On initialization, ATP generates TrainType according to DataPlugContent.CCTrainType from the CC data plug.
On initialization, ATP generates CoreId according to DataPlugContent.CCCoreId read from the CC data plug.
Core id for CC on the distant cab.
On initialization, ATP generates SubSystemId according to DataPlugContent.CC_SSID from the CC data plug.
According with train type, ATP software shall compute the VCP check words of the project vital setting DATA.VES, which generated by CC offline tools.
If check words are correct, ATP software shall read the vital setting and convert to the global variable ATPsetting according to the Table 61;
Otherwise, the ATP shall cease to run.
According with train type, ATP software shall read DATA.VES and detect the track map data with VCP which was generated by CC offline tools. If the data is correct, ATP shall generate TrackMap with the structure as refer to [REF11]; Otherwise, ATP cannot continue to operate.
Some parts of codes in DATA.VES, related to input and output functions, as project configuration data, ATP links them during initialization and generates Offline structure as Table 63, refer to [REF11].
SafeApplicationVersion stands for the version of ATP software. The version of ATP software is defined in source code. The version shall be update whenever the code changed.
After ATP gets the offline parameters and track map from the CC data plug, it needs to compare this information with the other CPU module, which represented by the term of IdenticalVersionOfDualCPU. If the information is as same, ATP shall set IdenticalVersionOfDualCPU as True; otherwise, it will set IdenticalVersionOfDualCPU as False. 
TrainType, the train type from data plug;
CoreId, the train end identification from data plug;
SubSystemId, the train identification from data plug;
TrackMap, the version number of each ZC region in line map;
ATPsetting, the version number for the configuration data;
SafeApplicationVersion, the version of ATP software.
After all above-mentioned information has corrected, and correspondingly, ATP will generate TrainKnown information. If TrainKnown considered as False, ATP shall set all output ports as restricted.
Through the communication with CCNV, ATP judges NonVitalRequestreceived from CCNV and generates NonVitalRequestReady If received a new message.
ATOcontrolTimeValid stands for the effectiveness of CCNV message. If there is no updating CCNV message past the CCNV_VALIDITY_CYCLES, ATOcontrolTimeValid is set as False.
ATP determines whether received a safety input message from VIOM1.
Through the communication, ATP gets the vital input message from VIOM1 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM1VitalInputsAvailable.
Records the survival time of received vital inputs from VIOM1.
ATP records the latest cycle time information of VIOM in END_1 by the term LatestVIOM1LoopHourVIOM.
In initialization, set LatestVIOM1LoopHourVIOM as the zero;
If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM1LoopHourVIOM as the viomLoopHour of the message. 
Otherwise, LatestVIOM1LoopHourVIOM keeps unchanged.
ATP determines whether received a safety input message from VIOM2.
Through the communication, ATP gets the vital input message from VIOM2 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM2VitalInputsAvailable.
During the calculation, the value i is either zero or one, which represents one of the two VIOM in the train END_2. 
Records the survival time of received vital inputs from VIOM2.
ATP records the latest cycle time information of VIOM in END_2by the term LatestVIOM2LoopHourVIOM.
In initialization, set LatestVIOM2LoopHourVIOM as the zero;
If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM2LoopHourVIOM as the viomLoopHour of the message. 
Otherwise, LatestVIOM2LoopHourVIOM keeps unchanged.
ATP determines whether the vital inputs message from VIOM1 valid.
ATP determines whether the vital inputs message from VIOM2 valid.
For four vital input messages from VIOM1 and VIOM2, ATP shall deal with it comprehensively and generate the IdenticalInputs information in this cycle for calculation of other modules, structured as . For both of VIOM message in the same END, ATP shall consider the reliability and use ¡°logic OR¡± for judge the status of each port:
If both of VIOM message from one train end is invalid, the IdenticalInputs of this end is also ineffective. 
If only one VIOM message from one train end is invalid, the IdenticalInputs is equal to this effective VIOM message.
If there is at least one VIOM message of a port is on permissive, ATP shall regard the corresponding port of this train END as permissive status. 
Otherwise, ATP shall regard this port as restrictive status in the IdenticalInputs.
CoupledByEnd1 or CoupledByEnd2 shows that both ends of train connect with other trains. If the project is not configured with the capture of coupling input, it is certain that the train does not connect with other trains.  
NOTES:
ATPtime stands for the ATP loop hour of this train END.
Based on CoreId, ATP initialize ATPtime as the initiative value of END_1 or END_2;
If the value exceeds the maximum loop hour, ATP shall set it as the initiative value; 
Otherwise, add one for each cycle. 
The message transmitted from the distant ATP in the other END shall be protected by check words. And before using the information, ATP shall verify the check words.
OtherATPmessageAvailable, ATP shall judge the effectiveness of message from the redundant ATP, shown as following pseudo-codes:
OtherATPmessageValid represents the effectiveness of the messages from redundant ATP. If this message is invalid, ATP will set OtherATPmessageValid as False; otherwise, it is set as True. 
The OtherATPminTime stands for the local ATP maintained minimum time of the redundant ATP. The setting rule is as following:
In initialization, ATP set the OtherATPminTime as default value based on the CoreId of the redundant ATP.
Or else:, if the updating message from the new redundant ATP in this cycle is available, ATP will update OtherATPminTime as the current time in the message. 
Or else:, if the redundant ATP message is still effective, ATP will add 1 in the OtherATPminTime until it is out of bound, and set is as initialization value. 
Or else:, If the received a new redundant ATP message, but it was not available, ATP shall update OtherATPminTime as in the message.
Otherwise, accumulate OtherATPminTime.
The OtherATPmaxTime stands for the local ATP maintained maximum time of the redundant ATP. The rules to update OtherATPmaxTime are similar with OtherATPminTime except that when received a new message from the redundant ATP, the OtherATPmaxTime shall add the maximum transmission delay in network.
OtherATP, parse and store messages from the distant ATP.
In initialization or the message has expired, set all variables as default value;
when new message available, set the corresponding value from the new message;
otherwise, remain unchanged.
BlockModeUsed represents that either of train end chooses BM mode. 
The status of BMvariantValidWhileTemporallyValid shows whether it is in the BM mode.
BeaconVariantsUpdating used to determine ATP whether to update the BM variants in this cycle.
If all the following conditions are fulfilled, ATP shall set BeaconVariantsUpdating as True:
The current operational mode is BLOCK MODE;
And train moved and ATP received a BM beacon in this cycle;
And the train is either not localized, or the direction of the BM variants is as same as the orientation of the train front end.
Otherwise, ATP shall set BeaconVariantsUpdating as False.
The structure of array ATP stored BMbeaconVariants are ST_BM_VARIANT. The rules to update the BM variants are as follows:
if the BMbeaconReadAge is larger than the ATPsetting.VariantsBMfullValidityTime, ATP shall set all BM variants as restricted status.
Else If the BeaconVariantsUpdating is True, then ATP update the BMbeaconVariants by the new beacon.
Otherwise, keep BMbeaconVariants unchanged.
NOTES:
There is a situation that ATP read one BM beacon as the second beacon for ATP initializing location, and the direction of this BM beacon is opposite with the train movement.
UsedBMbeaconId records the used BM variants came from which BM beacon:
When one of the following conditions fulfilled, ATP clear the UsedBMbeaconId:
initialization,
the BLOCK MODE variant is not temporally valid,
the direction of the used BM beacon is not as same as train front orientation,
the train is not localized.
Or else:, when received a valid BM beacon, ATP update UsedBMbeaconId;
Otherwise, keep this value unchanged.
NOTES:
ATP shall use the more recent message from beacons and CBI radio.
The local ATP shall compare the information from the redundant ATP to ensure the consistency, which includes versions of vital software, project configuration data and the track map. 
ZCmessageReady represents that an available EOA and variants message from ZC received in this cycle.
LastEOAReportAge represents the value calculated by current ATP time minus the previous loc-report number and the EOA consuming time in ZC. 
EOAgroundAge stands for the number of CC cycle when receiving the EOA information.
VariantGroundAge shows the survival time of the variants in ZC.
In the CBTC mode, ATP gets the variants by parse the ZC message. The variants sending from ZC are categorized by line section. Moreover, it will send the line section variants in the current ZC area and the adjacent one. ATP will record and check the variants and maintains the time effectiveness.
ATP shall maintain the validation of CBTC variants message from ZC. if the validation timeout, ATP should set all CBTC variants to restrictive state.
OdometerImm records the changes of VPBWrite register in each interrupt, structured as Table 56.
In the interrupt, when the TopLocValid detected by VPB board regarded as True, OdometerImm.TopLocValid and BeaconMsgReady set as True. Adding TopLocCounter, the data from beacon savor is saved into BeaconMsgByte[MAX_BEACON_DATA_SIZE].
SensorTestFlag regarded as the symbol whether ATP in CPU 1 needs to check the sensor. In the interval, if the value of CBKWrite.CogCounterReg is not changed in the continuous SENSOR_TEST_START_TIME, and the WheelFilteredStopped was False at last cycle, the ATP of CPU1 in VLE-2 board need to set SensorTestFlag as True and send the data to the ATP of CPU2.
For the ATP of CPU1 in VLE-2 board, if it sets the SensorTestFlag of pervious end of cycle as True, it need to set the value of OdometerImm.D1/D2/D3 based on the settled sequence in each interrupt, and set the SensorTesting as True.
D1/2/3 shall set to POWER_ON at every other interrupts;
In other interrupt, D1/2/3 shall be set to pseudo random value.
For the ATP of CPU2, if the SensorTestFlag from CPU1 is True, it needs to read the D1/2/3 registers of VPB-2 board and obtain the current testing value of D1/2/3.
During the sensor test performing, both ATP in the two CPUs of VLE-2 shall detect the consistency of the test result according to the state of C1/2/3 in the two continuous interrupt. Accordingly, ATP determines the state of three sensors: A1, A2, A3.
if D(i-1)= POWER_ON & Ci=LOW_LEVEL£¬Ai = SENSOR_BLOCKED
if D(i-1)= POWER_ON & Ci=HIGH_LEVEL£¬Ai = SENSOR_CONDUCT
if D(i-1)= POWER_OFF & Ci=HIGH_LEVEL£¬Ai = SENSOR_WRONG
In the interrupt i, the rules to determine whether the state of a sensor Ai is SENSOR_CONDUCT or SENSOR_BLOCK are as follows:
if D(i-1)= POWER_ON & Ci=LOW_LEVEL£¬Ai = SENSOR_BLOCKED
if D(i-1)= POWER_ON & Ci=HIGH_LEVEL£¬Ai = SENSOR_CONDUCT
if D(i-1)= POWER_OFF & Ci=LOW_LEVEL£¬keeps Ai as last status: Ai = Ai(t-1) 
if D(i-1)= POWER_OFF & Ci=HIGH_LEVEL£¬Ai = SENSOR_WRONG
Based on the above three sensors¡¯ status A1/2/3, ATP determines the status of the odometer as following conditions:
If any one of A1/2/3 is SENSOR_WRONG, then ATP consider the odometer as error in this interrupt and set the OdometerImm.TestResultas TEST_INCONSISTENT;
If all of A1/2/3 are SENSOR_CONDUCT, then ATP consider the odometer as error in this interrupt and set the OdometerImm.TestResultas TEST_INCONSISTENT;
If all of A1/2/3 are SENSOR_BLOCKED, then ATP consider the odometer as error in this interrupt and set the OdometerImm.TestResultas TEST_INCONSISTENT;
If all of A1/2/3 are as same as the result at last interrupt respectively, then ATP consider the odometer as stop in this interrupt and set the OdometerImm.TestResultas TEST_STOPPING;
If the TEST_STOPPING has lasted more than SENSOR_TEST_IMMOBILE_THRESHOLD, the ATP consider the odometer standstill, and set OdometerImm.TestResultas TEST_IMMOBILE;
If any one of A1/2/3 is different with the result at last interrupt, then ATP consider the odometer rolling, and set the OdometerImm.TestResultas TEST_FLOATING.
When the odometer test result is either TEST_INCONSISTENT or TEST_FLOATING, ATP shall stop the sensor test and set OdometerImm.SensorTestingas False for this interrupt, and set SensorTestFlag as False for this cycle.
Because of the design restriction, only the FPGA1 in the VPB-2 board can send the testing sequence D1/2/3 to the sensor, and meanwhile the FPGA1 will forward the info to the FPGA2 in the VPB-2 so that the CPU2 in the VLE-2 can read. Both of the FPGA in the VPB-2 board will have the same process for the sensor testing result C1/2/3.
In the specific T_LOCK_ODOMETER, the OdometerImm of all intervals need to be saved into LockedOdometer[ATP_INTERRUPT_NB] with the index as ImmediateNb; The value of BeaconMsgReady, TopLocCounter and BeaconMsgByte should be recorded by using LockedBeaconMsgReady, LockedTopLocCounter and LockedBeaconMsgBytefor the main task.
The ATP software in different CPUs shall synchronize the information get from the VPB board, with following rules: 
For CogCounter:
If the CogCounter read by two CPUs are different at the same interrupt, ATP shall take the large one as the result;
ATP shall use the CPU's CogCode as same as CogCounter.
For TopLocValid:
Only the cog counter latched by TOPLOC is between the before and after cog counter , TOPLOC is considered valid
If the top-loc happened in adjacent interrupt between two CPUs, the former one shall use to calculate the CogPositionBeforeTopLoc, and the latter to calculate the CogPositionAfterTopLoc;
If the top-loc difference are more than one interrupt, ATP shall consider it as invalid.
BeaconChecksumFailure judges whether the checksum of beacon message is correct or not. 
In the main task, if LockedBeaconMsgReady is True, LockedBeaconMsgByteneed to be detected, including validity of ATCkey and calculation of the SACEM checksum of beacon.
ATP shall reject each beacon message which vital checksum is corrupted.
In the main task of ATP, if the status of LockedBeaconMsgReady in the interrupt is True, and the BeaconChecksumFailure is False, ATP shall set the BeaconMessageReceive as True; and vice versa. If ATP receives more than one beacons in this cycle, it will deal with the last beacon and based on this data to update the BeaconMessageReceive.
BeaconCount represents the accumulated number of received Top-loc signal from power on to current cycle.
If the BeaconMessageReceive is True, ATP shall parse the value of LockedBeaconMsgByte and generate BeaconMessage with structure as ST_BEACON_MSG:
If the status of BeaconMessageReceive is True, the BeaconMessage.ID is obtained by LockedBeaconMsgByte; Otherwise, keep it unchanged.
If the BeaconMessageReceive is True, the variants is come from LockedBeaconMsgByteand ATP set as BeaconMessage.Variants[MAX_BM_VARIANT_NB]; if there is no beacon read at the end of cycle, there is no changes.
BM_VARIANTS_BIT_0...BM_VARIANTS_BIT_15 represents the index of BM beacon variants defined in [REF4].
If the BeaconMessageReceive is True, the default message is judged by LockedBeaconMsgByteand ATP set the BeaconMessage.DefaultMessage; if there is no new beacon read, it keeps unchanged.
DEFAULT_MESSAGE_BIT represents the index of beacon that judges default message, which defined in the [REF4].
If the BeaconMessageReceive is True, it is feasible to judge whether the variants are available through LockedBeaconMsgByte and ATP set as BeaconMessage.BlockModeVariantAvailable; If there is no new beacon read, it keeps invariable. 
BLOCK_MODE_VARIANT_AVAILABLE_BIT stands for the index of the beacon variants in the beacon message defined in [REF4]. 
At each cycle, ATP shall provide to beacon device the ATCkey in order to be able to control message freshness.
The ATP software needs to calculate the expected cog code with 8 bits, according to the encoding characteristic of the disc code and the direction of odometer rotation.
When the odometer initialization, the expected CompCogCode shall be set as initial CogCode;
Since then, for one cog rotated in interrupt, the corresponded bit shall be shift as following rules:
if the cog increased in adjacent interrupts, the CompCogCode shall be shift a bit toward right from high to low; shift out the lowest one and set the new highest bit as C4array[C4ArrayIndex], and update C4ArrayIndex.
otherwise, if the cog decreased, the CompCogCode shall be shift a bit toward left from low to high; shift out the highest bit and set the C4array[C4ArrayIndex] as the new lowest one, and update C4ArrayIndex accordingly.
In which, C4ArrayIndex is the current cog index, ranging from 0 to 99. C4array[C4ArrayIndex] is the array of disc codes, "1" meaning conduction and "0" indicating blocked, for details see [REF4].
ATP determines the odometer position ready according to the matching of the CompCogCode and CogCode locked in each interrupt.
In initialization, the OdometerCogPositonReady shall be False;
Or else:, if the OdometerCogPositonReady was False, then only after the odometer rotated reversely or WheelFilteredStopped and re-turned continuous toward the same direction after 8 cogs, ATP shall re-initialize the Counter-Code matching relation and set OdometerCogPositonReady as True;
Or else:, if CogCode is different with CompCogCode in one of interrupt of the cycle, ATP shall set OdometerCogPositonReady as False;
Otherwise, ATP keep OdometerCogPositonReady unchanging.
TeethCounter used as the odometer cog value in one deferred task, which is the difference of the CogCounter in the last interrupt of adjacent cycle. The calculation of the TeethCounter shall consider the installation direction of the odometer and the register range of the CogCounter.
NOTES:
TeethCounter is a signed value. If TeethCounter greater than 0, then means the odometer rotating toward to the train END_1 direction; other hand, if it less than 0, then means the odometer rotating toward to the END_2.
If a beacon with top-loc received in this cycle, ATP shall record the cog position of the interrupt when and just before the top-loc happen:
CogPositionBeforeTopLoc, the CogCounter in the interrupt just before the top-loc happen;
CogPositionAfterTopLoc, the CogCounter in the interrupt when the top-loc happen.
Which, i means the interrupt received top-loc signal.
If all interrupts in one cycle are sensors testing, ATP shall set SensorTestPerformed. Otherwise, set SensorTestPerformed as False.
SensorSequenceDetected_1£¬SensorSequenceDetected_2£¬SensorSequenceDetected_3£¬
If sensors testing performed in this cycle, ATP shall determine the conduction state of each sensor:
If all test results of every interrupts for this sensor are SENSOR_CONDUCT, ATP shall set sensor sequence detected for this sensor;
Otherwise, does not set this sensor sequence detected.
If sensors testing do not perform, ATP does not set any sensor sequence detected.
ATP shall check consistency of sensors whether sensor testing performed or not. Sensors testing result shall declare inconsistent at cycle k (UnconsistentSensorTest) if the following conditions are fulfilled:
Sensors test done at cycle k, and no sequence has been detected on any of the three sensors C1, C2, C3 (SENSOR_BLOCKED)
Or at cycle k, the expected sequence is detected on all three sensors C1, C2, C3 (SENSOR_CONDUCT).
Or any of the three sensors is tested as error (SENSOR_WRONG).
Wheel shall consider safely stopped WheelStopped at cycle k if the following conditions are fulfilled:
sensors test has been performed,
and at least one sensor out of three sensors C1, C2, C3 has detected expected sequence,
and at least one sensor out of three sensors C1, C2, C3 has not detected expected sequence,
and sensors test result combination on three sensors C1, C2, C3 has not changed between cycle k-1 and k.
At cycle k, WheelFilteredStopped shall change from False to True on raising edge of WheelStopped information, That is, if:
WheelStopped information was False at cycle k-1,
and WheelStopped information was True at cycle k.
and then:
LastStopCogPosition is assigned to TeethCounter,
At cycle k, WheelFilteredStopped shall change from True to False, according following expression:
the cog moved more than one cog;
ATP shall detect whether the cog number counted in adjacent interrupt is greater than the default maximum cog number on cycle or on interrupt.
NOTES:
If the calculated movement exceeds the default one, ATP shall set the wheel kinematics invalid.
From power-up, ATP shall consider that OdometerState is "NOT_INITIALIZED ".
If OdometerState is NOT_INITIALIZED at cycle k, and if wheel detected stopped at cycle k, then WheelMinimumMovement and WheelMaximumMovement shall be set to zero.
At cycle k, ATP shall consider that OdometerState changes from NOT_INITIALIZED to WAITING_COG_POSITION_CODE_READY if:
a falling edge is detected on WheelFilteredStopped information,
and sensors test is consistent at cycle k and was consistent at cycle k-1,
At cycle k, ATP shall consider that OdometerState changes from NOT_INITIALIZED to INVALID
if sensors test is not consistent at cycle k.
ATP shall accumulate the time for waiting cog position ready state.
At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to NOT_INITIALIZED if:
wheel is detected stopped (WheelFilteredStopped),
and cog position remains unknown (not OdometerCogPositionReady),
and there is no sensors test inconsistency,
and time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is strictly less than ATPsetting.OdoInitTimeout
At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to INITIALIZED
If:
Cog position is safely known which means that wheel angular position is well-known;
and there is no sensors test inconsistency;
and time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is strictly less than ATPsetting.OdoInitTimeout.
At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to INVALID if:
sensors test inconsistency is detected,
or time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is more than or equal to the ATPsetting.OdoInitTimeout
When odometer is initializing, wheel movement shall be over and under estimated considering maximum acceleration per cycle according with the train front:
At cycle k, ATP shall consider that OdometerState changes from INITIALIZED to INVALID if:
OdometerState was evaluated Initialized at cycle k-1,
And:
Sensors test result is inconsistent;
Or neither wheel filtered stopped nor cog position ready.
Wheel angular movement is the rotation movement observed on the wheel in cog count from cycle k-1 to k. Angular movement of the wheel can convert into a linear movement by taking into consideration of the uncertainty on wheel diameter measurement provided by calibration process. WheelMinimumMovement and WheelMaximumMovement represents respectively minimum and maximum curvilinear distance ran between cycle k-1and k by a reference point of the wheel located on the rolling circumference.
If motion and speed are available at cycle k, then wheel curvilinear movement calculates as follows:
NOTES:
When odometer cog-counter-code matched, regardless of ATP in END_1 or END_2, and no matter the activation of train front, the direction towards END_1 is always be set as the positive direction. That is, when the movement is greater than 0, indicating the direction of the train is running to END_1, and vice versa to END_2.
At cycle k, ATP shall consider that OdometerState changes from INVALID to NOT_INITIALIZED if:
OdometerState was evaluated Invalid at cycle k-1,
and wheel is detected stopped (WheelFilteredStopped),
and there is no sensors test inconsistency.
In invalid status, ATP shall calculate wheel movement by using measured value of the odometer.
ATP shall invalidate wheel kinematic if minimum odometer motion is null and sensors test is not performed for more than ATPsetting.OdoTestContradictionDuration.
Wheel kinematic is valid if odometer is valid, the calculated motion is not greater than the default value, and there is communication with odometer.
ATP calculates the maximum wheel speed according to the maximum wheel movement; this value is non-negative and rounded up.
When wheel motion and acceleration are measurable, then instantaneous acceleration computed according following expression:
FilteredWheelAcceleration measurement is the average of InstantaneousWheelAcceleration over FILTERED_ACCELERATION_NB cycles for filtering the fluctuation causing by the sampling period.
When wheel motion and acceleration are measurable, sliding average acceleration at cycle k defined by following expression:
ATP records the maximum movement when the state transferring from COASTING to BRAKING or SLIDING, or from BRAKING to SLIDING.
ATP shall record the reversed motions during the braking or sliding state.
If the reversed motion during braking or sliding state is greater than a project defined distance, ATP shall consider the motion sign changed.
ATP shall record the speed when the train begins to slide.
ATP shall record how many cycles staying in SLIDING state.
ATP software shall use the over-estimation model for train movement provided by Figure 58 state-diagram. The maximum and minimum train motion shall overestimate based on different state as follows:
COASTING. There is not sliding effect during on train coasting or motoring, so ATP need not to overestimate train motion.
BRAKING. When train brakes, which means the measured acceleration is less than the ATPsetting.BrakingStartAcc (normally -0.3m/s^2), ATP shall overestimated the maximum train motion 15% at most.
SLIDING, When the measured acceleration is less than the ATPsetting.SlidingStartAcc (-2.5m/s^2 normally) or the average acceleration is less than ATPsetting.BrakingStartAcc, ATP shall use the train motion before SLIDING as the current train motion.
SKIDDING, If train slides or slips excessively, ATP shall consider odometer motion untrustworthy.
The state transfers from ¡°COASTING¡± to ¡°BRAKING¡± when: 
The MotionOverEstimationState transfers from ¡°COASTING¡± to ¡°SLIDING¡± when: 
The MotionOverEstimationState transfers from ¡°BRAKING¡± to ¡°SLIDING¡± when: 
The MotionOverEstimationState transfers from ¡°BRAKING¡± to ¡°COASTING¡± when:
The MotionOverEstimationState transfers from ¡°SLIDING¡± to ¡°COASTING¡± when:
The principle of overestimation in SLIDING state based on the following assumptions:
Because the threshold deceleration (the typical value is -2.3m/s^2) used to detect sliding is far less than the full service braking deceleration (normally -1m/s^2), it is not possible to reach the SLIDING state unless the emergency brake applied. The project guaranteed that the absolute value of the minimum emergency brake deceleration is greater than the acceleration due to track gradient, and the rolling stock must cut off the traction during EB applied. Therefore, during SLIDING state, the real speed of the train must gradually reduce. However, if the measured absolute value of the wheel deceleration is too large or too long in the sliding conditions, ATP shall consider the overestimation algorithm as failure.
At cycle k, if motion overestimation status is SLIDING, ATP shall consider that sliding effect is ended (SlidingEnded) if FilteredWheelAcceleration is strictly less than ATPsetting.SlippingStopAcc and strictly greater than ATPsetting.SlidingStopAcc for more than ATPsetting.SlidingGripRecoveryTime.
The MotionOverEstimationState transfers from ¡°SLIDING¡± to ¡°BRAKING¡± when:
At cycle k, if motion overestimation status is SLIDING, ATP shall consider that sliding is excess (SlidingExcess) if FilteredWheelAcceleration is strictly less than ATPsetting.SlippingStopAcc and strictly greater than ATPsetting.SlidingStopAcc for more than ATPsetting.SlidingExcessTime.
The MotionOverEstimationState transfers from SLIDING to SKIDDING when:
Because the application of anti-lock braking system for the train of current project, makes the brake acceleration cannot continuous less than ATPsetting.SlidingStopAcc for serious cycles. Therefore, if there was an unexpected instantaneous acceleration less than ATPsetting.SlidingStopAcc, and the after cycles' acceleration met the criteria of SlidingExcess, then the following two conditions can hold simultaneously.
The MotionOverEstimationState transfers from SKIDDING to COASTING when: 
ATP records the minimum movement when the state transferring from COASTING to BRAKING or SLIDING, or from BRAKING to SLIDING.
In BRAKING state, the maximum train motion overestimated as ATPsetting.SlidingCoefficient (15% normally) at most. If the overestimated motion has greater than the start braking movement, ATP shall use the start breaking movement as the current train motion. That said the train speed during braking could not faster than before.
In state SLIDING:
If both WheelMaximumMovement and StartBrakingMovementMax are same direction, and the absolute value of the former is greater than the absolute value of the latter, indicating that due to the sampling error makes the measured movement greater than StartBrakingMovementMax. In this case, ATP shall uses WheelMaximumMovement as current train maximum motion.
Otherwise, uses StartBrakingMovementMax as train maximum motion.
In other state (COASTING, SKIDDING), uses measured wheel maximum movement as current overestimated maximum train motion.
ATP shall record the speed when the train begins to slip.
ATP shall record how many cycles staying in SLIPPING state.
If the project that odometer installed on the traction axle of the train, ATP shall consider the slipping effect to impact the underestimation of measured wheel movement.
ATP software shall use the over-estimation model for train movement provided by Figure 59 state-diagram. The maximum and minimum train motion shall overestimate based on different state as follows:
COASTING. There is not sliding effect during on train coasting or motoring, so ATP need not to overestimate train motion.
MOTORING, normal traction state (only consdering odometer installed on motorized axle).
SLIPPING, wheel slipping happen (only consdering odometer installed on motorized axle).
SKIDDING, If train slides or slips excessively, ATP shall consider odometer motion untrustworthy.
The MotionUnderEstimationState transfers from ¡°COASTING¡± to ¡°MOTORING¡± when:
The MotionUnderEstimationState transfers from ¡°COASTING¡± to ¡°SLIPPING¡± when: 
The MotionUnderEstimationState transfers from ¡°MOTORING¡± to ¡°SLIPPING¡± when:
The MotionUnderEstimationState transfers from MOTORING to COASTING¡± when: 
The MotionUnderEstimationState transfers from SLIPPING to COASTING when:
The MotionUnderEstimationState transfers from SLIPPING to MOTORING when:
The MotionUnderEstimationState transfers from SLIPPING to SKIDDING when:
The MotionUnderEstimationState transfers from SKIDDING to COASTING when: 
ATP records the minimum movement when the state transferring from COASTING to MOTORING or SLIPPING, or from MOTORING to SLIPPING.
For calibration validation purpose, ATP shall consider that slip/side detected if:
motion overestimation modeling status is not coasting nor braking,
or motion underestimation modeling status is not coasting nor motoring.
When the overestimation or underesimation state is SKIDDING, or the motion signed changed in BRAKING or SLIDING state, ATP shall consider the overestimation model as fault.
If overestimation model was fault, then ATP considers the model invalid. 
ReferenceSpeedUnderThreshold_1 defines whether the referenced speed 1 from CCNV is lower than a configurable threshold.
ReferenceSpeedAvailable_1 defines whether the referenced speed 1 from CCNV is valid or not. 
ReferenceSpeedUnderThreshold_2 defines whether the referenced speed 2 from CCNV is lower than a configurable threshold. 
ReferenceSpeedAvailable_2 shows whether the referenced speed 2 from CCNV is effective or not. 
The independent source of odometry reference 1 said to disable if following conditions reached:
local source of odometry is available (ValidWheelKinematic),
and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,
and source of odometry reference 1 is available,
and odometer reference 1 indicates that train speed is less than reference speed threshold.
The independent source of odometry reference 2 said to disable if following conditions reached:
local source of odometry is available (ValidWheelKinematic),
and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,
and source of odometry reference 2 is available,
and odometer reference 2 indicates that train speed is less than reference speed threshold.
The independent source of odometry reference 1 said to enable if following conditions reached:
local source of odometry is available,
and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,
and source of odometry reference 1 is available,
and odometer reference 1 indicates that train speed is greater than reference speed threshold.
The independent source of odometry reference 2 said to enable if following conditions reached:
local source of odometry is available,
and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,
and source of odometry reference 2 is available,
and odometer reference 2 indicates that train speed is greater than reference speed threshold.
The independent source of odometry reference 1 is said to be out of order if it is possibly disabled during more than ATPsetting.OdoLockedAxleDisablingLatency.
When the independent source of odometry reference 1 had out of order, it considered not out of order one if the source of odometry reference 1 is possibly enabled during more than ATPsetting.OdoLockedAxleEnablingLatency:
The independent source of odometry reference 2 is said to be out of order if it is possibly disabled during more than ATPsetting.OdoLockedAxleDisablingLatency.
When the independent source of odometry reference 2 had out of order, It considered not out of order one if the source of odometry reference 2 is possibly enabled during more than ATPsetting.OdoLockedAxleEnablingLatency:
The source of odometry reference 1 said to be contradictory with local source of odometry if:
local source of odometry is available (ValidWheelKinematic)
and OdometerSpeedUnderThreshold indicates that wheel speed is less than reference speed threshold,
and source of odometry reference 1 is available and not out of order,
and odometer reference 1 indicates that train speed is greater than reference speed threshold.
The source of odometry reference 2 said to be contradictory with local source of odometry if:
local source of odometry is available (ValidWheelKinematic)
and OdometerSpeedUnderThreshold indicates that wheel speed is less than reference speed threshold,
and source of odometry reference 2 is available and not out of order,
and odometer reference 2 indicates that train speed is greater than reference speed threshold.
Odometer axle shall consider possibly locked if:
Both independent sources of odometry indicates a contradiction with local odometer,
Or one source of odometry is contradictory and the other one is out of order (or not available).
If AxlePossiblyLocked situation lasts more than ATPsetting.OdoLockedAxleTimeout, the odometer axle shall be considered locked. Once UnrecoverableAxleLocked set to True, it will stay at state True unless ATP re-initialized.
If only one or no source of odometry is available, then ATP shall invalidate kinematic while this situation lasting.
Wheel and train kinematic shall consider correctly correlated if and only if:
odometer axle is not detected locked,
and odometer axle detection is available
Train kinematic information shall declare invalid if at least one of following condition is True:
odometer kinematic is not valid,
or neither radar speed nor over-estimation modeling of train movement is valid,
or train movement and wheel movement has been detected de-correlated.
TrainStopped, train shall consider strictly stopped if and only if:
wheel is detected strictly stopped,
and train kinematic elaboration is valid,
and wheel is not detected sliding.
Train shall consider stopped with the tolerance of one cog detection if:
wheel is detected at filtered stop,
and train kinematic elaboration is valid,
and wheel is not detected sliding.
According to the matching of odometer cog counter and code, maximum train speed shall computed using the followings expressions:
NOTES:
If a valid beacon with top-loc received between cycle k-1 and k, then minimum and maximum distance ran since top-loc shall evaluate as the difference between current teeth counter and recorded cog position just before or after top-loc. If there is no beacon received, ATP updates distances from last beacon using the train movements.
NOTES:
As shown in Figure 510, the odometer calibration state divides into the following four states:
CALI_WAITING, the state of not calibrated or calibration has failed, waiting for read the MTIB1 beacon.
CALI_MEASURING, after read MTIB1 and waiting for read MTIB2.
CALI_VALIDATING, after read MTIB2 and waiting for the verifying RB.
CALI_COMPLETED, calibration has been verified by the RB successfully.
The following variables shall update during calibration:
MaxCogCalibration, the overestimated calibration for each cog;
MinCogCalibration, the underestimated calibration for each cog;
CalibrationState, the state of calibration.
From power-up and while calibration process is not successfully performed, ATP shall use default calibration to compute train motion and shall consider itself in the state of waiting for the first beacon belonging to a couple of calibration.
If ATP is in the state of CALI_WAITING, can transform to the measuring state if following conditions fulfilled:
a valid beacon has been received and this beacon belongs to a couple of calibration,
and train kinematic was valid,
and no excessive slip/slide effect was detected,
and WheelMinimumMovement is not null,
Then, ATP shall memorize:
position of the wheel before and after top location signal of received beacon
the ID of received beacon,
the sign of the movement when crossing beacon,
and shall consider itself as CALI_MEASURING.
If ATP is in the state of CALI_MEASURING and following conditions fulfilled:
a valid beacon has been received and the beacon and first memorized calibration beacon is one of possible dedicated couple of calibration,
and train kinematic was valid,
and no excessive slip/slide effect was detected,
and sign of train motion is still identical to thus detected on first beacon signaling,
Then,
if resulting calibration range is included in default calibration range, then ATP shall:
memorize:
position of the wheel before and after top location signal of received beacon,
the id of received beacon,
and shall consider itself as CALI_VALIDATING.
else: ATP shall consider that calibration process has failed and back to CALI_WAITING.
Among them, the measured maximum and minimum calibration fetches from the offline-generated counter-calibration table, based on the calculated cog counter.
The CaliMinRation and CaliMaxRation are elements of structure MTIB generated by offline tool for each couple of calibration beacons. Refer to [REF11] for the definition of MTIB.
If ATP is in the state of CALI_MEASURING and following conditions fulfilled:
train kinematic has been detected not valid,
or excessive slip/slide effect has been detected,
or WheelMinimumMovement sign is in the opposite direction of thus observed on first beacon or becomes null,
or an unexpected beacon has been received. That is, a beacon not belonging calibration measurement couple.
Then, ATP shall abort calibration process and back to CALI_WAITING.
If ATP is in the state of calibration validation in progress and following conditions fulfilled:
train kinematic has been detected not valid,
or excessive slip/slide effect has been detected,
or WheelMinimumMovement sign is in the opposite direction of thus observed on first beacon or becomes null,
or an unexpected beacon has been received. That is, a beacon not belonging calibration validation couple.
In such case, then ATP shall consider that calibration process as not sable and so back to CALI_WAITING.
If ATP is in the state of calibration validation in progress and following conditions fulfilled:
a valid beacon has been received and this beacon is one of possible confirmation beacons related to second beacon signaled of calibration measurement,
and train kinematic was valid,
and no excessive slip/slide effect was detected,
and sign of train motion is still identical to thus detected on first beacon signaling,
and WheelMinimumMovement is not null.
Then,
if resulting calibration range fully includes the calibration range in track map, then ATP shall:
update ATP minimum and maximum calibration with last calibration computed on beacons,
and shall consider that calibration process is CALI_COMPLETED.
else: ATP shall consider that calibration process is not usable and so back to CALI_WATING waiting for new measurement calibration beacons.
If the calibration completed, ATP shall not calibrate when new calibrating beacons read.
The orientation of the train END means the UP or DOWN orientation which this END toward to. When a pair of consecutive beacon read, ATP can determine the orientation for each train END according to the direction of these beacons in track map and the direction of train movement.
On a balloon loop, a train can run to the reverse direction without having to shunt or even stop, refer to Figure 513,which means there are inconsistent orientations for two train ENDs (both END_1 and END_2 are toward to UP or DOWN).
If a valid beacon read, ATP shall calculate actual maximum and minimum location of the END_2 according to the beacon location in track map, the distance from beacon antenna to the END_2, the distance after top-loc, the orientation of END_2 and the direction of train movement. The beacon location indicate the actual external location of the END_2.
NOTES:
Only when ATP and redundant ATP are all in filtered stopped state, can ATP use redundant ATP location for initialization.
ATP determine the initial train location by redundant ATP, memorized location and beacon location in order. If train delocalized, the train location should be clear.
If train has localized on the track map, according to the orientation of END_2, ATP using the maximum and minimum train motion to update the external or internal location of the END_2.
ATP shall determine whether there is an unknown-status point intersecting with the train location.
If the train has localized at the previous cycle, and fulfills one of the following conditions:
There is an unknown-status divergence of convergence located in the range from train tail to train head, then ATP shall set as True;
Or else:, if there is a convergence with reverse route located in the range from train tail to train head, the ATP shall set as True;
Or else, train crossed the boundary of ATC area, shall set as True.
Otherwise, set as False.
ATP shall determine the correct order of the external and internal location of train END.
ATP shall calculate the uncertain distance between the external and internal locations of train END_2.
If either of ends can ensure the train integrity, ATP shall set TrainUnitIntegrity as True. If the project is not configured with the capture of train integrity, it is sure that the train can guarantees the integrity.
If the localization state is not NOT_LOCALIZED, ATP shall determine whether the localization fault happens or not, according to the following pseudo-codes:
Only the localization state is LOCALIZED, ATP shall consider the train has localized.
When the train passed the continuous two beacons, ATP can judge the initial location and direction according to the position and the sequences of above-mentioned beacons in track map. Later, ATP can update the train location in the track map in each cycle based on the train movement combined with sliding overestimation and wheel block consideration. If ATP received a new beacon, it will realign the train location according to this beacon. For safety, ATP needs to maintain the location information from the external and internal side of each train end.
ATP shall consider the driver is in this cab if it captures that either end of cab activated, which shown by the data from DriverInCab_1 or DriverInCab_2.
If the active status is different between two ENDs of the train, ATP consider there is a driver in train.
NonVitalSelectedFrontEnd represents the train front choice from CCNV. 
If there is a driver in the train, the train front is the activated END. or else: the front determined by CCNV.
 Otherwise, the train front is the default one or the front one when train is moving.
The train front orientation is the orientation of the active train END.
ATP updates the train front location according to the active train END.
ATP updates the train rear locations according to the active train END.
In BM mode, if train localized but EOA is invalid, LocationPathKnown cannot be TRUE when train cross switch. After train crossed switch and relocalized by beacon successfully, LocationPathKnown can be set to TRUE.
NOTES:
ATP shall send the current localization status to the ZC.
ATP shall send the status of the localization status whether confirmed.
Only when train has moved and filtered stopped in sleeping zone, can ATP writing memorized location information.
When train has moved and does not fulfill the condition of writing memory location, ATP shall clear memorized location information.
RestrictiveSignalOverrun, ATP shall determine whether the location of maximum train head overruns a restricted signal in BLOCK mode.
When all of the following conditions fulfilled, ATP considers the train has overrun a restricted signal in this cycle, and set RestrictiveSignalOverrun as True.
Train has localized;
And the current type of EOA is BLOCK_MODE_EOA;
And RestrictiveSignalOverrun was False at the last cycle;
And the moving direction in current cycle is toward on the train front end;
And the maximum location of train front end passes the position of the signal in this cycle;
And the status of the signal is restriction or overlap established.
Otherwise, ATP set RestrictiveSignalOverrun as False.
NOTES:
If current EOA is valid and whose orientation is END_1, ATP shall authorize the train can move toward END_1.
If current EOA is valid and whose orientation is END_2, ATP shall authorize the train can move toward END_2.
ATP shall map the TSR message received from LC to structure of block. It need to judge whether there is corresponding TSR for each BLOCK in the track map. If yes, ATP shall update the abscissa of the starting and ending points, as well as the restriction speed. During the process, it need to transfer the abscissa and speed unit of TSR message to the corresponding one used in ATP.
For TSR processing, the iTC system supports only one TSR at one BLOCK at most. The beginning and the termination point of the TSR can be set any position in this block. However, it never sustains the situation that there are more than one TSR in one block.
If EOA is valid, ATP shall calculate the distance and the speed of the train moved after traction cutoff period ( ), according to the current train maximum speed, the maximum acceleration of traction and the maximum acceleration of the gradient.
If EOA is valid, ATP shall calculate the distance and the speed of the train moved after the traction cutoff period plus emergency brake applied period ( ), according to the current train maximum speed, the maximum acceleration of traction and the maximum acceleration of the gradient.
ATP shall calculate the train energy where EB indeed applied. The calculation shall consider the kinetic energy and the error of the potential energy. 
The ATPsetting.MPauthAltitudeMaxErrorEnergy means an algorithm error caused by offline tool to calculate the compensation gradients.
NOTES:
If the train tail intersected with a PSR (or TSR) area, and the speed of train is lower but the V2EbApplied is higher than the limitation. In accordance with the above approach will result in EB, although when the train runs to the EB applied position, the train may have left the PSR area.
According to the status of TSRcontrollinhibition, ATP can judge whether it is necessary to handle TSR information.
[iTC_CC_ATP-SwRS-0318] 
ATP shall determine whether train exceeds the vital speed limitation of the restrictive zone, by comparing the energy between the energy of the train and the energy of the zone.
ATP shall determine whether train exceeds the vital speed limitation of the restrictive point,  by comparing the energy between the energy of the train and the kinetic added potential energy of the point.
If the train energy exceeds the zone of point vital speed limitation, ATP shall consider the train possibly over energy.
If the RMF or RMR mode selected, ATP shall not monitor the train energy.
ATP shall request emergency braking if train is possibly in over-energy and train speed control enabled and if following conditions fulfilled:
the train is not detected at filtered stop,
or the train is detected at filtered stop and:
safe immobilization customization setting for this control indicates to use emergency brake,
or safe immobilization customization setting for this control indicates to use emergency brake when it was already applied.
ATP shall request parking braking if train is possibly in over-energy and train speed control enabled and if following conditions fulfilled:
the train is detected at filtered stop,
and safe immobilization customization setting for this control indicates to use parking brake.
If ATP cannot determine train is NotOnRestrictiveMoralTimeArea_1, and if this situation lasts more than ATPsetting. MTtimeout cycles, ATP shall consider that route exclusivity is not guaranteed and RouteExclusivityGuaranted_1 shall be set to False.
If ATP detects that train is NotOnRestrictiveMoralTimeArea_1, route exclusivity shall consider as guaranteed for that direction of travel and RouteExclusivityGuaranted_1 shall set to True
If ATP cannot determine train is NotOnRestrictiveMoralTimeArea_2, and if this situation lasts more than ATPsetting.MTtimeout cycles, ATP shall consider that route exclusivity is not guaranteed and RouteExclusivityGuaranted_2 shall set to False.
If ATP detects that train is NotOnRestrictiveMoralTimeArea_2, route exclusivity shall consider as guaranteed for that direction of travel and RouteExclusivityGuaranted_2 shall set to True
If RouteExclusivityGuaranted_1 is False, ATP shall request emergency braking if and only if:
TrainFrontEnd is not END_2,
RM forward nor RM reverse are not selected,
and block mode is not selected.
If RouteExclusivityGuaranted_2 is False, ATP shall request emergency braking if and only if:
TrainFrontEnd is not END_1,
RM forward nor RM reverse driving mode are not selected,
and block mode is not selected.
ATP shall request parking braking if train considered too near from a non-exclusive route and if following conditions are fulfilled:
the train is detected at filtered stop,
safe immobilization customization setting for this control indicates to use parking brake.
ATP shall request emergency braking if train considered too near from a non-exclusive route and if following conditions are fulfilled:
the train is not detected at filtered stop,
or the train is detected at filtered stop and:
safe immobilization customization setting for this control indicates to use emergency brake,
or safe immobilization customization setting for this control indicates to use emergency brake when it was already applied.
The No Undetectable Danger in Extremity 1 shall be consider as permissive status according to project configuration.
The "No Undetectable Danger in Extremity 2" shall be consider as permissive status according to project configuration.
If there is neither No Undetectable Danger in Extremity 1 nor No Undetectable Danger in Extremity 2 inputs, ATP shall consider the train is possible under the risk of undetectable danger.
ATP shall request a parking braking if the possibility of an undetected danger has proven to be and if following conditions are fulfilled:
the train is detected at filtered stop,
safe immobilization customization setting for this control indicates to use parking brake.
When the driver does not authorize the train running toward the END_1, ATP shall accumulate the distance of the train running toward to the END_1.
If in initialization, or the NoUndetectableDanger_1 is True, or the train has triggered EB and has stopped, ATP set this distance to 0;
Else if train kinematic has invalid, ATP set this distance to the default value.
Else if the odometer has initialized:
If the MaximumTrainMotionis greater than 0, ATP accumulate the maximum movement in this cycle with the distance of last cycle;
Or if the MaximumTrainMotionis less than or equal to 0, ATP use the minimum movement of this cycle plus to the distance last cycle (in fact, decrease the accumulated distance). The minimum of this accumulated distance is 0.
Otherwise, keep the distance unchanged.
When the driver does not authorize the train running toward the END_2, ATP shall accumulate the distance of the train running toward to the END_2.
If in initialization, or the NoUndetectableDanger_2 is True, or the train has triggered EB and has stopped, ATP set this distance to 0;
Else if train kinematic has invalid, ATP set this distance to the default value.
Else if the odometer has initialized:
if the MaximumTrainMotion is less than 0, ATP accumulate the maximum movement in this cycle with the distance of last cycle;
Else: if the MaximumTrainMotion is greater than or equal to 0, ATP use the minimum movement of this cycle plus to the distance last cycle (in fact, decrease the accumulated distance). The minimum of this accumulated distance is 0.
Otherwise, keep the distance unchanged.
When the train has moved without NUDE more than project-restricted distance, ATP shall set this value to True.
The EB request shall be maintained to True during the application time ATPsetting.NUDEtrainStopDurationBeforeEBrelease, if the train has moved without NUDE more than project restricted distance.
 When UndetectDangerMotionWithoutNUDE is True, ATP shall set EBappliedForMotionWithoutNUDE to True;
 When UndetectDangerMotionWithoutNUDE change from True to False,  ATP shall maintain EBappliedForMotionWithoutNUDE to True in period ATPsetting.NUDEtrainStopDurationBeforeEBrelease£»
Over the time, set this value to False.
When the train has triggered emergency brake causing by the "undetectable danger risk" and has stopped, ATP shall determine whether keeping the EB output according to the project configuration.
NOTES:
ATP estimates that current train maximum speed not exceeds the RM limit speed.
RMRselectedDrivingMode represents the choice of RMR. 
When the train is not on RMR mode, and the train moved backward related to the active cab, called rollback. ATP shall request EB if the speed of the rollback is greater than the project limits. If the rollback distance is greater than the project limits, ATP shall request the permanent EB, which cannot release.
When train front extremity is END_1 and traction effort is supposed to be in the direction of travel, RollbackDistanceAccount_1 is the estimated maximum distance which separates current front extremity 1 position to last most forward position reached by this extremity. ATP shall evaluate RollbackDistanceAccount_1 in order to control that speed does not exceed ATPsetting.MPnotAuthLimitSpeed .
When train front extremity is END_2 and traction effort is supposed to be in the direction of travel, RollbackDistanceAccount_2 is the estimated maximum distance which separates current front extremity 2 position to last most forward position reached by this extremity. ATP shall evaluate RollbackDistanceAccount_2 in order to control that speed does not exceed ATPsetting.MPnotAuthLimitSpeed.
From ATP power-up, UnrecoverableRollbackOverSpeed shall initialize to False.
UnrecoverableRollbackOverSpeed shall be set to True if and only if following conditions are fulfilled:
driving selector indicates that traction effort is supposed to be in the direction of travel,
train front extremity is END_2 or END_1,
and rollback limit speed currently applicable is null for this direction of travel.
Once UnrecoverableRollbackOverSpeed set as True, it shall stay at state True while ATP is not reboot.
RollbackOverSpeed shall be True if and only if following conditions are fulfilled:
driving selector indicates that traction effort is supposed to be in the direction of travel,
rain front extremity is END_2 or END_1,
and movement observed is in the opposite direction of travel,
and over-estimated train speed is greater than ATPsetting.MPnotAuthLimitSpeed currently applicable for this direction of travel and rollback speed restrictions is not null.
Or:
train has reached a position due a rollback movement which is unrecoverable,
Or:
train kinematic is invalid,
ATP shall request emergency braking if a reverse speed limit is over-run for unwilling rollback or excessive reverse motion.
When train front extremity is END_1 and traction effort is supposed to be in the opposite direction of travel, ReverseDistanceAccount_1 is the estimated maximum distance which separates current front extremity 1 position to last most forward position reached by this extremity. ATP shall evaluate ReverseDistanceAccount_1 in order to control that speed does not exceed reverse speed limit function.
When train front extremity is END_2 and traction effort is supposed to be in the opposite direction of travel, ReverseDistanceAccount_2 is the estimated maximum distance which separates current front extremity 2 position to last most forward position reached by this extremity. ATP shall evaluate ReverseDistanceAccount_2 in order to control that speed does not exceed ReverseSpeedRestrictions reverse speed limit function.
ReverseOverSpeed shall be True if following conditions fulfilled:
driving selector indicates that traction effort is supposed to be in the opposite direction of travel,
train front extremity is END_2 or END_1,
and movement observed is the opposite direction of travel,
and:
over-estimated train speed is greater than reverse speed restrictions currently applicable for this direction of travel,
or else: if reverse speed restrictions currently applicable is null for this direction of travel,
Or else: train kinematic is invalid.
ATP shall request emergency braking if a reverse speed limit is over-run for unwilling rollback or excessive reverse motion.
ATP shall determine whether there are intersection between the range of train locations and the vital passenger exchange zone of the side-A:
In initialization or train delocalization, set the TrainInterVPEZ_A as False;
If there are intersection between the range of train locations (from the minimum train tail to the maximum train head) and the vital passenger exchange zone (composing by a pair of SGL_VPEZ singularities with opposite direction in the train map), and the train door side A correspond to the platform according with Table 512, set TrainInterVPEZ_A as True:
Otherwise, set TrainInterVPEZ_A as False.
ATP shall determine whether there are intersection between the range of train locations and the vital passenger exchange zone of the side-B:
In initialization or train delocalization, set the TrainInterVPEZ_B as False;
If there are intersection between the range of train locations (from the minimum train tail to the maximum train head) and the vital passenger exchange zone (composing by a pair of SGL_VPEZ singularities with opposite direction in the train map), and the train door side B correspond to the platform according with Table 512, set TrainInterVPEZ_B as True:
Otherwise, set TrainInterVPEZ_B as False.
VPEZid_A records the ID of the VPEZ, which intersected with the location of train on side A.
If the TrainInterVPEZ_A, set as the ID of this VPEZ.
Otherwise, set as None.
VPEZid_B records the ID of the VPEZ, which intersected with the location of train on side B.
If the TrainInterVPEZ_B, then set as the ID of this VPEZ.
Otherwise, set as None.
TrainIncludedInVPEZ_A, ATP shall determine whether the whole train location belongs to one vital passenger exchange zone VPEZid_A.
In initialization or train delocalization, set the TrainIncludedInVPEZ_A as False;
If the range of train locations (from the minimum train tail to the maximum train head) belongs to a VPEZ, and the TrainInterVPEZ_A is True, then ATP shall set TrainIncludedInVPEZ_A as True;
Otherwise, set TrainIncludedInVPEZ_A as False.
TrainIncludedInVPEZ_B, ATP shall determine whether the whole train location belongs to one vital passenger exchange zone VPEZid_B.
In initialization or train delocalization, set the TrainIncludedInVPEZ_B as False;
If the range of train locations (from the minimum train tail to the maximum train head) belongs to a VPEZ, and the TrainInterVPEZ_B is True, then ATP shall set TrainIncludedInVPEZ_B as True;
Otherwise, set TrainIncludedInVPEZ_B as False.
TrainEmergencyBrakeApplied shows that whether the train has applied emergency brake. 
If the project is not configured, ATP shall consider the emergency brake has not applied by the train. 
Otherwise, if either of the end is in emergency brake, ATP considers the emergency brake has applied.
The term TrainParkingBrakeApplied stands for that either of the train ends is in parking brake.
ATP shall consider that train safely immobilized if:
Train brake has detected safely applied, or train parking brake is detected;
And train is detected at filtered stop.
ATP shall determine whether train doors on side A opening. The rules are following:
ATP shall determine whether train doors on side B opening. The rules are following:
AlignPSDzone_A, ATP shall determine whether there are intersection between the range of train locations and the platform screen doors zone of the side-A.
PSDid_A, the id of the PSD on side-A intersects with train location.
In initialization or train delocalization, set AlignPSDzone_A as False and PSDid_A as None.
If there are intersection between the range of train locations (from the minimum train tail to the maximum train head) and the PSD zone (composing by a pair of SGL_PSD_ZONE singularities with opposite direction in the train map), and the train door side A correspond to the platform according with Table 512, set AlignPSDzone_A as True, and records PSDid_A as the PSD¡¯s id:
Otherwise, set AlignPSDzone_A as False and PSDid_A as None.
AlignPSDzone_B, ATP shall determine whether there are intersection between the range of train locations and the platform screen doors zone of the side-A.
PSDid_B, the id of the PSD on side-A intersects with train location.
In initialization or train delocalization, set AlignPSDzone_B as False and PSDid_B as None.
If there are intersection between the range of train locations (from the minimum train tail to the maximum train head) and the PSD zone (composing by a pair of SGL_PSD_ZONE singularities with opposite direction in the train map), and the train door side B correspond to the platform according with Table 512, set AlignPSDzone_B as True, and records PSDid_B as the PSD¡¯s id:
Otherwise, set AlignPSDzone_B as False and PSDid_B as None.
PSDoperation_A and PSDoperation_B structured as ST_PSD_OPERATION, used to obtain the PSD controlling order from CCNV.
ATP shall determine whether to establish communication with the correlative CI according to request from CCNV:
When there is at least one id of PSDoperation_A or PSDoperation_B is not none, ATP shall set CommunicatedWithPSD to True:
Otherwise, set CommunicatedWithPSD to False.
In initialization, all PSD DoorClosed of TableOfPSDPlatform set as False, and the valid period is zero. Later on, if receiving correct CI_IOstatus, on the basis of ID number the status of related PSD doorClosed from TableOfPSDPlatform is updated and the DoorStatusValidityTime is set as ATPsetting.PSDstatusValidityTime subtracted the delay of FSFB2 message.
If ATP does not receive the CI_IOstatus from CI, or if this message detected as False, ATP shall update the PSD status of TableOfPSDPlatform, i.e. it is necessary to minus DoorStatusValidityTime with one. If the value is less than or equal to zero, the status of DoorClosed is set as False; otherwise the status keeps the same.
Only when the train fulfilled the following conditions, ATP shall use the PSD status from the CI:
The train location intersects with a PSD zone;
And the train is filtered stopped or just started moving.
MasterCCcore shows whether the status from CCNV is the main controlled CC.
If the ATP is the master CC, then the A-side PSD state updating rules are as follows:
If the ATP is the master CC, then the B-side PSD state updating rules are as follows:
If the ATP is not the master CC, then the A-side PSD state updating rules are as follows:
If the ATP is not the master CC, then the B-side PSD state updating rules are as follows:
The rules to generate the PSD manage order on side A shall follow the pseudo-codes. In which if the PSD id from CCNV is not equal to the id in ATP's track map, ATP shall prohibit the PSD opening.
The rules to generate the PSD manage order on side B shall follow the pseudo-codes. In which if the PSD id from CCNV is not equal to the id in ATP's track map, ATP shall prohibit the PSD opening.
ATP shall determine whether itself opening the PSD in this cycle.
ATP shall determine whether itself or the redundant ATP opening the PSD in this cycle.
When communicating with the CI, if the PSDmanagerOrder_A which comes from CCNV was valid, ATP shall set the CIsetting[0] according to the PSDmanagerOrder_A and the configuration of the PSD.
When communicating with the CI, if the PSDmanagerOrder_B, which comes from CCNV, was valid, ATP shall set the CIsetting[1] according to the PSDmanagerOrder_B and the configuration of the PSD.
The AllTrainDoorsClosedAndLocked stands for the condition that either side of both train ends collect TDCL, i.e. both side of door is closed and locked.
ATP shall not monitor the status of train doors when InhibitControlTrainDoorsStatus is selected.
If the train is aligning in a PSD or intersecting with a vital passage exchange zone, and the RMF or RMR does not selected, ATP shall keep triggering parking brake when the train doors does not closed and locked.
If ATP has triggered parking brake for train doors opening, but it does not applied by the rolling stock, ATP shall trigger the emergency brake.
ATP shall determine whether the train is departure without TDCL.
If ATP needs to monitor the status of train doors, ATP shall trigger EB if train determine without TDCL:
ATP shall not monitor the status of train doors open without door opening enable if InhibitProtectionMovingWithoutTDCL is selected.
The conditions ATP does not control PSD can be configured by project.
If the train stopped or just started moving, and the status of all aligned PSD are closed, ATP shall consider the AllPSDclosedAndLocked is True.
ATP shall determine whether the train starts moving without the aligned PSD closed.
If in charge of the PSD control, ATP shall trigger emergency brake when train just started moving but PSD does not closed.
If one of the statuses of the aligned PSD does not closed when train stopped, ATP shall trigger parking brake.
If ATP has triggered the parking brake for the PSD opening, but it does not applied by the rolling stock, ATP shall trigger the emergency brake.
ATP shall monitor the PSD opening command whether valid by the following rules:
If the PSD opening command is True in the current cycle, ATP consider this command is valid;
Or else:, if the PSD opening command become from True to False, ATP shall start to counter the cycles:
If the PSD opening command has become False and has lasted more than ATPsetting.PSDopeningCommandValidityTime, then ATP shall consider the PSD opening command as invalid;
Or else:, ATP still consider the PSD opening command as valid.
Otherwise, ATP consider the PSD opening command as invalid.
If ATP needs to supervise the PSD opening status, ATP shall trigger parking brake when the PSD opening command is valid.
EmergencyHandleNotPulledEnd1 stands for the closed emergency door of END_1. If the train does not allocate with emergency door in the cab, it is certain that the emergency door does not opened. 
EmergencyHandleNotPulledEnd2 stands for the closed emergency door of End2. If the train does not allocate with emergency door in the cab, it is certain that the emergency door does not opened. 
ATP shall keep hold the train END_1 door closed when one of the following conditions fulfilled:
Train kinematics is valid and the train does not stop;
Or the emergency handle of END_1 is not pulled;
ATP shall keep hold the train END_2 door closed when one of the following conditions fulfilled:
Train kinematics is valid and the train does not stop;
Or the emergency handle of END_2 is not pulled;
If ATP does not hold the train end door, then trigger emergency brake.
ATP shall consider the evacuation is not possible on side-A when there are intersection between the range of train locations and the hazardous evacuation zone of the side-A:
In initialization or not TrainLocatedOnKnownPath, set the EvacuationNotPossible_A as False;
Or else, if there are intersection between the range of train locations (from the minimum train tail to the maximum train head) and the vital passenger exchange zone (composing by a pair of SGL_HAZAR_EVAC_ZONE singularities with opposite direction in the train map), and the train door side A correspond to the EVAC according with Table 512, set EvacuationNotPossible_A as True.
Otherwise, set EvacuationNotPossible_A as False.
ATP shall consider the evacuation is not possible on side-B when there are intersection between the range of train locations and the hazardous evacuation zone of the side-B:
In initialization or not TrainLocatedOnKnownPath, set the EvacuationNotPossible_B as False;
Or else, if there are intersection between the range of train locations (from the minimum train tail to the maximum train head) and the vital passenger exchange zone (composing by a pair of SGL_HAZAR_EVAC_ZONE singularities with opposite direction in the train map), and the train door side B correspond to the EVAC according with Table 512, set EvacuationNotPossible_B as True.
Otherwise, set EvacuationNotPossible_B as False.
The conditions ATP determining the HoldDoorsClosed_A show as following ARDL:
The conditions ATP determining the HoldDoorsClosed_B show as following ARDL :
ATP shall determine whether the train has docked in the station correctly according to conditions of train stopping and doors opening enable.
The train is said to be leaving the station:
if since last time train has been detected docked in station (TrainDockedInStation), the cumulated of the absolute value of MaximumTrainMotion is in the range [0, ATPsetting.EvacuationStationAreaLength] and no train kinematic invalidation occurs. 
or else, if the train kinematics is invalid, ATP shall set TrainLeavingStation as False and clear the cumulated distance.
EmergencyHandleNotPulledSid shows that the emergency handles is not pulled down.
If the train is just leaving the station and the side doors emergency handles are pulled, ATP shall require EvacuationWhileLeavingStation.
If the train does not stop on the doors opening enable area and the side doors emergency handles pulled, ATP shall require EvacuationWithTrainStopped.
If the train leaving station evacuation has been required, ATP shall trigger the emergency brake.
If the train stopped evacuation has been required, ATP shall trigger the emergency brake.
PBforOperationalRequest stands for the ZVRD output order from CCNV.
TrainParkingBrakeRequested, determine whether to apply parking brake. This variable shall be True when one of the following conditions met:
Train is in front of a possibly non-exclusive route,
Synthesis of speed constraints on the train implies that it is not allowed to move anymore. Any movement may lead to an hazardous situation,
Train is located on a passenger exchange area with PSD and train doors are not proven closed and locked,
Train is located on a passenger exchange area with PSD and PSD are not proven closed and locked,
There is a possibility of undetectable dangers,
An operational parking brake is requested,
The PSD are opened and are under the supervision of ATP,
The EB has been requested in this cycle.
InhibitParkingBrake£¬ATP software do not apply the parking brake.
The Coreld and SubSystemID of the ATP and redundant ATP need to compare for the consistency, which records in IncompatibleDistantATP. In initialization, the message from redundant ATP cannot be used. On the other hand, when SubSystemID in the Dataplug read by redundant ATP is the same, but the Coreld is different, both ATP regards as consistency. Otherwise, ATP would trigger emergency brake. 
ApproachableSignalOverrun, ATP shall determine whether the location of maximum train head overruns an approachable signal with overlap established.
When all of the following conditions fulfilled, ATP considers the train has overrun a restricted signal in this cycle, and set ApproachableSignalOverrun as True.
not MotionProtectionInhibition;
And ApproachableSignalOverrun was False at the last cycle;
And the moving direction in current cycle is toward on the train front end;
And the maximum location of train front end passes the position of the signal with overlap attribute in this cycle;
And the variants status of the signal is overlap established(refer to Table 59).
Otherwise, ATP set ApproachableSignalOverrun as False.
ATP shall trigger emergency brake according to CCNV¡®s operational emergency brake request.
ATP shall control emergency brake output according following emergency braking requests from control functions:
moral-time control function has detected an hazardous situation (route exclusivity violation);
train speed is no longer compliant with respect of whole speed restriction of guide way;
an approachable speed limit has been over-run (RM speed limit or memorized location speed limit);
an over-speed in reverse direction of travel has been detected;
an emergency evacuation is required for passengers;
train departure with not all doors closed and locked has been detected;
the train starts to move on a PSD zone which status is not "all PSD proven closed and locked";
train has moved although there are potential undetectable dangers;
an operational emergency braking has been requested by CC-Non Vital;
train end doors are not closed and locked;
not all doors closed and locked has been detected on a PSD zone and parking brake is not applied, 
not all PSD closed and locked has been detected on a PSD zone and parking brake is not applied;
the approachable signal is overrun;
the VLE-2 safe timer failed;
the information of Dataplug in both ends of cab is inconsistent.
If an emergency braking request ordered by a control function, ATP shall not inhibit emergency brake until train filtered-stop reached.
ATP shall inhibit emergency brake if and only if train detected at filtered stop and there is no emergency braking request from control functions.
ATP shall monitor the CC continuous work time. If the CC is running more than MAX_RESET_TIME (the value is far less than MAX_ATP_LOOP_HOUR), the ATP shall set all output to VIOM as restricted status.
Whether CCNV request the channel of VIOM shall be disabled or not.
According to [REF5], the commands ATP sent to VIOM shall attach the current ATPtime, cycle synchronization check word Trace and Dt, safety clock state SafeTimerFailed, MasterCCcore, the LatestVIOM1LoopHourVIOM and LatestVIOM2LoopHourVIOM needed to feedback to the respective VIOM.
ATP shall send the orientation of minimum location of current active cab id to the ZC. For the rule can refer to SwRS-0403.
ATP shall send the minimum head location of the active cab to the ZC, including the block id and its abscissa. According to [REF5], the unit of the abscissa in Location Report is 0.5 meter, so the ATP needs to convert its internal unit to match that. The conversion shall be safety-oriented, which means the envelope of the train location tend to be "stretched" to the both ends. The rules of conversion are as following ARDL:
ATP shall send the coupled status of the active train cab to the ZC.
ATP shall send the current inactive cab id to the ZC.
ATP shall send the orientation of the minimum location of inactive cab id to the ZC. For the rule can refer to SwRS-0408.
ATP shall send the minimum tail location of the active cab to the ZC, including the block id and its abscissa. According to [REF5], the unit of the abscissa in Location Report is 0.5 meter, so the ATP needs to convert its internal unit to match that. The convertion shall be safety-oriented, which means the envelope of the train location tend to be "stretched" to the both ends. The rules of convertion are as following ARDL:
ATP shall send the coupled status of the inactive train cab to the ZC.
ATP shall send the location error to the ZC. According to [REF5], the unit of the location error in Location Report is 0.5 meter, so the ATP needs to convert its internal unit to match that. The convertion shall be safety-oriented, which means the location error tend to be ¡°overestimated".
According to the status of RouteSetNotNeededSendable, ATP can judge whether it is necessary to send RSNN information.
Whether the CCNV request route set note needed.
ATP shall send the route set not needed information to ZC.
ATP shall send the docking correction information to the ZC.
ATP shall send the maximum train speed to the ZC. According to [REF5], the unit of the speed in Location Report is KPH, so the ATP needs to convert its internal unit to match that. The convertion shall be safety-oriented, which means the speed tend to be ¡°overestimated".
ATP shall send the current monitoring mode to the ZC.
ATP shall send the signal override information to the ZC.
DateSynchronisationReportAvailable used to judge whether the LC synchronization message could use or not. When the below conditions fulfilled, DateSynchronisationReportAvailable shall set as True. Otherwise, it set as False.   
If ATP Receives the DateSynchronizationReport message from LC, and the checksum is correct. 
And If the received message is LC to respond the local CC, ATP shall qualify with below conditions:
The current ATP time is more than ccLoopHour in the message
The different value between the current ATP time and the ccLoopHour  is less than the LC message time in the previous ATP.
Or else:, If the received message is LC to respond the remote CC, and it should be qualified with below conditions:
The minimum time in remote ATP maintained by current ATP is more than the ccLoopHour
The different value between maximum time in remote ATP maintained by current ATP and the ccLoopHour is less than the LC message time in the previous ATP.
LastSynchronisationReportAge records the age from previous LC message to current cycle. It used to compare whether the new received message is more updating than last recorded one, to prevent the inverse transition in the network communication.  
LCsynchronisationLoopHourValid will check whether the LC message is still valid. 
IdentificationLogical TypeDescription
ST_GROUND_TIME
TimeNUMERIC_32
MillisecondsNUMERIC_32
ATP shall estimate a time called GroundTimeReference for trackside equipment (ZC /LC). From power-up, GroundTimeReference shall consider invalid. The rules for time information are as follows:
When LC message invalid, it is set as default value. 
When ATP receives an available LC message, it updates as the time of message. 
Otherwise, it updates the value according to the on board and track side cycle.
Before received the first valid synchronization from a LC, the corresponding LC vital time shall consider not significant, and the ATP shall prevent to send Location Report message to the ZC(s) associated to the corresponding LC.
ATP shall calculate when to send the Location Report as the following ARDL:
ATP shall record the ZC area id where the train tail located. If the train is not localized, ATP shall use the current receiving beacon where located, or the last known ZC area id.
ATP shall record the ZC area id where the train head located. If the train is not localized, ATP shall use the current receiving beacon where located, or the last known ZC area id.
When the time elapsed from last report is equal to the Location Report sending cycle, and the train tail located ZC is valid and not as same as the train head ZC, and the ZC train tail located authorized by the LC, ATP shall send the Location Report to this ZC where train tail located.
When the time elapsed from last report is equal to the Location Report sending cycle, and the train head located ZC is valid, and the ZC train head located authorized by the LC, ATP shall send the Location Report to this ZC where train head located.
ATP shall check the following conditions when sending overlap release to CBI:
Train front location is in overlap release zone,
and the other ATP's overlap timer has expired,
and ATP received variant request from CBI in this zone.
In Initialization, ATP reads the CCdataPlugInfo with VCP coded from CC data plug, and generates DataPlugContent with the structure shown as Table 44¡£
Through DataPlugContent.VLECpuId, ATP recognizes whether it is located in CPU1 or CPU2, and establish the communication between each other.
If the CPU id is wrong, ATP shall stop and wait for reboot manually by the operator. 
For CPU1, ATP shall control the LED to show WAITING_CPU when the communication establishing.
For CPU1, ATP shall control the LED to show ERR_CPU_ID when the cpuId is neither CPU1 nor CPU2.
In initialization, ATP needs to send some part of contents as shown in Table 47 from CC data plug to CCNV by dual-ports RAM after getting contact with CCNV. If ATP cannot establish the communication with CCNV, it will keep waiting and show in the LED as WAITING _CCNV, until the communication is built or the operator reboots VLE-2 board.
In initialization, ATP needs to send the DataPlugContent. DLUIpBlue and DLUIpRed from CC data plug to DLU through RAM.  
The hardware needs to be initialized, e.g. VPB board. If the initialization of hardware succeeds, the system will continue. Otherwise, ATP on CPU1 shall show the message in the LED as ERR_INIT_VPB, and prohibit software executing and waiting for the system reboot by the operator.  
In initialization, ATP in two CPU modules shall compare the values from VPB registers. If these initial values are equal, the ATP will continue; Otherwise, ATP shall show the message in LED as UNCONST_VPB, and prohibit software executing.
VLEimpulseNb[ATP_INTERRUPT_NB] array stores the safe clock impulse number for every interrupt triggered. ATP shall obtain the impulse number through VLE_GetSafeTime, and stores into the array. 
ImmediateCounter, as the interrupt counter, ATP shall accumulate 1 after each interrupt triggered.
When the fixed-time interrupt triggered, ATP shall update the ImmediateNb£¬CycleSynchronized, Trace, Dt and CycleBiasNb. 
If it is the first interrupt after powered up, ATP shall set ImmediateNb as zero£¬and initialize the Trace, Dt (the dynamic time of VCP), and the middle variables m based on CPU.
Or else:, If the ImmediateNb is zero, but the VitalTime has not changed comparing to the previous interrupt, then:
Or else, If ImmediateNb is zero, and the VitalTime has changed comparing to the previous interrupt, then:
Otherwise, set:
and if the ImmediateNb is greater than (ATP_INTERRUPT_NB-1), then:
The SafeTimerFailed defines whether the fix-time interrupt for hardware is correct or not. ATP shall check whether the safe clock impulse number with the adjacent interrupt is within the error range [MIN_TIMER_IMPULSE_NB, MAX_TIMER_IMPULSE_NB].
Once the SafeTimerFailed was True, ATP shall keep it as True unless the system is rebooted.
Or else:, if the impulse number is within the above-mentioned range, ATP shall set SafeTimerFailed as False
Otherwise, it will set SafeTimerFailed as True. 
VitalTime = VitalTime(k-1) + 1
The VitalTime stand for the current cycle of ATP deferred task. After power up, it starts from zero and increase one each cycle. When all the work is executed in the main task, ATP detects whether the interrupt task is over, i.e. the difference between ImmediateCounter and LockedImmediateCounter is equal to or larger than (ATP_INTERRUPT_NB -1). 
If it is so, it shows that the main task in this cycle finishes. Then ATP shall:
send the VitalTime to the other CPU,
and send Trace and Dt to VIOM to check,
and at the end of this cycle, set
 VitalTime = VitalTime(k-1) + 1
Otherwise, keep waiting.
CycleSynchronized = True,
ATP executes the new cycle DeferredTask when below conditions fulfilled:
CycleSynchronized is True,
and the TOC_VitalTime get from the other CPU is equal to VitalTime, representing that the other CPU finished to execute the task in the previous cycle. 
If above condition does not fulfill, ATP shall prohibit to execute, and CPU1 shows the message ERR_SYNCH in the LED of VLE board. 
ATP software shall maintain the RTC time for non-vital functions.
In initialization, ATP software get RTC time from VLE-2 board;
And then, ATP software updates the RTC time every second;
And if the difference between RTC time ATP used and the NTP time CCNV sent is greater than MAX_NTP_TIME_ERROR, ATP shall reset the RTC time as NTP time.
The Time.Update() means ATP software shall update the RTC time every second.
In every cycle, ATP combines the vital outputs generated by itself and from the other CPU into one frame and sends it to CCNV, who will transmit the frame to VIOM. ATP will send VIOM1VitalOut and VIOM2VitalOut to the other CPU through dual-ports RAM, and receive the TOC_VIOM1VitalOut and TOC_VIOM2VitalOut from the other CPU.
Based on ST_VIOM_OUT structure, ATP combines VIOM1VitalOut and TOC_VIOM1VitalOut as IdenticalVIOM1Out, while based on the same structure ST_VIOM_OUT, ATP combines VIOM2VitalOut and TOC_VIOM2VitalOut as IdenticalVIOM2Out.
IdenticalLocReport, the location report after merging two CPU¡¯s results. When the two CPUs complete LocReport calculation, need to send each other through the dual-port RAM; and receive the TOC_LocReport from the other. ATP shall combine the two reports as an IdenticalLocReport, according to the following rules:
The variables without vital checksums in ST_LOC_REPORT, shall use the values calculated by itself.
For the VitalChecksum_1, ATP shall calculate using the values from CPU1.
For the VitalChecksum_2, ATP shall calculate using the values from CPU2.
IdenticalVersionReport, the version report after merging two CPU¡¯s results. When the two CPUs complete VersionFromCCreport calculation, need to send each other through the dual-port RAM; and receive the TOC_VersionReport from the other. ATP shall combine the two reports as an IdenticalVersionReport, according to the following rules:
The variables without vital checksums in ST_VERSION_REPORT, shall use the values calculated by itself.
For the VitalChecksum_1, ATP shall calculate using the values from CPU1.
For the VitalChecksum_2, ATP shall calculate using the values from CPU2.
IdenticalCCsyncReport, the redundant ATP report after merging two CPU¡¯s results. When the two CPUs complete CCsynchroReport calculation, need to send each other through the dual-port RAM; and receive the TOC_CCsyncReport from the other. ATP shall combine the two reports as an IdenticalCCsyncReport, according to the following rules:
The variables without vital checksums in ST_SYNCHRO_REPORT, shall use the values calculated by itself.
For the VitalChecksum_1, ATP shall calculate using the values from CPU1.
For the VitalChecksum_2, ATP shall calculate using the values from CPU2.
IdenticalCIsetting, the PSD control message after merging two CPU¡¯s results. When the two CPUs complete CIsetting calculation, need to send each other through the dual-port RAM; and receive the TOC_CIsetting from the other. ATP shall combine the two reports as an IdenticalCIsetting, according to the following rules:
The variables in ST_CI_SETTING, shall use the values calculated by itself.
For the checkword 1 in FSFB2 protocol, ATP shall calculate using the values from CPU1.
For the checkword 2 in FSFB2 protocol, ATP shall calculate using the values from CPU2.
IdenticalCBIvariantRequest, the CBI variants request after merging two CPU¡¯s results. When the two CPUs complete CBIvariantRequestcalculation, need to send each other through the dual-port RAM; and receive the TOC_CCvariantReport from the other. ATP shall combine the two reports as an IdenticalCBIvariantRequest, according to the following rules:
The variables without vital checksums, shall use the values calculated by itself.
For the VitalChecksum_1, ATP shall calculate using the values from CPU1.
For the VitalChecksum_2, ATP shall calculate using the values from CPU2.
IdenticalCCvariantReport, the CC overlap releasable report after merging two CPU¡¯s results. When the two CPUs complete CCvariantReportcalculation, need to send each other through the dual-port RAM; and receive the TOC_CCvariantReport from the other. ATP shall combine the two reports as an IdenticalCCvariantReport, according to the following rules:
The variables without vital checksums, shall use the values calculated by itself.
For the VitalChecksum_1, ATP shall calculate using the values from CPU1.
For the VitalChecksum_2, ATP shall calculate using the values from CPU2.
