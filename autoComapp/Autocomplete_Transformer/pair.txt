#
@
初始化时，ATP读取来自CC data plug的DataPlugContent.CCTrainType信息，生成TrainType。
$
On initialization, ATP generates TrainType according to DataPlugContent.CCTrainType from the CC data plug.
%
def TrainType(k):
    return DataPlugContent.CCTrainType
#
@
初始化时，ATP读取来自CC data plug的DataPlugContent.CCCoreId信息，生成CoreId。
$
On initialization, ATP generates CoreId according to DataPlugContent.CCCoreId read from the CC data plug.
%
def CoreId(k):
    return DataPlugContent.CCCoreId
#
@
OtherCoreId，远端车头号
$
Core id for CC on the distant cab.
%
def OtherCoreId(k):
    if (CoreId(k) is END_1):
        return END_2
    elif (CoreId(k) is END_2):
        return END_1
    else:
        return None
#
@
初始化时，ATP读取来自CC data plug的DataPlugContent.CC_SSID信息，生成SubSystemId。
$
On initialization, ATP generates SubSystemId according to DataPlugContent.CC_SSID from the CC data plug.
%
def SubSystemId(k):
    return DataPlugContent.CC_SSID
#
@
上述信息均获取正确并且相一致后，生成TrainKnown信息。如果TrainKnown为False，则VIOM将输出全限制状态。
$
After all above-mentioned information has corrected, and correspondingly, ATP will generate TrainKnown information. If TrainKnown considered as False, ATP shall set all output ports as restricted.
%
def TrainKnown(k):
    return ((TrainType(k) == ATPsetting.TrainTypeId)
            and (CoreId(k) is END_1
                 or CoreId(k) is END_2)
            and IdenticalVersionOfDualCPU(k))
#
@
NonVitalRequestReady，通过与CCNV的通信接口，判断是否收到CCNV的消息NonVitalRequest
$
Through the communication with CCNV, ATP judges NonVitalRequestreceived from CCNV and generates NonVitalRequestReady If received a new message.
%
def NonVitalRequestReady(k):
    return Message.Exists(NonVitalRequest)
#
@
ATOcontrolTimeValid，CCNV消息有效标志，如果超过CCNV_VALIDITY_CYCLES个周期仍未收到新的CCNV消息，则设置为False。
$
ATOcontrolTimeValid stands for the effectiveness of CCNV message. If there is no updating CCNV message past the CCNV_VALIDITY_CYCLES, ATOcontrolTimeValid is set as False.
%
def ATOcontrolTimeValid(k):
    if (NonVitalRequestReady(k)):
        ATOcontrolTimeValid = True
        ATOcontrolTimer = 0
    elif (ATOcontrolTimer(k-1) < CCNV_VALIDITY_CYCLES):
        ATOcontrolTimer = ATOcontrolTimer(k-1) + 1
    else:
        ATOcontrolTimeValid = False
    return ATOcontrolTimeValid
#
@
VIOM1VitalInputsReceived，ATP判断是否收到了来自VIOM1的安全输入消息。其中viomId取值为0或1，表示位于END_1车头2个VIOM中的1个。
$
ATP determines whether received a safety input message from VIOM1. During the calculation, the value viomId is either zero or one, which represents one of the two VIOM in the train END_1.
%
def VIOM1VitalInputsReceived(viomId, k):
    return Message.Received(VIOM1VitalInput(viomId), k)
#
@
VIOM1VitalInputsAvailable，通过通信接口，获取来自VIOM1的安全输入消息，并判断消息传输的时间有效性以及顺序的正确性。其中ViomId取值为0或1，表示位于END_1车头2个VIOM中的1个。
$
Through the communication, ATP gets the vital input message from VIOM1 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM1VitalInputsAvailable. During the calculation, the value ViomId is either zero or one, which represents one of the two VIOM in the train END_1. 
%
def VIOM1VitalInputsAvailable(ViomId, k):
    return Message.Available(VIOM1VitalInputsReceived(ViomId, k),
                             VIOM1VitalInput(ViomId).AtpLoopHour,
                             VIOM_VALIDITY_TIME,
                             VIOM1VitalInputsLastAge(ViomId, k-1),
                             k) 
#
@
VIOM1VitalInputsLastAge，记录收到最新的END_1端VIOM的存活时间为多少。
$
Records the survival time of received vital inputs from VIOM1.
%
def VIOM1VitalInputsLastAge(ViomId, k):
    return Message.LastAge(VIOM1VitalInputsAvailable(ViomId, k),
                               VIOM1VitalInput(ViomId).AtpLoopHour,
                               VIOM1VitalInputsLastAge(ViomId, k-1),
                               k) 
#
@
LatestVIOM1LoopHourVIOM，记录当前收到最新的END_1端VIOM的周期时间信息。初始化时LatestVIOM1LoopHourVIOM为VIOM周期号的最小值0；
如果收到可用的VIOM1信息，或之前的VIOM1消息已无效但又新收到一条VIOM1消息，则将相应的LatestVIOM1LoopHourVIOM设置为新收到消息中的viomLoopHour值；否则，LatestVIOM1LoopHourVIOM保持不变。
$
ATP records the latest cycle time information of VIOM in END_1 by the term LatestVIOM1LoopHourVIOM.In initialization, set LatestVIOM1LoopHourVIOM as the zero; If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM1LoopHourVIOM as the viomLoopHour of the message. Otherwise, LatestVIOM1LoopHourVIOM keeps unchanged.  
%
def LatestVIOM1LoopHourVIOM(ViomId, k):
    if (VIOM1VitalInputsAvailable(k)
        or (not VIOM1VitalInputsValid(k-1)
            and VIOM1VitalInputsReceived(ViomId, k))):
        return VIOM1VitalInput[ViomId].ViomLoopHour
    else:
        return LatestVIOM1LoopHourVIOM[ViomId](k-1)
#
@
VIOM2VitalInputsReceived，收到并校验正确来自VIOM2的安全输出消息。
$
ATP determines whether received a safety input message from VIOM2.
%
def VIOM2VitalInputsReceived(ViomId, k):
    return Message.Received(VIOM2VitalInput(ViomId), k)
#
@
VIOM2VitalInputsAvailable，通过通信接口，获取来自VIOM2的安全输入消息，并判断消息传输的时间有效性以及顺序的正确性。其中ViomId取值为0或1，表示位于END_2车头2个VIOM中的1个。
$
Through the communication, ATP gets the vital input message from VIOM2 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM2VitalInputsAvailable. During the calculation, the value i is either zero or one, which represents one of the two VIOM in the train END_2. 
%
def VIOM2VitalInputsAvailable(ViomId, k):
    return Message.Available(VIOM2VitalInputsReceived(ViomId, k),
                                  VIOM2VitalInput(ViomId).AtpLoopHour,
                                  VIOM_VALIDITY_TIME,
                                  VIOM2VitalInputsLastAge(ViomId, k-1),
                                  k) 
#
@
VIOM2VitalInputsLastAge，记录当前收到最新的END_2端VIOM的周期时间信息。
$
Records the survival time of received vital inputs from VIOM2.
%
def VIOM2VitalInputsLastAge(viomId, k):
    return Message.LastAge(VIOM2VitalInputsAvailable(viomId, k),
                               VIOM2VitalInput(viomId).AtpLoopHour,
                               VIOM2VitalInputsLastAge(viomId, k-1),
                               k) 
#
@
LatestVIOM2LoopHourVIOM，记录当前收到最新的END_2端VIOM的周期时间信息。初始化时LatestVIOM2LoopHourVIOM为VIOM周期号的最小值0；
如果收到可用的VIOM2信息，或之前的VIOM2消息已无效但又新收到一条VIOM2消息，则将相应的LatestVIOM2LoopHourVIOM设置为新收到消息中的ViomLoopHour值；否则，LatestVIOM2LoopHourVIOM保持不变。
$
ATP records the latest cycle time information of VIOM in END_2by the term LatestVIOM2LoopHourVIOM.In initialization, set LatestVIOM2LoopHourVIOM as the zero; If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM2LoopHourVIOM as the viomLoopHour of the message.
Otherwise, LatestVIOM2LoopHourVIOM keeps unchanged.
%
def LatestVIOM2LoopHourVIOM(ViomId, k):
    if (VIOM2VitalInputsAvailable(k)
        or (not VIOM2VitalInputsValid(k-1)
            and VIOM2VitalInputsReceived(ViomId, k))):
        return VIOM2VitalInput[ViomId].ViomLoopHour
    else:
        return LatestVIOM2LoopHourVIOM[ViomId](k-1)
#
@
VIOM1VitalInputsValid，判断来自END_1的VIOM安全输入信息是否在有效时间内。
$
ATP determines whether the vital inputs message from VIOM1 valid.
%
def VIOM1VitalInputsValid(k):
    return (Message.Valid(VIOM1VitalInput(1).AtpLoopHour, VIOM_VALIDITY_TIME)
            or Message.Valid(VIOM1VitalInput(2).AtpLoopHour, VIOM_VALIDITY_TIME))
#
@
VIOM2VitalInputsValid，判断来自END_2的VIOM安全输入信息是否在有效时间内。
$
ATP determines whether the vital inputs message from VIOM2 valid.
%
def VIOM2VitalInputsValid(k):
    return (Message.Valid(VIOM2VitalInput(1).AtpLoopHour, VIOM_VALIDITY_TIME)
            or Message.Valid(VIOM2VitalInput(2).AtpLoopHour, VIOM_VALIDITY_TIME))
#
@
CoupledByEnd1或CoupledByEnd2，列车两端连挂其他车辆。如果该项目未配置连挂输入的采集，则认为列车未与其他车连挂。其状态来自于项目可配置的列车输入采集。
$
CoupledByEnd1 or CoupledByEnd2 shows that both ends of train connect with other trains. If the project is not configured with the capture of coupling input, it is certain that the train does not connect with other trains.  
%
def CoupledByEnd1(k):
    return Offline.GetCoupledByEnd1(k)
def CoupledByEnd2(k):
    return Offline.GetCoupledByEnd2(k)
#
@
TrainNotCoupled，列车未与其他车辆连挂。
%
def TrainNotCoupled(k):
    return Offline.GetTrainNotCoupled(k)
#
@
TrainCoupledType，根据项目配置，获取当前列车的连挂类型。支持以下四种连挂类型：TRAIN_COUPLED_UNKNOWN，当前连挂状态无效；
TRAIN_NO_COUPLED，列车未连挂；TRAIN_COUPLED_END1，列车END_1端连挂；TRAIN_COUPLED_END2，列车END_2端连挂。规则如下：
%
def TrainCoupledType(k):
    if (TrainNotCoupled(k)
        and not TrainCoupledByEnd1(k)
        and not TrainCoupledByEnd2(k)):
        return TRAIN_NO_COUPLED
    elif (not TrainNotCoupled(k)
        and TrainCoupledByEnd1(k)
        and not TrainCoupledByEnd2(k)):
        return TRAIN_COUPLED_END1
    elif (not TrainNotCoupled(k)
        and not TrainCoupledByEnd1(k)
        and TrainCoupledByEnd2(k)):
        return TRAIN_COUPLED_END2
    else:
        return TRAIN_COUPLED_UNKNOWN
#
@
ATPtime，维护本端ATP的loop hour时间。根据本端CoreId，初始化为END_1或 END_2的初始值；如果超过了相应的最大值，则重新等于初始化的值。否则每周期加1
$
ATPtime stands for the ATP loop hour of this train END. Based on CoreId, ATP initialize ATPtime as the initiative value of END_1 or END_2; If the value exceeds the maximum loop hour, ATP shall set it as the initiative value; Otherwise, add one for each cycle. 
%
def ATPtime(k):
    if (CoreId(k) is END_1):
        if (Initialization):
            return CC1_INIT_TIME
        elif (ATPtime(k-1) >= CC1_MAX_TIME):
            return CC1_INIT_TIME
        else:
            return ATPtime(k-1) + 1
    else:
        if (Initialization):
            return CC2_INIT_TIME
        elif (ATPtime(k-1) >= CC2_MAX_TIME):
            return CC2_INIT_TIME
        else:
            return ATPtime(k-1) + 1
#
@
OtherATPmessageReceived，本周期收到冗余ATP消息并校验正确。
$
The message transmitted from the distant ATP in the other END shall be protected by check words. And before using the information, ATP shall verify the check words.
%
def OtherATPmessageReceived(k):
    return Message.Received(OtherCCsynchroReport,k)
#
@
OtherATPmessageAvailable，判断来自冗余ATP消息的有效性：
$
OtherATPmessageAvailable, ATP shall judge the effectiveness of message from the redundant ATP, shown as following pseudo-codes:
%
def OtherATPmessageAvailable(k):
    return Message.Available(OtherATPmessageReceived(k),
                            OtherCCsynchroReport.LatestTimeOtherCore,
                            OTHER_ATP_VALIDITY_TIME,
                            LastOtherATPmessageAge(k-1),
                            k)
#
@
LastOtherATPmessageAge，获取到的远端ATP消息的存活时间。
%
def LastOtherATPmessageAge(k):
    return Message.LastAge(OtherATPmessageAvailable(k),
                            OtherCCsynchroReport.LatestTimeOtherCore,
                            LastOtherATPmessageAge(k-1),
                            k)
#
@
OtherATPmessageValid，接收到的冗余ATP消息是否在有效期内。如果该消息已失效，则设置OtherATPmessageValid为False；否则为True。 
$
OtherATPmessageValid represents the effectiveness of the messages from redundant ATP. If this message is invalid, ATP will set OtherATPmessageValid as False; otherwise, it is set as True. 
%
def OtherATPmessageValid(k):
    return Message.Valid(OtherCCsynchroReport.LatestTimeOtherCore,
                         OTHER_ATP_VALIDITY_TIME,
                         k)
#
@
OtherATPminTime，本端ATP维护的冗余ATP的最小时间。设置规则如下：初始化时根据所在车头设置OtherATPminTime为默认值；否则，如果本周期收新的冗余ATP消息可用，则更新OtherATPminTime为消息中的currentTime；否则，如果冗余ATP消息仍然在有效期内，则对OtherATPminTime每周期加1，若越界则重新等于初始化值；否则，如果当前收到的新的冗余ATP消息（但不可用），则将OtherATPminTime更新为消息中的时间；其他情况，OtherATPminTime累加1，若越界则重新等于初始化值。
$
The OtherATPminTime stands for the local ATP maintained minimum time of
the redundant ATP. The setting rule is as following: In initialization, ATP set 
the OtherATPminTime as default value based on the CoreId of the redundant 
ATP. Or else:, if the updating message from the new redundant ATP in this 
cycle is available, ATP will update OtherATPminTime as the current time in 
the message. Or else:, if the redundant ATP message is still effective, ATP 
will add 1 in the OtherATPminTime until it is out of bound, and set is as 
initialization value. Or else:, If the received a new redundant ATP message, 
but it was not available, ATP shall update OtherATPminTime as in the 
message. Otherwise, accumulate OtherATPminTime.
%
if (CoreId == END_1)
    if (Initialization)
        OtherATPminTime = CC2_INIT_TIME
    elif ((OtherATPmessageAvailable(k) == True)
            or ((OtherATPmessageValid(k) == False)
                  and Exists(OtherCCsynchroReport)))
        OtherATPminTime = OtherCCsynchroReport.CurrentTime
    else:
        if (OtherATPminTime(k-1) >= CC2_MAX_TIME)
             OtherATPminTime = CC2_INIT_TIME
        else:
             OtherATPminTime = OtherATPminTime(k-1) + 1
else:
    if (Initialization)
        OtherATPminTime = CC1_INIT_TIME
    elif ((OtherATPmessageAvailable(k) == True)
            or ((OtherATPmessageValid(k) == False)
                  and Exists(OtherCCsynchroReport)))
        OtherATPminTime = OtherCCsynchroReport.CurrentTime
    else:
        if (OtherATPminTime(k-1) >= CC1_MAX_TIME)
             OtherATPminTime = CC1_INIT_TIME
        else:
             OtherATPminTime = OtherATPminTime(k-1) + 1
#
@
OtherATPmaxTime，维护冗余ATP的最大时间。
$
The OtherATPmaxTime stands for the local ATP maintained maximum time of the redundant ATP. The rules to update OtherATPmaxTime are similar with OtherATPminTime except that when received a new message from the redundant ATP, the OtherATPmaxTime shall add the maximum transmission delay in network.
%
if (CoreId == END_1)
    if (Initialization)
        OtherATPmaxTime = CC2_INIT_TIME
    elif ((OtherATPmessageAvailable(k) == True)
            or ((OtherATPmessageValid(k) == False)
                  and Exists(OtherCCsynchroReport)))
        OtherATPmaxTime = OtherCCsynchroReport.CurrentTime
                                  + LoopHourModularSub(ATPtime(k),
                                        OtherCCsynchroReport.LatestTimeOtherCore)
    else:
        if (OtherATPmaxTime(k-1) >= CC2_MAX_TIME)
             OtherATPmaxTime = CC2_INIT_TIME
        else:
             OtherATPmaxTime = OtherATPmaxTime(k-1) + 1
else:
    if (Initialization)
        OtherATPmaxTime = CC1_INIT_TIME
    elif ((OtherATPmessageAvailable(k) == True)
            or ((OtherATPmessageValid(k) == False)
                  and Exists(OtherCCsynchroReport)))
        OtherATPmaxTime = OtherCCsynchroReport.CurrentTime
                                  + LoopHourModularSub(ATPtime(k),
                                        OtherCCsynchroReport.LatestTimeOtherCore)
    else:
        if (OtherATPmaxTime(k-1) >= CC1_MAX_TIME)
             OtherATPmaxTime = CC1_INIT_TIME
        else:
             OtherATPmaxTime = OtherATPmaxTime(k-1) + 1
#
@
OtherATP，解析并存储远端ATP的消息。初始化或者远端消息过期时，设置相应的值为默认状态；当本周期收到新的远端消息时，将其设置为新收到消息的值；否则，保持不变。
$
OtherATP, parse and store messages from the distant ATP.In initialization or the message has expired, set all variables as default value; when new message available, set the corresponding value from the new message; otherwise, remain unchanged.
%
def OtherATP(k):
    if (Initialization
        or (not OtherATPmessageValid(k))):
        OtherATP.LatestTimeOtherCore = INVALID_LOOP_HOUR
        OtherATP.CoreId = None
        OtherATP.BeaconId = None
        OtherATP.EnableDoorOpening_A = False
        OtherATP.EnableDoorOpening_B = False
        OtherATP.PsdManagerOpeningOrder = False
        OtherATP.PsdIdSide_A = None
        OtherATP.PsdValiditySide_A = None
        OtherATP.PsdClosedSide_A = False
        OtherATP.PsdIdSide_B = None
        OtherATP.PsdValiditySide_B = None
        OtherATP.PsdClosedSide_B = False
        OtherATP.ZcVersion = None
        OtherATP.LocatedOnKnownPath = False
        OtherATP.LocatedWithMemLocation = False
        OtherATP.Location.Ext2 = None
        OtherATP.Location.Uncertainty = None
        OtherATP.Location.Ext1 = None
        OtherATP.SleepZoneId = None
        OtherATP.SleepZoneVersion = None
        OtherATP.MotionSinceLastReloc = None
        OtherATP.MotionSinceMemLoc = None
        OtherATP.TrainFilteredStopped = False
        OtherATP.SafetyParameterVersion = None
        OtherATP.SafetyApplicationVersion = None
        OtherATP.CC_SSID = None
        OtherATP.OverlapExpired = False
    elif (OtherATPmessageAvailable(k)):
        OtherATP.LatestTimeOtherCore = OtherCCsynchroReport.LatestTimeOtherCore(k)
        OtherATP.CoreId = OtherCCsynchroReport.CoreId
        OtherATP.BeaconId = OtherCCsynchroReport.BeaconId
        OtherATP.EnableDoorOpening_A = OtherCCsynchroReport.EnableDoorOpening_A
        OtherATP.EnableDoorOpening_B = OtherCCsynchroReport.EnableDoorOpening_B
        OtherATP.PsdManagerOpeningOrder = OtherCCsynchroReport.PsdManagerOpeningOrder
        OtherATP.PsdIdSide_A = OtherCCsynchroReport.PsdIdSide_A
        OtherATP.PsdValiditySide_A = OtherCCsynchroReport.PsdValiditySide_A
        OtherATP.PsdClosedSide_A = OtherCCsynchroReport.PsdClosedSide_A
        OtherATP.PsdIdSide_B = OtherCCsynchroReport.PsdIdSide_B
        OtherATP.PsdValiditySide_B = OtherCCsynchroReport.PsdValiditySide_B
        OtherATP.PsdClosedSide_B = OtherCCsynchroReport.PsdClosedSide_B
        OtherATP.ZcVersion = OtherCCsynchroReport.ZcVersion
        OtherATP.LocatedOnKnownPath = OtherCCsynchroReport.LocatedOnKnownPath
        OtherATP.LocatedWithMemLocation = OtherCCsynchroReport.LocatedWithMemLocation
        OtherATP.Location.Ext2 = OtherCCsynchroReport.Location.Ext2
        OtherATP.Location.Uncertainty = OtherCCsynchroReport.Location.Uncertainty
        OtherATP.Location.Ext1 = OtherCCsynchroReport.Location.Ext1
        OtherATP.SleepZoneId = OtherCCsynchroReport.SleepZoneId
        OtherATP.SleepZoneVersion = OtherCCsynchroReport.SleepZoneVersion
        OtherATP.MotionSinceLastReloc = OtherCCsynchroReport.MotionSinceLastReloc
        OtherATP.MotionSinceMemLoc = OtherCCsynchroReport.MotionSinceMemLoc
        OtherATP.TrainFilteredStopped = OtherCCsynchroReport.TrainFilteredStopped
        OtherATP.SafetyParameterVersion = OtherCCsynchroReport.SafetyParameterVersion
        OtherATP.SafetyApplicationVersion = OtherCCsynchroReport.SafetyApplicationVersion
        OtherATP.CC_SSID = OtherCCsynchroReport.CC_SSID
        OtherATP.OverlapExpired = OtherCCsynchroReport.OverlapExpired
    else:
        pass
    return OtherATP
#
@
BlockModeUsed，当前是否现在选择BM模式。其状态来自于项目可配置的列车输入采集。
$
BlockModeUsed represents that either of train end chooses BM mode. 
%
def BlockModeUsed(k):
    return Offline.GetBlockModeUsed(k)
#
@
BMvariantValidWhileTemporallyValid，当前是否使用BM变量。其状态来自于项目可配置的列车输入采集。
$
The status of BMvariantValidWhileTemporallyValid shows whether it is in the BM mode.  
%
def BMvariantValidWhileTemporallyValid(k):
    return Offline.GetBMvariantValidWhileTemporallyValid(k)
#
@
BeaconVariantsUpdating，判断是否要更新BM变量。若本周期满足以下所有条件时，则认为需要更新BM变量，设置BeaconVariantsUpdating为True。当前使用BM变量（BMvariantValidWhileTemporallyValid）；本周期未停车且收到信标消息且判断该信标带有BM变量；上周期列车未定位，或该BM信标方向与列车运营方向一致。否则，设置BeaconVariantsUpdating为False。
$
BeaconVariantsUpdating used to determine ATP whether to update the BM variants in this cycle. If all the following conditions are fulfilled, ATP shall set BeaconVariantsUpdating as True:The current operational mode is BLOCK MODE;And train moved and ATP received a BM beacon in this cycle; And the train is either not localized, or the direction of the BM variants is as same as the orientation of the train front end. Otherwise, ATP shall set BeaconVariantsUpdating as False.
%
def BeaconVariantsUpdating(k):
    return (BMvariantValidWhileTemporallyValid(k)
            and BeaconMessageReceive(k)
            and TrackMap.IsBmBeacon(BeaconMessage.ID)
            and not TrainFilteredStopped(k)
            and (not TrainLocalized(k-1)
                 or (TrackMap.BmBeaconDirection(BeaconMessage.ID)== TrainFrontOrientation(k-1))))
#
@
BMbeaconReadAge，记录读取BM信标到当前的时间，默认值为REPORT_AGE_MAX。
如果BM信标变量无效，该值应被设置为默认值，BM信标变量无效的条件如下：初始化；或当前不在BM模式(not BMvariantValidWhileTemporallyValid)；或BMbeaconReadAge已大于ATPsetting.VariantsBMfullValidityTime；或本周期收到的BM信标（BeaconVariantsUpdating为True）中DefaultMessage为True或BlockModeVariantAvailable为False；或本周期列车由定位转为失位状态；或当前使用的BM信标方向与已定位的列车运营方向TrainFrontOrientation不同。否则，如果本周期更新BM信标，则将该变量的初始值设置为1（因为ATP使用的是上个周期读到的信标信息）。其他情况，累加该变量。
%
def BMbeaconReadAge(k):
    if (Initialization
        or not BMvariantValidWhileTemporallyValid(k)
        or BMbeaconReadAge(k-1) > (ATPsetting.VariantsBMfullValidityTime - 1)
        or (BeaconVariantsUpdating(k)
            and (DefaultMessage(k) or not BlockModeVariantAvailable(k)))
        or (TrainLocalized(k-1)
            and (not TrainLocalized(k)
                  or TrackMap.BmBeaconDirection(UsedBMbeaconId(k-1))
                     is not TrainFrontOrientation(k-1)))):
        return REPORT_AGE_MAX
    elif (BeaconVariantsUpdating(k)):
        return 1
    else:
        return BMbeaconReadAge(k-1) + 1
#
@
BMbeaconVariantValue，获取来自BM信标中该变量的值，输入索引和周期，若过期为假值.
%
def BMbeaconVariantValue(lineSection, VarIndex, k):
    if (BMbeaconReadAge(k) > ATPsetting.VariantsBMfullValidityTime):
        return False
    else:
        for Var in range(0, MAX_BM_VARIANT_NB):
            if (BMbeaconVariants[Var].LineSection == LineSection
                and BMbeaconVariants[Var].Index == VarIndex):
                return BMbeaconVariants[Var].Value
            else:
                continue
        else:
            return False
#
@
UsedBMbeaconId用于记录当前所使用的BM变量来自哪个BM信标，判断条件如下：当初始化，非使用BM变量（not BMvariantValidWhileTemporallyValid），该信标方向与当前车头方向不符，或列车失位时，清除UsedBMbeaconId；否则，如果收到有效的BM信标，记录该信标id到UsedBMbeaconId；否则，保持UsedBMbeaconId不变。
$
UsedBMbeaconId records the used BM variants came from which BM beacon: When one of the following conditions fulfilled, ATP clear the UsedBMbeaconId: initialization,the BLOCK MODE variant is not temporally valid, the direction of the used BM beacon is not as same as train front orientation, the train is not localized. Or else:, when received a valid BM beacon, ATP update UsedBMbeaconId; Otherwise, keep this value unchanged.
%
def UsedBMbeaconId(k):
    if (BeaconVariantsUpdating(k)):
        return BeaconMessage.Id
    elif (Initialization
           or not BMvariantValidWhileTemporallyValid(k)
           or (TrainLocalized(k-1)
               and (TrackMap.BmBeaconDirection(UsedBMbeaconId(k-1))
                    is not TrainFrontOrientation(k-1)))
           or (TrainLocalized(k-1) and not TrainLocalized(k))):
        return None
    else:
        return UsedBMbeaconId(k-1)
#
@
BMvariantValidLastRisingAge, 记录从选择BM模式到当前经过的时间
%
def BMvariantValidLastRisingAge(k):
    if (not BMvariantValidWhileTemporallyValid(k)):
        BMvariantValidLastRisingAge = 0
    else:
        BMvariantValidLastRisingAge = BMvariantValidLastRisingAge(k-1) + 1
#
@
CBIvariantReportReceived，ATP软件收到CCNV转发的“CBI variant report”消息，并安全校核字校验正确。
%
def CBIvariantReportReceived(cbi, k):
    return Message.Received(CBIvariantReport(cbi), k)
#
@
CBIvariantReportAvailable，联锁消息可用
%
def CBIvariantReportAvailable(cbi, k):
    return Message.Available(CBIvariantReportReceived(cbi, k),
                                  CBIvariantReport(cbi).CcLoopHour,
                                  ATPsetting.VariantsBMlowValidityTime,
                                  min(CBIvariantReportLastAge(cbi, k-1),
                                       CBIminProductionAge(cbi, k-1),
                                       BMvariantValidLastRisingAge(k)),
                                       k)
#
@
CBIvariantReportLastAge，记录最新收到的联锁消息已存活的时间。
%
def CBIvariantReportLastAge(cbi, k):
    return Message.LastAge(CBIvariantReportAvailable(cbi, k),
                            CBIvariantReport(cbi).CcLoopHour,
                            CBIvariantReportLastAge(cbi, k-1),
                            k)
#
@
BMcbiVariants, 当来自CBI的变量可用时，存储CBI变量；其他时候保持不变。
%
def BMcbiVariants(cbi, k):
    if (CBIvariantReportAvailable(cbi, k)):
        for idx in range(0, CBIvariantReport.NumberOrVariants):
            BMcbiVariants[cbi].Variants[idx] = CBIvariantReport.Variant[idx]
    else:
        pass
    return BMcbiVariants
#
@
CBIvariantAge，CBI变量的有效存活时间，最大值为REPORT_AGE_MAX。
该值与CBIvariantReportLastAge的区别是在判断回复远端ATP消息时，使用
OtherATPmaxTime进行计算，在判断有效期时导向安全侧。
%
def CBIvariantAge(cbi, k):
    if (Initialization
        or CBIvariantAge(k-1) >= REPORT_AGE_MAX):
        return REPORT_AGE_MAX
    elif (CBIvariantReportAvailable(cbi, k)
          and Message.ReplyLocalCC(CBIvariantReport(cbi).CcLoopHour)):
        return (1 + Message.ModularSub(ATPtime(k), CBIvariantReport(cbi).CcLoopHour))
    elif (CBIvariantReportAvailable(cbi, k)
          and Message.ReplyDistantCC(CBIvariantReport(cbi).CcLoopHour)):
        return (1 + Message.ModularSub(OtherATPmaxTime(k), CBIvariantReport(cbi).CcLoopHour))
    else:
        return (1 + CBIvariantAge(cbi, k-1))
#
@
CBIvariantLowValidity，判断是否在CBI无线的短有效期内，用于PZ的监控。 在CBTC或者使用来自BM信标变量的情况下，该值为真。
%
def CBIvariantLowValidity(cbi, k):
    if (not BlockModeUsed(k)
        or not CBIvariantMoreAvailableThanBeacon(cbi, k)
        or CBIvariantAge(cbi, k) <= ATPsetting.VariantsBMlowValidityTime):
        return True
    else:
        return False
#
@
BMcbiVariantValue，根据联锁变量索引，获得CBI的变量。
%
def BMcbiVariantValue(CbiId, VarIndex, k):
    if (CBIvariantAge(CbiId, k) > ATPsetting.VariantsBMfullValidityTime):
        return False
    else:
        return BMcbiVariants[CbiId].Variants[VarIndex]
#
@
AppliedCBIvariantLoopHour，记录当前使用的CBI的变量的CC时间，供CCNV使用。
%
def AppliedCBIvariantLoopHour(cbiId, k):
    if (CBIvariantReportAvailable(cbiId, k)):
        return CBIvariantReport(cbiId).CcLoopHour
    else:
        return AppliedCBIvariantLoopHour(cbiId, k-1)
#
@
CBIvariantMoreAvailableThanBeacon，通过比较最后一次收到的BM信标的有效期，和对应变量所在该联锁区的无线变量，判断对于该变量，是使用来自CI无线的变量而非来自信标的变量。
$
ATP shall use the more recent message from beacons and CBI radio.
%
def CBIvariantMoreAvailableThanBeacon(CbiId, k):
    if (Initialization
        or not TrainLocatedOnKnownPath(k-1)
        or not ATPsetting.BlockModeThroughRadio(k)):
        return False
    else:
        return (UsedBMbeaconId(k) is None
                or (CBIvariantAge(CbiId, k) <= ATPsetting.VariantsBMfullValidityTime
                     and (CBIvariantReportLastAge(CbiId, k)
                          <= BMbeaconReadAge(k) + ATPsetting.VariantsBMradioPriorityDelay)
                     and (CBIvariantReportLastAge(CbiId, k) <= CBIminProductionAge(CbiId, k))))
#
@
BMvariantValue，统一来自BM信标和CBI无线的BM变量
%
def BMvariantValue(Variant, k):
    if (CBIvariantMoreAvailableThanBeacon(Variant.Cbi.Id, k)):
        return BMcbivariantValue(Variant.Cbi.Id, Variant.Cbi.Index, k)
    else:
        return BMbeaconVariantValue(Variant.LineSec.Id, Variant.LineSec.Index, k)
#
@
BMvariantRemainingTime，BM变量的剩余有效期
%
def BMvariantRemainingTime(cbi, k):
    if (not BMvariantValidWhileTemporallyValid(k)):
        return 0
    elif (CBIvariantMoreAvailableThanBeacon(cbi, k)):
        return max(0, ATPsetting.VariantsBMfullValidityTime - CBIvariantAge(cbi, k))
    else:
        return max(0, ATPsetting.VariantsBMfullValidityTime - BMbeaconReadAge(k))
#
@
VersionAuthorizationReceived，收到版本授权
%
def VersionAuthorizationReceived(lcId, k):
    return Message.Received(VersionAuthorization(lcId), k)
#
@
VersionAuthorizationAvailable，LC版本授权消息可用
%
def VersionAuthorizationAvailable(lcId, k):
    return Message.Available(VersionAuthorizationReceived(lcId, k),
                                  VersionAuthorization(lcId).CcLoopHour,
                                  ATPsetting.VersionsValidityTime,
                                  LastVersionReportAge(lcId, k-1),
                                  k)
#
@
LastVersionReportAge，记录从上次收到LC的版本信息到现在的时间。
%
def LastVersionReportAge(lcId, k):
    return Message.LastAge(VersionAuthorizationAvailable(lcId, k),
                            VersionAuthorization(lcId).CcLoopHour,
                            LastVersionReportAge(lcId, k-1),
                            k)
#
@
ReceivedVersionMessages，用于存储从LC收到的MAX_ZC_NB个ZC区的授权信息。由于每个ZC分属不同的LC管理，因此收到特定的LC消息时应仅更新其所对应ZC的版本授权状态。
%
def ReceivedVersionMessages(LcId, k):
    if (Initialization):
        ReceivedVersionMessages = None
    elif (VersionAuthorizationAvailable(LcId, k)):
        if (Message.ReplyLocalCC(VersionAuthorization(LcId).CcLoopHour)):
            NewValidity = (VersionAuthorization(LcId).CcLoopHour
                              + ATPsetting.VersionsValidityTime)
        else:
            NewValidity
                = (ATPtime(k) + ATPsetting.VersionsValidityTime
                   - (OtherATPmaxTime(k) - VersionAuthorization(LcId).CcLoopHour))
        for ZcId in range(0, MAX_ZC_NB):
            if  (TrackMap.Zc[ZcId].LcId == LcId):
                ReceivedVersionMessages[ZcId].VitalAuthorization
                    = VersionAuthorization(LcId).VitalAuthorization[ZcId]
                ReceivedVersionMessages[ZcId].ValidityTime = NewValidity
            else:
                pass
    else:
        ReceivedVersionMessages = ReceivedVersionMessages(k-1)
    return ReceivedVersionMessages
#
@
VersionAuthorizedByLC，获取ZC的版本授权状态
%
def VersionAuthorizedByLC(ZcId, k):
    if (Message.IsMoreRecent
          (ReceivedVersionMessages(TrackMap.Zc[ZcId].LcId ,k)[zcId].ValidityTime,
           ATPtime(k))):
        return ReceivedVersionMessages(TrackMap.Zc[ZcId].LcId, k)[zcId].VitalAuthorization
    else:
        return False
#
@
SameVersionWithDistantCore，比较来自远端ATP的安全软件，项目配置数据，以及线路地图版本号与本端是否一致
$
The local ATP shall compare the information from the redundant ATP to ensure the consistency, which includes versions of vital software, project configuration data and the track map. 
%
def SameVersionWithDistantCore(k):
    if (OtherATPmessageValid(k)
        and (OtherATP.SafetyParameterVersion == ATPsetting.SafetyParameterVersion)
        and (OtherATP.SafetyApplicationVersion == SafeApplicationVersion)):
        for ZcId in range(0, MAX_ZC_NB):
            if (OtherATP.ZcVersion[ZcId] != TrackMap.ZC[ZcId].Version):
                return False
            else:
                continue
        else:
            return True
    else:
        return False
#
@
EOAReportReceived，收到EOA消息
%
def EOAReportReceived(k):
    return Message.Received(EOAReport, k)
#
@
ZCmessageReady，表示本周期收到了有效的来自ZC的EOA和变量消息。当前时间大于消息中的ccLoopHour；消息中的ccLoopHour+EOA有效期，应大于当前时间。
$
ZCmessageReady represents that an available EOA and variants message from ZC received in this cycle.
%
def ZCmessageReady(k):
    return (Message.Available(EOAReportReceived(k),
                                   EOA_Report.CcLoopHour,
                                   ATPsetting.EOAvalidityTime,	
                                   LastEOAReportAge(k-1),
                                   k)
            and (VersionAuthorizedByLC(SSIDofZC, k))
            and (Message.ReplyLocalCC(EOA_Report.CcLoopHour)
                 or SameVersionWithDistantCore(k)))
#
@
LastEOAReportAge，数值型，上次发出loc-report的周期数减去EOA在ZC端消耗的时间（CC周期数）。
$
LastEOAReportAge represents the value calculated by current ATP time minus the previous loc-report number and the EOA consuming time in ZC. 
%
def LastEOAReportAge(k):
    return Message.LastAge(ZCmessageReady(k),
                            EOA_Report.CcLoopHour,
                            LastEOAReportAge(k-1),
                            k)
#
@
EOAgroundAge，数值型，在收到EOA消息时，其时间已经消耗了几个CC的周期。需同时维护WithoutSpaceEoa和普通EOA。
$
EOAgroundAge stands for the number of CC cycle when receiving the EOA information.
%
def EOAgroundAge(k):
    if (Initialization):
        EOAgroundAge.WithoutSpacing = REPORT_AGE_MAX
        EOAgroundAge.Classic = REPORT_AGE_MAX
    elif (ZCmessageReady(k)):
        EOAgroundAge.WithoutSpacing = (round.ceil
                                       ((EOA_Report.MessageContainerCreationTime
                                         - EOA_Report.WithoutSpacingEoaCreationTime)
                                        * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS))
        EOAgroundAge.Classic = round.ceil((EOA_Report.MessageContainerCreationTime
                                           - EOA_Report.EoaCreationTime)
                                          * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS)
    else:
        EOAgroundAge = EOAgroundAge(k-1)
    return EOAgroundAge
#
@
ReceivedEOAreport，判断当新收到EOA消息的有效期大于之前存储EOA消息有效期时，更新EOA。需同时维护WithoutSpaceEoa和普通EOA。当存储的EOA消息过期后，清除该消息。
%
def ReceivedEOAreport(k):
    if (Initialization):
        ReceivedEOAreport = None
    elif (ZCmessageReady(k)):
        ReceivedEOAreport.TrainFrontEnd = EOA_Report.TrainFrontEnd
        ReceivedEOAreport.Classic = UpdateReceivedEoa(EOA_Report.CcLoopHour,
                                                               EOAgroundAge(k).Classic,
                                                               EOA_Report.Classic,
                                                               ReceivedEOAreport(k-1).Classic)
        ReceivedEOAreport.WithoutSpacing = (UpdateReceivedEoa
                                                   (EOA_Report.CcLoopHour,
                                                    EOAgroundAge(k).WithoutSpacing,
                                                    EOA_Report.WithoutSpacing,
                                                    ReceivedEOAreport(k-1).WithoutSpacing))
        ReceivedEOAreport.CcLoopHour = EOA_Report.CcLoopHour
    else:
        ReceivedEOAreport = ReceivedEOAreport(k-1)
        if (Message.IsMoreRecent(ATPtime(k), ReceivedEOAreport.Classic.ValidityTime)):
            clean_reseived_eoa_classic
        if (Message.IsMoreRecent(ATPtime(k), ReceivedEOAreport.WithoutSpacing.ValidityTime)):
            clean_reseived_eoa_without_space
    return ReceivedEOAreport
def UpdateReceivedEoa(NewEoaLoopHour, EoaGroundAge, NewReceivedEoa, PreviousReceivedEoa):
    if (Message.ReplyLocalCc(NewEoaLoopHour)):
        NewValidity = (NewEoaLoopHour - EoaGroundAge + ATPsetting.EOAvalidityTime)
    else:
        NewValidity = (ATPtime(k) - EoaGroundAge + ATPsetting.EOAvalidityTime
                          - (OtherATPmaxTime(k) - NewEoaLoopHour))
    if (Message.IsMoreRecent(NewValidity, ATPtime(k))
        and (Message.IsMoreRecent(NewValidity, PreviousReceivedEoa.ValidityTime))):
        return NewReceivedEoa
    else:
        return PreviousReceivedEoa
#
@
VariantGroundAge，将ZC端的变量生存时间转换为CC周期数
$
VariantGroundAge shows the survival time of the variants in ZC.
%
def VariantGroundAge(lineSec, k):
    VariantGroundAge = round.ceil((EOA_Report.MessageContainerCreationTime
                                         - VariantReport(lineSec).CreationTime)
                                        * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS)
    return VariantGroundAge
#
@
VariantReportReceived，收到ZC变量消息
%
def VariantReportReceived(LineSec, k):
    return Message.Received(VariantReport(LineSec), k)
#
@
ReceivedVariantReport，存储来自ZC的变量消息，如ST_VARIANT_RCV所示，按照LineSection进行存储：
%
def ReceivedVariantReport(LineSec, k):
    if (ZCmessageReady(k)
        and VariantReportReceived(LineSec, k)):
        if (Message.ReplyLocalCc(ReceivedEOAreport(k).CcLoopHour)):
            NewValidity = (ReceivedEOAreport(k).CcLoopHour
                            - VariantGroundAge(LineSec, k)
                            + ATPsetting.VariantsCBTCvalidityTime)
        else:
            NewValidity = (ATPtime(k) - VariantGroundAge(LineSec, k)
                            + ATPsetting.VariantsCBTCvalidityTime
                            - (OtherATPmaxTime(k) - ReceivedEOAreport(k).CcLoopHour))
        if (Message.IsMoreRecent(NewValidity, ATPtime(k))
            and (Message.IsMoreRecent
                 (NewValidity, ReceivedVariantReport[LineSec](k-1).ValidityTime))):
            ReceivedVariantReport[LineSec].ValidityTime = NewValidity
            ReceivedVariantReport[LineSec].Variants = VariantReport(LineSec, Variants)
        else:
            ReceivedVariantReport[LineSec] = ReceivedVariantReport[LineSec](k-1)
    else:
        ReceivedVariantReport[LineSec] = ReceivedVariantReport[LineSec](k-1)
    return ReceivedVariantReport
#
@
CBTCvariantValue，维护CBTC下变量的值。如果变量有效期大于当前时间，则使用该变量；否则为限制状态。
$
ATP shall maintain the validation of CBTC variants message from ZC. if the validation timeout, ATP should set all CBTC variants to restrictive state.
%
def CBTCvariantValue(Variant, k):
    if (ReceivedVariantReport(Variant.LineSec.Id, k).ValidityTime > ATPtime(k)):
        return ReceivedVariantReport(Variant.LineSec.Id, k).Status(Variant.LineSec.Index)
    else:
        return False
#
@
VariantValue，统一CBTC和BM下的变量
%
def VariantValue(Variant, k):
    if (BlockModeUsed(k)):
        return BMvariantValue(Variant, k)
    else:
        return CBTCvariantValue(Variant, k)
#
@
BeaconCount，ATP记录从上电开始，到当前周期共收到多少次Top-loc信号。
$
BeaconCount represents the accumulated number of received Top-loc signal from power on to current cycle.
%
if (Initialization)
    BeaconCount = 0
else:
     BeaconCount = LockedTopLocCounter(k) + BeaconCount(k-1)
#
@
如果本周期BeaconMessageReceive为True，则从LockedBeaconMsgByte中获取信标ID，设置BeaconMessage.ID；其他情况保持不变。
$
If the status of BeaconMessageReceive is True, the BeaconMessage.ID is obtained by LockedBeaconMsgByte; Otherwise, keep it unchanged.
%
if (Initialization)
    BeaconMessage.ID = 0
elif (BeaconMessageReceive(k))
    BeaconMessage.ID = LockedBeaconMsgByte[BEACON_ID_BITS]
else:
    BeaconMessage.ID = BeaconMessage.ID(k-1)
#
@
如果本周期BeaconMessageReceive为True，则从LockedBeaconMsgByte中获取变量数据，设置数组BeaconMessage.Variants[MAX_BM_VARIANT_NB]；若本周期未读到新的信标则保持不变。其中BM_VARIANTS_BIT_0...BM_VARIANTS_BIT_15表示[REF4]中定义的信标消息中表示BM信标变量的位数。
$
If the BeaconMessageReceive is True, the variants is come from LockedBeaconMsgByteand ATP set as BeaconMessage.Variants[MAX_BM_VARIANT_NB]; if there is no beacon read at the end of cycle, there is no changes. BM_VARIANTS_BIT_0...BM_VARIANTS_BIT_15 represents the index of BM beacon variants defined in [REF4].
%
if (Initialization)
    BeaconMessage.Variants = {0,..,0}
elif (BeaconMessageReceive(k))
    BeaconMessage.Variants(k)
        = {LockedBeaconMsgByte[BM_VARIANTS_BIT_0],
            ...,
            LockedBeaconMsgByte[BM_VARIANTS_BIT_15]}
else:
    BeaconMessage.Variants = BeaconMessage.Variants(k-1)
#
@
如果本周期BeaconMessageReceive为True，则从LockedBeaconMsgByte中判断是否默认消息，设置BeaconMessage.DefaultMessage；若本周期未读到新的信标则保持不变。其中DEFAULT_MESSAGE_BIT表示[REF4]中定义的信标消息中表示信标是否为默认消息的位数。
$
If the BeaconMessageReceive is True, the default message is judged by LockedBeaconMsgByteand ATP set the BeaconMessage.DefaultMessage; if there is no new beacon read, it keeps unchanged. DEFAULT_MESSAGE_BIT represents the index of beacon that judges default message, which defined in the [REF4].
%
if (Initialization)
    BeaconMessage.DefaultMessage = False
elif (BeaconMessageReceive(k))
    BeaconMessage.DefaultMessage(k)
        = LockedBeaconMsgByte[DEFAULT_MESSAGE_BIT]
else:
    BeaconMessage.DefaultMessage = BeaconMessage.DefaultMessage(k-1)
#
@
如果本周期BeaconMessageReceive为True，则从LockedBeaconMsgByte中判断变量是否可用信息，设置BeaconMessage.BlockModeVariantAvailable；若本周期未读到新的信标则保持不变。其中BLOCK_MODE_VARIANT_AVAILABLE_BIT表示[REF4]中定义的信标消息中表示信标所带变量是否可用的位数。
$
If the BeaconMessageReceive is True, it is feasible to judge whether the variants are available through LockedBeaconMsgByte and ATP set as BeaconMessage.BlockModeVariantAvailable; If there is no new beacon read, it keeps invariable. BLOCK_MODE_VARIANT_AVAILABLE_BIT stands for the index of the beacon variants in the beacon message defined in [REF4]. 
%
if (Initialization)
    BeaconMessage.BlockModeVariantAvailable = False
elif (BeaconMessageReceive(k))
    BeaconMessage.BlockModeVariantAvailable(k)
        = LockedBeaconMsgByte[BLOCK_MODE_VARIANT_AVAILABLE_BIT]
else:
    BeaconMessage.BlockModeVariantAvailable(k)
        = BeaconMessage.BlockModeVariantAvailable(k-1)
#
@
TeethCounter，ATP根据IdenticalLockedOdometer中锁存的最后一个中断的CogCounter变化值，更新TeethCounter，作为主任务使用的里程计齿数值。TeethCounter的计算应考虑里程计安装方向和CogCounter的寄存器取值范围。TeethCounter是有符号值。如果TeethCounter大于0，则表示里程计相对于初始位置向列车END_1方向转动；反之如果小于0，则表示里程计相对于初始位置向列车END_2方向转动。
$
TeethCounter used as the odometer cog value in one deferred task, which is the difference of the CogCounter in the last interrupt of adjacent cycle. The calculation of the TeethCounter shall consider the installation direction of the odometer and the register range of the CogCounter. TeethCounter is a signed value. If TeethCounter greater than 0, then means the odometer rotating toward to the train END_1 direction; other hand, if it less than 0, then means the odometer rotating toward to the END_2.
%
TeethCounter(k)
 = TeethCounter(k-1)
    + (IdenticalLockedOdometer[ATP_INTERRUPT_NB - 1].CogCounter(k)
         - IdenticalLockedOdometer[ATP_INTERRUPT_NB - 1].CogCounter(k-1))
       * ATPsetting.CCcoreOdoCogIncreasing[CoreId]
#
@
CogPositionBeforeTopLoc，CogPositionAfterTopLoc，如果本周期读到信标，则通过IdenticalLockedOdometer计算读到信标瞬间的里程计齿数信息：
使用Top-loc发生的前一个中断的CogCounter来更新。CogPositionBeforeTopLoc；使用Top-loc发生时中断的CogCounter来更新CogPositionAfterTopLoc；其他情况，CogPositionBeforeTopLoc和CogPositionAfterTopLoc保持不变。其中i表示锁存收到Top-loc信号的那个中断。如果上下CPU收到Top-loc相差1个中断，则使用较早的的中断作为计算CogPositionBeforeTopLoc的依据，而较迟的那个中断作为计算CogPositionAfterTopLoc的依据。
$
If a beacon with top-loc received in this cycle, ATP shall record the cog position of the interrupt when and just before the top-loc happen:
CogPositionBeforeTopLoc, the CogCounter in the interrupt just before the top-loc happen; CogPositionAfterTopLoc, the CogCounter in the interrupt when the top-loc happen. Which, i means the interrupt received top-loc signal.
%
CogPositionBeforeTopLoc(k)
 = TeethCounter(k-1)
   + ((IdenticalLockedOdometer[i-1].CogCounter(k)
       - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k-1))
       * ATPsetting.CCcoreOdoCogIncreasing[CoreId]))
CogPositionAfterTopLoc(k)
 = TeethCounter(k-1)
   + ((IdenticalLockedOdometer[i].CogCounter(k)
        - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k-1))
      * ATPsetting.CCcoreOdoCogIncreasing[CoreId]))
#
@
WheelStopped，如果当前在进行传感器测试，且任一中断中未发生三路全通或全堵错误，且一个周期所有中断内三路传感器的导通状态都与上周期的结果相同时，输出WheelStopped为True。否则为False。
$
Wheel shall consider safely stopped WheelStopped at cycle k if the following conditions are fulfilled: sensors test has been performed, and at least one sensor out of three sensors C1, C2, C3 has detected expected sequence,
and at least one sensor out of three sensors C1, C2, C3 has not detected expected sequence, and sensors test result combination on three sensors C1, C2, C3 has not changed between cycle k-1 and k.
%
if (SensorTestPerformed(k) == True)
    WheelStopped(k)
     = ((UnconsistentSensorTest(k) == False)
       and (SensorSequenceDetected_1 = SensorSequenceDetected_1(k-1))
       and (SensorSequenceDetected_2 = SensorSequenceDetected_2(k-1))
       and (SensorSequenceDetected_3 = SensorSequenceDetected_3(k-1)))
else:
    WheelStopped = False
#
@
WheelFilteredStopped，判断本周期车轮是否处于滤过停止状态，规则如下：
如果WheelFilteredStopped上周期为False，而本周期WheelStopped由False变为True，则认为本周期为True。在此条件下，记录停车时的齿数LastStopCogPosition为当前齿数。WheelFilteredStopped由True变为False的条件：齿数移动超过1个齿。
$
At cycle k, WheelFilteredStopped shall change from False to True on raising edge of WheelStopped information, That is, if: WheelStopped information was False at cycle k-1,and WheelStopped information was True at cycle k. and then: LastStopCogPosition is assigned to TeethCounter， At cycle k, WheelFilteredStopped shall change from True to False, according following expression: the cog moved more than one cog;
%
def WheelFilteredStopped(k):
    if (not WheelFilteredStopped(k-1)
        and not WheelStopped(k-1)
        and WheelStopped(k)):
        LastStopCogPosition = TeethCounter(k)
        return True
    elif (WheelFilteredStopped(k-1)
          and not UnconsistentSensorTest(k)
          and abs(TeethCounter(k) - LastStopCogPosition) <= 1):
        return True
    else:
        return False
#
@
MaxCountCogsRunInCycleExceeded，里程计转过齿数不能超过周期最大值，也不能超过的相邻中断的最大值。
$
ATP shall detect whether the cog number counted in adjacent interrupt is greater than the default maximum cog number on cycle or on interrupt.
%
def MaxCountCogsRunInCycleExceeded(k):
    if (abs(IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k)
            - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k-1))
         > ATPsetting.OdoMaxCogOnCycle):
        return True
    else:
        for i in range(ATP_INTERRUPT_NB-1):
            if (abs(IdenticalLockedOdometer[i].CogCounter
                     - IdenticalLockedOdometer[i+1].CogCounter)> ATPsetting.OdoMaxCogOnIntrrupt):
                return True
            else:
                continue
        return False
#
@
WheelKinematicsInvalidForCogCount，如果ATP检测到某个中断的齿数转过最大值时，设置齿数计算错误。
$
If the calculated movement exceeds the default one, ATP shall set the wheel kinematics invalid.
%
WheelKinematicsInvalidForCogCount = MaxCountCogsRunInCycleExceeded(k))
#
$
If OdometerState is NOT_INITIALIZED at cycle k, and if wheel detected stopped at cycle k, then WheelMinimumMovement and WheelMaximumMovement shall be set to zero.
%
if (OdometerState(k) == NOT_INITIALIZED)
    if (WheelFilteredStopped(k) == True))
         WheelMinimumMovement = 0
         WheelMaximumMovement = 0
    else:
         WheelMinimumMovement = ―ATPsetting.MaxMotionPerCycle
         WheelMaximumMovement = ATPsetting.MaxMotionPerCycle
#
@
里程计状态由NOT_INITIALIZED变为WAITING_COG_POSITION_CODE_READY的条件是:上周期在NOT_INITIALIZED；上周期在WheelFilteredStopped；本周期未WheelFilteredStopped而且未检测到传感器测试失败。
$
At cycle k, ATP shall consider that OdometerState changes from NOT_INITIALIZED to WAITING_COG_POSITION_CODE_READY if: a falling edge is detected on WheelFilteredStopped information, and sensors test is consistent at cycle k and was consistent at cycle k-1。
%
if ((OdometerState(k-1) =  NOT_INITIALIZED)
    and (not WheelFilteredStopped(k) and not UnconsistentSensorTest(k))
    and (WheelFilteredStopped(k-1))
    OdometerState =  WAITING_COG_POSITION_CODE_READY
#
@
若检测到传感器三路全通或全堵，则进入INVALID传感器无效。
$
At cycle k, ATP shall consider that OdometerState changes from NOT_INITIALIZED to INVALID，if sensors test is not consistent at cycle k.
%
if ((OdometerState(k-1) = NOT_INITIALIZED)
    and UnconsistentSensorTest(k))
    OdometerState = INVALID
#
@
InitializationTimer，在WAITING_COG_POSITION_CODE_READY状态下累加初始化时间.
$
ATP shall accumulate the time for waiting cog position ready state.
%
if (OdometerState(k-1) == WAITING_COG_POSITION_CODE_READY
     and OdometerState(k) == WAITING_COG_POSITION_CODE_READY)
    InitializationTimer =  InitializationTimer(k-1) + 1 
elif (OdometerState(k-1) != WAITING_COG_POSITION_CODE_READY
     and OdometerState(k) == WAITING_COG_POSITION_CODE_READY)
    InitializationTimer = 1
else:
    InitializationTimer = 0
#
@
由WAITING_COG_POSITION_CODE_READY转回NOT_INITIALIZED状态的条件：
$
At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to NOT_INITIALIZED if:
wheel is detected stopped (WheelFilteredStopped),and cog position remains 
unknown (not OdometerCogPositionReady), and there is no sensors test 
inconsistency, and time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is strictly less than ATPsetting.OdoInitTimeout
%
if (OdometerState(k-1) = WAITING_COG_POSITION_CODE_READY)
    and WheelFilteredStopped(k)
    and not OdometerCogPositionReady(k)
    and not UnconsistentSensorTest(k)
    and (InitializationTimer(k) < ATPsetting.OdoInitTimeout)
   OdometerState =  NOT_INITIALIZED
#
@
由WAITING_COG_POSITION_CODE_READY转入INITIALIZED状态的条件：
$
At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to INITIALIZED
If: Cog position is safely known which means that wheel angular position is well-known;and there is no sensors test inconsistency; and time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is strictly less than ATPsetting.OdoInitTimeout.
%
if (OdometerState(k-1) == WAITING_COG_POSITION_CODE_READY
    and OdometerCogPositionReady(k)
    and not UnconsistentSensorTest(k)
    and (InitializationTimer(k)< ATPsetting.OdoInitTimeout))
    OdometerState = INITIALIZED
#
@
由WAITING_COG_POSITION_CODE_READY转入INVALID的条件：
￥
At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to INVALID if:sensors test inconsistency is detected, or time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is more than or equal to the ATPsetting.OdoInitTimeout。
%
if (OdometerState(k-1) ==  WAITING_COG_POSITION_CODE_READY)
   and ((InitializationTimer(k)>= ATPsetting.OdoInitTimeout)
          or UnconsistentSensorTest(k))
    OdometerState = INVALID
#
@
在里程计初始化阶段，ATP需根据当前车头激活方向和上周期位移的结果，对本周期位移进行过估处理。
$
When odometer is initializing, wheel movement shall be over and under estimated considering maximum acceleration per cycle according with the train front:
%
if (OdometerState(k) ==  WAITING_COG_POSITION_CODE_READY)
    if ((TrainFrontEnd(k-1) == END_2) or (NoUndetectableDanger_2(k-1) == True))
         WheelMinimumMovement(k) = WheelMinimumMovement(k-1) + ATPsetting.MaxMotionPerCycle
         WheelMaximumMovement(k) = WheelMaximumMovement(k-1) - ATPsetting.MaxMotionPerCycle
    else:
         WheelMinimumMovement(k) = WheelMinimumMovement(k-1) ― ATPsetting.MaxMotionPerCycle
         WheelMaximumMovement(k) = WheelMaximumMovement(k-1) + ATPsetting.MaxMotionPerCycle
#
@
当上周期里程计已在INITIALIZED状态，并满足以下条件之一时，里程计状态由INITIALIZED变为INVALID：传感器测试检测出三路全通全堵；或者，非停车状态，而且齿数齿号也不一致。
$
At cycle k, ATP shall consider that OdometerState changes from INITIALIZED to INVALID if:OdometerState was evaluated Initialized at cycle k-1,And:Sensors test result is inconsistent;Or neither wheel filtered stopped nor cog position ready.
%
if (OdometerState(k-1) is INITIALIZED
     and ((UnconsistentSensorTest(k) == True)
           or (not WheelFilteredStopped(k)
                and not OdometerCogPositionReady(k)))):
    OdometerState = INVALID
#
@
在INITIALIZED状态，如果齿数齿号匹配，则计算车轮最大最小位移依据伪代码中的公式：对于车载ATP软件的位移，在齿数齿号匹配的状态下，无论ATP位于END_1还是END_2，也无论激活哪段车头，始终以END_1方向为位移的正方向。即当位移大于0时，表示列车向END_1端方向运行，反之则向END_2端方向运行。
$
If motion and speed are available at cycle k, then wheel curvilinear movement calculates as follows: When odometer cog-counter-code matched, regardless of ATP in END_1 or END_2, and no matter the activation of train front, the direction towards END_1 is always be set as the positive direction. That is, when the movement is greater than 0, indicating the direction of the train is running to END_1, and vice versa to END_2.
%
if (OdometerState(k) is INITIALIZED):
    WheelMinimumMovement(k) = MinCogCalibration(k-1) * (TeethCounter(k) ― TeethCounter(k-1))
    WheelMaximumMovement(k) = MaxCogCalibration(k-1) * (TeethCounter(k) ― TeethCounter(k-1))
#
@
在无效状态停车，并未检测到传感器错误，则能回到非初始化状态。
$
At cycle k, ATP shall consider that OdometerState changes from INVALID to NOT_INITIALIZED if:OdometerState was evaluated Invalid at cycle k-1,and wheel is detected stopped (WheelFilteredStopped),and there is no sensors test inconsistency.
%
if (OdometerState(k-1) == INVALID
     and WheelFilteredStopped(k)
     and not UnconsistentSensorTest(k))
    OdometerState = NOT_INITIALIZED
#
@
在里程计无效状态下，ATP直接使用测得值计算车轮位移（因为此时列车运动学失效，后续功能并不使用测得的列车车轮位移）。
$
In invalid status, ATP shall calculate wheel movement by using measured value of the odometer.
%
if (OdometerState(k) == INVALID)
    WheelMinimumMovement(k) = MinCogCalibration(k-1) * (TeethCounter(k) ― TeethCounter(k-1))
    WheelMaximumMovement(k) = MaxCogCalibration(k-1) * (TeethCounter(k) ― TeethCounter(k-1))
#
@
SensorTestContradiction，当里程计读数为0，但中断中却未进行传感器测试时，设置该变量为True，否则为False。
NoCommunicationWithOdometer，当SensorTestContradiction保持为True超过限定时间后，设置该值为真，表明中断中的传感器测试判断失败。
$
ATP shall invalidate wheel kinematic if minimum odometer motion is null and sensors test is not performed for more than ATPsetting.OdoTestContradictionDuration.
%
def SensorTestContradiction(k):
    return (not WheelFilteredStopped(k)
            and TeethCounter(k-1) == TeethCounter(k-2)
            and not SensorTestPerformed(k))
def NoCommunicationWithOdometer(k):
    if (Initialization
        or not SensorTestContradiction(k)):
        SensorTestContradictionDuration = 0
        return False
    else:
        SensorTestContradictionDuration = SensorTestContradictionDuration(k-1) + 1
        
        if (SensorTestContradictionDuration > ATPsetting.OdoTestContradictionDuration):
            return True
        else:
            return False
#
@
ValidWheelKinematic，车轮运动学特性有效.
$
Wheel kinematic is valid if odometer is valid, the calculated motion is not greater than the default value, and there is communication with odometer.
%
ValidWheelKinematic(k)
 = ((OdometerState(k) != INVALID)
   and (not WheelKinematicsInvalidForCogCount(k))
   and (not NoCommunicationWithOdometer(k)))
#
@
WheelMinSpeed，里程计测得车轮最小速度，非负值。
%
def WheelMinSpeed(k):
    return round.floor(abs(WheelMinimumMovement(k)) / ATP_CYCLE_TIME)
#
@
WheelMaxSpeed，ATP根据里程计测得位移计算车轮最大速度，该值为非负数，并且向上取整。
$
ATP calculates the maximum wheel speed according to the maximum wheel movement; this value is non-negative and rounded up.
%
def WheelMaxSpeed(k):
    return round.ceil(abs(WheelMaximumMovement(k)) / ATP_CYCLE_TIME)
#
@
InstantaneousWheelAcceleration，在进行最大位移过估算法之前，需计算瞬时车轮加速度（为减少采样周期过短使得采样误差导致的加速度大幅变化，ATP使用相邻2个周期的算术平均加速度作为瞬时加速度）。
$
When wheel motion and acceleration are measurable, then instantaneous acceleration computed according following expression:
%
def InstantaneousWheelAcceleration(k):
    return ((abs(TeethCounter(k) - TeethCounter(k-2))
             - abs(TeethCounter(k-2) - TeethCounter(k-4)))
            * MaxCogCalibration(k-1) / pow(2*ATP_CYCLE_TIME))
#
@
FilteredWheelAcceleration，在进行最大位移过估算法之前，ATP需计算FILTERED_ACCELERATION_NB个周期的滤波平均加速度
$
FilteredWheelAcceleration measurement is the average of InstantaneousWheelAcceleration over FILTERED_ACCELERATION_NB cycles for filtering the fluctuation causing by the sampling period.
%
FilteredWheelAcceleration(k)
 = (InstantaneousWheelAcceleration(k)
     + InstantaneousWheelAcceleration(k-1)
     + ...
     + InstantaneousWheelAcceleration(k-FILTERED_ACCELERATION_NB+1))
    / FILTERED_ACCELERATION_NB
#
@
AverageWheelAcceleration，在进行最大位移过估算法之前，ATP需计算AVERAGE_ACCELERATION_NB个周期的平均车轮加速度
$
When wheel motion and acceleration are measurable, sliding average acceleration at cycle k defined by following expression:
%
AverageWheelAcceleration(k)
 = (InstantaneousWheelAcceleration(k)
     + InstantaneousWheelAcceleration(k-1)
     + ...
     + InstantaneousWheelAcceleration(k-AVERAGE_ACCELERATION_NB+1))
    / AVERAGE_ACCELERATION_NB
#
@
StartBrakingMovementMax，记录由COASTING→BRAKING，COASTING→SLIDING，或BRAKING→SLIDING状态时的最大位移。
$
ATP records the maximum movement when the state transferring from COASTING to BRAKING or SLIDING, or from BRAKING to SLIDING.
%
def StartBrakingMovementMax(k):
    if (Initialization
        or (MotionOverEstimationState(k) is COASTING)):
        return 0
    elif ((MotionOverEstimationState(k-1) is COASTING
             and MotionOverEstimationState(k) is BRAKING)
            or (MotionOverEstimationState(k-1) is COASTING
                 and MotionOverEstimationState(k) is SLIDING)
            or (MotionOverEstimationState(k-1) is BRAKING
                 and MotionOverEstimationState(k) is SLIDING))):
        return MaximumTrainMotion(k-1)
    else:
        return StartBrakingMovementMax(k-1)
#
@
MaxMotionDuringBrakingOrSliding，在制动或者打滑状态下反向运行的最大位移.
$
ATP shall record the reversed motions during the braking or sliding state.
%
if (StartBrakingMovementMax(k-1) > 0)
    MaxMotionDuringBrakingOrSliding(k)
     = min((MaxMotionDuringBrakingOrSliding(k-1) + WheelMaximumMovement(k)), 0)
elif (StartBrakingMovementMax(k-1) < 0)
    MaxMotionDuringBrakingOrSliding(k)
     = max((MaxMotionDuringBrakingOrSliding(k-1) + WheelMaximumMovement(k)), 0)
else:
    MaxMotionDuringBrakingOrSliding = 0
#
@
MaxMotionOdometerSignChanged，用于监控是否发生了测得车轮位移反向.
$
If the reversed motion during braking or sliding state is greater than a project defined distance, ATP shall consider the motion sign changed.
%
def MaxMotionOdometerSignChanged(k):
    return (sign(StartBrakingMovementMax(k-1)) != sign(WheelMaximumMovement(k))
            and (abs(MaxMotionDuringBrakingOrSliding(k))
                  > ATPsetting.OdoMinDistAfterSenseChange)) 
#
@
StartSlidingSpeed，记录由COASTING或BRAKING进入SLIDING状态时的速度。
$
ATP shall record the speed when the train begins to slide.
%
if (Initialization
     or (MotionOverEstimationState(k) == COASTING)
     or (MotionOverEstimationState(k) == BRAKING))
    StartSlidingSpeed = 0
elif (((MotionOverEstimationState(k-1) == COASTING)
          or (MotionOverEstimationState(k-1) == BRAKING))
       and (MotionOverEstimationState(k) == SLIDING))
    StartSlidingSpeed = WheelMaxSpeed(k-1)
else:
    StartSlidingSpeed = StartSlidingSpeed(k-1)
#
@
TimeInSliding，记录在SLINDING状态下持续了多少个周期.
$
ATP shall record how many cycles staying in SLIDING state.
%
if (Initialization
     or ((MotionOverEstimationState(k-1) == SLIDING)
          and (MotionOverEstimationState(k) != SLIDING)))
    TimeInSliding = 0
elif (MotionOverEstimationState(k) == SLIDING)
    TimeInSliding = TimeInSliding(k-1) + 1
else:
    TimeInSliding = TimeInSliding(k-1)
#
@
当满足以下条件时，MotionOverEstimationState由COASTING转入BRAKING，并执行：
$
The state transfers from “COASTING” to “BRAKING” when: 
%
if ((MotionOverEstimationState(k-1) == COASTING)
    and (WheelFilteredStopped(k) != True)
    and (FilteredWheelAcceleration(k)< ATPsetting.BrakingStartAcc)
    and (FilteredWheelAcceleration(k)>= ATPsetting.SlidingStartAcc)
    and OdometerState(k) is INITIALIZED)
    MotionOverEstimationState = BRAKING
#
$
The MotionOverEstimationState transfers from “COASTING” to “SLIDING” when: 
%
if ((MotionOverEstimationState(k-1) == COASTING)
    and (WheelFilteredStopped(k) != True)
    and (FilteredWheelAcceleration(k) < ATPsetting.SlidingStartAcc)
    and OdometerState(k) is INITIALIZED)
    MotionOverEstimationState = SLIDING
#
$
The MotionOverEstimationState transfers from “BRAKING” to “SLIDING” when: 
%
if (MotionOverEstimationState(k-1) == BRAKING
    and (FilteredWheelAcceleration(k) < ATPsetting.SlidingStartAcc)
    and (AverageWheelAcceleration(k) < ATPsetting.BrakingStartAcc)
    and (OdometerState(k) is INITIALIZED)
    and (not MaxMotionOdometerSignChanged(k)))
    MotionOverEstimationState = SLIDING
#
$
The MotionOverEstimationState transfers from “BRAKING” to “COASTING” when: 
%
if (MotionOverEstimationState(k-1) == BRAKING
    and ((AverageWheelAcceleration(k)>= ATPsetting.BrakingStartAcc)
          or (OdometerState(k) is INVALID)
          or (MaxMotionOdometerSignChanged(k))))
    MotionOverEstimationState = COASTING
#
$
The MotionOverEstimationState transfers from “SLIDING” to “COASTING” when:
%
if ((MotionOverEstimationState(k-1) == SLIDING)
     and ((OdometerState(k) is INVALID)
           or (MaxMotionOdometerSignChanged(k) == True))
    MotionOverEstimationState = COASTING
#
@
SlidingEnded，判断是否结束打滑状态的条件之一。
$
At cycle k, if motion overestimation status is SLIDING, ATP shall consider that sliding effect is ended (SlidingEnded) if FilteredWheelAcceleration is strictly less than ATPsetting.SlippingStopAcc and strictly greater than ATPsetting.SlidingStopAcc for more than ATPsetting.SlidingGripRecoveryTime.
%
if (MotionOverEstimationState(k-1) == SLIDING
    and (FilteredWheelAcceleration(k) < ATPsetting.SlippingStopAcc)
    and (FilteredWheelAcceleration(k) > ATPsetting.SlidingStopAcc)
    and (MotionOverEstimationState(k-2) == SLIDING)
    and (FilteredWheelAcceleration(k-1) < ATPsetting.SlippingStopAcc)
    and (FilteredWheelAcceleration(k-1) > ATPsetting.SlidingStopAcc)
    ...
    and (MotionOverEstimationState(k-ATPsetting.SlidingGripRecoveryTime) == SLIDING)
    and (FilteredWheelAcceleration(k-ATPsetting.SlidingGripRecoveryTime+1)
           < ATPsetting.SlippingStopAcc)
    and (FilteredWheelAcceleration(k-ATPsetting.SlidingGripRecoveryTime+1)
           > ATPsetting.SlidingStopAcc))
    SlidingEnded = True
else:
    SlidingEnded = False
#
$
The MotionOverEstimationState transfers from “SLIDING” to “BRAKING” when:
%
if ((MotionOverEstimationState(k-1) == SLIDING)
     and (OdometerState(k) is INITIALIZED)
     and (not MaxMotionOdometerSignChanged(k))
     and (TimeInSliding(k-1) <= ATPsetting.SlidingTimeout)
     and (0 < (|StartSlidingSpeed(k-1)| + TimeInSliding(k-1)* ATPsetting.SlidingStopAcc))
     and ((|StartSlidingSpeed(k-1)| + TimeInSliding(k-1)* ATPsetting.SlidingStopAcc)
           < |WheelMaxSpeed(k)|)
     and (SlidingEnded(k) == True))
    MotionOverEstimationState = BRAKING
#
@
SlidingExcess，测得的加速度在项目配置范围内满足一定时间，是ATP判断过度打滑的必要条件之一。
$
At cycle k, if motion overestimation status is SLIDING, ATP shall consider that sliding is excess (SlidingExcess) if FilteredWheelAcceleration is strictly less than ATPsetting.SlippingStopAcc and strictly greater than ATPsetting.SlidingStopAcc for more than ATPsetting.SlidingExcessTime.
%
if (MotionOverEstimationState(k-1) == SLIDING
    and (FilteredWheelAcceleration(k) < ATPsetting.SlippingStopAcc)
    and (FilteredWheelAcceleration(k) > ATPsetting.SlidingStopAcc)
    and (MotionOverEstimationState(k-2) == SLIDING)
    and (FilteredWheelAcceleration(k-1) < ATPsetting.SlippingStopAcc)
    and (FilteredWheelAcceleration(k-1) > ATPsetting.SlidingStopAcc)
    ...
    and (MotionOverEstimationState(k-ATPsetting.SlidingExcessTime) == SLIDING)
    and (FilteredWheelAcceleration(k-ATPsetting.SlidingExcessTime+1)
           < ATPsetting.SlippingStopAcc)
    and (FilteredWheelAcceleration(k-ATPsetting.SlidingExcessTime+1)
           > ATPsetting.SlidingStopAcc))
    SlidingExcess = True
else:
    SlidingExcess = False
#
$
The MotionOverEstimationState transfers from SLIDING to SKIDDING when:
%
if (MotionOverEstimationState(k-1) is SLIDING
     and OdometerState(k) is INITIALIZED
     and not MaxMotionOdometerSignChanged(k)
     and (TimeInSliding(k-1) > ATPsetting.SlidingTimeout
          or (StartSlidingSpeed(k-1)+ TimeInSliding(k-1) * ATPsetting.SlidingStopAcc) <= 0 
          or (((StartSlidingSpeed(k-1) + TimeInSliding(k-1)* ATPsetting.SlidingStopAcc)
                >= WheelMaxSpeed(k))
               and SlidingExcess(k))))
    MotionOverEstimationState = SKIDDING
#
@
由于当前项目应用的车辆都装有ABS防抱死系统，使得在制动时列车的加速度不会连续若干周期小于ATPsetting.SlidingStopAcc。因此，如果某周期瞬间加速度小于ATPsetting.SlidingStopAcc；并且在之后的测得加速度满足SlidingExcess条件，那么，下列两个条件可以同时成立： 
$
Because the application of anti-lock braking system for the train of current project, makes the brake acceleration cannot continuous less than ATPsetting.SlidingStopAcc for serious cycles. Therefore, if there was an unexpected instantaneous acceleration less than ATPsetting.SlidingStopAcc, and the after cycles' acceleration met the criteria of SlidingExcess, then the following two conditions can hold simultaneously.
%
|StartSlidingSpeed(k-1)| + TimeInSliding(k) * ATPsetting.SlidingStopAcc >= |WheelMaxSpeed(k)|)
AND (SlidingExcess(k) == True)
#
$
The MotionOverEstimationState transfers from SKIDDING to COASTING when: 
%
if (MotionOverEstimationState(k-1) is SKIDDING
     and (WheelFilteredStopped(k)
           or OdometerState(k) is INVALID))
    MotionOverEstimationState = COASTING
#
@
StartBrakingMovementMin，记录由COASTING进入BRAKING，COASTING进入SLIDING，或者BRAKING进入SLIDING状态时的最小位移。
$
ATP records the minimum movement when the state transferring from COASTING to BRAKING or SLIDING, or from BRAKING to SLIDING.
%
def StartBrakingMovementMin(k):
    if (Initialization
        or OdometerState(k-1) is not INITIALIZED
        or (MotionOverEstimationState(k) is COASTING)):
        return 0
    elif ((MotionOverEstimationState(k-1) is COASTING
             and MotionOverEstimationState(k) is BRAKING)
           or (MotionOverEstimationState(k-1) is COASTING
               and MotionOverEstimationState(k) is SLIDING)
           or (MotionOverEstimationState(k-1) is BRAKING
                and MotionOverEstimationState(k) is SLIDING)):
        return MinimumTrainMotion(k-1)
    else:
        return StartBrakingMovementMin(k-1)
#
@
OverestimatedMotionMin，根据打滑状态机，对里程计测得的最小位移进行补偿。在BRAKING或SLIDING状态时，由于车辆ABS的作用，会在瞬间释放制动而使得转速突然增大，可能接近但不会大于进入制动状态时刻的速度。而由于获取里程计读值有1个齿的采样误差，在该误差的作用下，可能会使得测得位移大于进入制动状态时刻的位移，即出现测得车轮最小位移大于列车最大位移的情形。为防止这种情况，需要对列车最小位移进行调整，即始终使用进入制动状态时刻与测得车轮最小位移中绝对值较小的一个。其他情况，无需补偿，使用测得位移。
%
def OverstimatedMotionMin(k):
    if (sign(StartBrakingMovementMin(k)) == sign(WheelMinimumMovement(k))
          and (MotionOverEstimationState (k) is BRAKING
               or MotionOverEstimationState (k) is SLIDING)):
        if (StartBrakingMovementMin(k) >= 0):
            return min(StartBrakingMovementMin(k), WheelMinimumMovement(k))
        else:
            return (-1 * min(abs(StartBrakingMovementMin(k)), abs(WheelMinimumMovement(k))))
    else:
        return WheelMinimumMovement(k)
#
@
OverestimatedMotionMax，根据打滑状态机，对里程计测得的最大位移进行补偿。如果本周期在BRAKING状态，按如下规则更新列车最大位移：如果本周期测得车轮位移与StartBrakingMovementMax方向相同，且前者的绝对值大于后者的绝对值，表明由于采样齿数波动，测得位移大于StartBrakingMovementMax，此时使用测得位移作为最大列车位移；否则，根据配置对测得位移进行补偿，取StartBrakingMovementMax与补偿后的测得位移中绝对值较小的一个，位移方向与StartBrakingMovementMax相同。如果本周期在SLIDING状态时，按如下规则更新列车最大位移：如果本周期测得车轮位移与StartBrakingMovementMax方向相同，且前者的绝对值大于后者的绝对值，表明由于采样齿数波动，使得测得位移大于StartBrakingMovementMax。此时使用测得位移作为最大列车位移；否则，使用StartBrakingMovementMax。其他状态下，无需对测得最大位移进行补偿。
$
In BRAKING state, the maximum train motion overestimated as ATPsetting.SlidingCoefficient (15% normally) at most. If the overestimated motion has greater than the start braking movement, ATP shall use the start breaking movement as the current train motion. That said the train speed during braking could not faster than before. In state SLIDING: If both WheelMaximumMovement and StartBrakingMovementMax are same direction, and the absolute value of the former is greater than the absolute value of the latter, indicating that due to the sampling error makes the measured movement greater than StartBrakingMovementMax. In this case, ATP shall uses WheelMaximumMovement as current train maximum motion.
Otherwise, uses StartBrakingMovementMax as train maximum motion. In other state (COASTING, SKIDDING), uses measured wheel maximum movement as current overestimated maximum train motion.
%
def OverestimatedMotionMax(k):
    if MotionOverEstimationState(k) is BRAKING:
        if (sign(StartBrakingMovementMax(k)) == sign(WheelMaximumMovement(k))
                and abs(WheelMaximumMovement(k)) > abs(StartBrakingMovementMax(k))):
            return WheelMaximumMovement(k) 
        elif (StartBrakingMovementMax(k) >= 0):
            return min(abs(StartBrakingMovementMax(k)),
                       abs(WheelMaximumMovement(k) * ATPsetting.SlidingCoefficient))
        else:
            return -1 * min(abs(StartBrakingMovementMax(k)),
                            abs(WheelMaximumMovement(k) * ATPsetting.SlidingCoefficient))
    elif MotionOverEstimationState(k) is SLIDING:
        if (sign(StartBrakingMovementMax(k)) == sign(WheelMaximumMovement(k))
                and abs(WheelMaximumMovement(k)) > abs(StartBrakingMovementMax(k))):
            return WheelMaximumMovement(k)
        else:
            return StartBrakingMovementMax(k)
    else:  # Coasting and Skidding
        return WheelMaximumMovement(k)
#
@
StartSlippingSpeed，记录由COASTING或MOTORING进入SLIPPING状态时的速度。
$
ATP shall record the speed when the train begins to slip.
%
def StartSlippingSpeed(k):
    if (Initialization
        or OdometerState(k-1) is not INITIALIZED
        or MotionUnderEstimationState(k) is COASTING
        or MotionUnderEstimationState(k) is MOTORING):
        return 0
    elif ((MotionUnderEstimationState(k-1) is COASTING
            or MotionUnderEstimationState(k-1) is MOTORING)
           and MotionUnderEstimationState(k) is SLIPPING):
        return WheelMinSpeed(k-1)
    else:
        return StartSlippingSpeed(k-1)
#
@
TimeInSlipping，记录在SLIPPING状态下持续了多少个周期.
$
ATP shall record how many cycles staying in SLIPPING state.
%
def TimeInSlipping(k):
    if (Initialization
        or (MotionUnderEstimationState(k-1) is SLIPPING
            and MotionUnderEstimationState(k) is not SLIPPING)):
        return 0
    elif (MotionUnderEstimationState(k) is SLIPPING):
        return TimeInSlipping(k-1) + 1
    else:
        return TimeInSlipping(k-1)
#
@
OdometerAxleMotorized，表示需考虑里程计所安在车轴牵引导致的空转。
$
If the project that odometer installed on the traction axle of the train, ATP shall consider the slipping effect to impact the underestimation of measured wheel movement.
%
def OdometerAxleMotorized(k):
    return not ATPsetting.OdoNotOnMotorizedAxle
#
$
The MotionUnderEstimationState transfers from “COASTING” to “MOTORING” when: 
%
if (MotionUnderEstimationState(k-1) is COASTING
    and OdometerAxleMotorized(k)
    and FilteredWheelAcceleration(k) <= ATPsetting.SlippingStartAcc
    and FilteredWheelAcceleration(k) > ATPsetting.TractionStartAcc
    and OdometerState(k) is INITIALIZED)
    MotionUnderEstimationState = MOTORING
#
$
The MotionUnderEstimationState transfers from “COASTING” to “SLIPPING” when: 
%
if (MotionUnderEstimationState(k-1) is COASTING
    and OdometerAxleMotorized(k)
    and FilteredWheelAcceleration(k) > ATPsetting.SlippingStartAcc
    and OdometerState(k) is INITIALIZED)
    MotionUnderEstimationState = SLIPPING
#
$
The MotionUnderEstimationState transfers from “MOTORING” to “SLIPPING” when: 
%
if (MotionUnderEstimationState(k-1) is MOTORING
    and FilteredWheelAcceleration(k) > ATPsetting.SlippingStartAcc
    and AverageWheelAcceleration(k) > ATPsetting.MotoringStartAc)
    and OdometerState(k) is INITIALIZED
    and OdometerAxleMotorized(k))
    MotionUnderEstimationState = SLIDING
#
$
The MotionUnderEstimationState transfers from MOTORING to COASTING” when: 
%
if (MotionUnderEstimationState(k-1) is MOTORING
    and (AverageWheelAcceleration(k) <= ATPsetting.TractionStartAcc
          or OdometerState(k) is INVALID
          or not OdometerAxleMotorized(k)))
    MotionUnderEstimationState = COASTING
#
$
The MotionUnderEstimationState transfers from SLIPPING to COASTING when:
%
if (MotionUnderEstimationState(k-1) is SLIPPING
     and (OdometerState(k) is INVALID
           or not OdometerAxleMotorized(k)))
    MotionUnderEstimationState = COASTING
#
@
SlippingEnded，判断是否结束空转状态的条件之一。
%
def SlippingEnded(k):
  if (MotionUnderEstimationState(k-1) is not SLIPPING):
      slipping_ended_counter = 0
      return False
  elif (FilteredWheelAcceleration(k) < ATPsetting.SlippingStopAcc
        and FilteredWheelAcceleration(k) > ATPsetting.SlidingStopAcc):
      slipping_ended_counter = slipping_ended_counter + 1
      return (slipping_ended_counter >= ATPsetting.SlippingGripRecoveryTime)
#
$
The MotionUnderEstimationState transfers from SLIPPING to MOTORING when:
%
if (MotionUnderEstimationState(k-1) is SLIPPING
     and OdometerState(k) is INITIALIZED
     and OdometerAxleMotorized(k)
     and TimeInSlipping(k-1) <= ATPsetting.SlippingTimeout
     and ((StartSlippingSpeed(k-1) + TimeInSlipping(k-1)* ATPsetting.SlippingStopAcc)
           > WheelMinSpeed(k))
     and SlippingEnded(k))
    MotionUnderEstimationState = MOTORING
#
@
SlippingExcess，测得的加速度在项目配置范围内满足一定时间，是ATP判断过度空转的必要条件之一。
%
def SlippingExcess(k):
  if (MotionUnderEstimationState(k-1) is not SLIPPING):
      slipping_excess_counter = 0
      return False
  elif (FilteredWheelAcceleration(k) < ATPsetting.SlippingStopAcc
        and FilteredWheelAcceleration(k) > ATPsetting.SlidingStopAcc):
      slipping_excess_counter = slipping_excess_counter + 1
      return (slipping_excess_counter >= ATPsetting.SlippingExcessTime)
#
$
The MotionUnderEstimationState transfers from SLIPPING to SKIDDING when:
%
if (MotionUnderEstimationState(k-1) is SLIPPING
     and OdometerState(k) is INITIALIZED
     and OdometerAxleMotorized(k)
     and (TimeInSlipping(k-1) > ATPsetting.SlippingTimeout
          or (((StartSlippingSpeed(k-1) + TimeInSlipping(k-1)* ATPsetting.SlippingStopAcc)
                <= WheelMinSpeed(k))
               and SlippingExcess(k))))
    MotionUnderEstimationState = SKIDDING
#
$
The MotionUnderEstimationState transfers from SKIDDING to COASTING when: 
%
if (MotionUnderEstimationState(k-1) is SKIDDING
     and (WheelFilteredStopped(k)
           or OdometerState(k) is INVALID))
    MotionUnderEstimationState = COASTING
#
@
StartMotoringMovementMin，记录由COASTING进入MOTORING，COASTING进入SLIPPING，或者MOTORING进入SLIPPING状态时的最小位移。
$
ATP records the minimum movement when the state transferring from COASTING to MOTORING or SLIPPING, or from MOTORING to SLIPPING.
%
def StartMotoringMovementMin(k):
    if (Initialization
        or OdometerState(k-1) is not INITIALIZED
        or (MotionUnderEstimationState(k) is COASTING)):
        return 0
    elif ((MotionUnderEstimationState(k-1) is COASTING
             and MotionUnderEstimationState (k) is MOTORING)
           or (MotionUnderEstimationState(k-1) is COASTING
               and MotionUnderEstimationState (k) is SLIPPING)
           or (MotionUnderEstimationState(k-1) is MOTORING
                and MotionUnderEstimationState(k) is SLIPPING)):
        return MinimumTrainMotion(k-1)
    else:
        return StartMotoringMovementMin(k-1)
#
@
UnderestimatedMotionMin，根据空转状态机，对里程计测得的最小位移进行补偿。在MOTORING状态下，使用牵引入口位移和将测得位移低估15%补偿后二者较大的一个，作为补偿后的位移。在SLIPPING状态下，使用牵引入口位移作为补偿后的位移。
%
def UnderestimatedMotionMin(k):
    if MotionUnderEstimationState(k) is MOTORING:
        if (WheelMinimumMovement(k) >= 0):
            return max(abs(StartMotoringMovementMin(k)),
                       abs(WheelMinimumMovement(k) * ATPsetting.SlippingCoefficient))
        else:
            return -1 * max(abs(StartMotoringMovementMin(k)),
                            abs(WheelMinimumMovement(k) * ATPsetting.SlippingCoefficient))
    elif MotionUnderEstimationState(k) is SLIPPING:
        return StartMotoringMovementMin(k)
    else:
        return WheelMinimumMovement(k)
#
@
UnderestimatedMotionMax，根据空转状态机，对里程计测得的最大位移进行补偿。
%
def UnderestimatedMotionMax(k):
    return WheelMaximumMovement(k)
#
@
SlipSlideDetected，是否检测到打滑空转
$
For calibration validation purpose, ATP shall consider that slip/side detected if:
motion overestimation modeling status is not coasting nor braking,or motion underestimation modeling status is not coasting nor motoring.
%
SlipSlideDetected(k)
 = ((MotionOverEstimationState(k) !=  COASTING
      and MotionOverEstimationState(k) !=  BRAKING)
   or (MotionUnderEstimationState(k) !=  COASTING
        and MotionUnderEstimationState(k) !=  MOTORING))
#
@
SlipSlideModellingFault，打滑补偿模型错误
$
When the overestimation or underesimation state is SKIDDING, or the motion signed changed in BRAKING or SLIDING state, ATP shall consider the overestimation model as fault.
%
def SlipSlideModellingFault(k):
    if (MotionOverEstimationState(k) is SKIDDING
         or MotionUnderEstimationState(k) is SKIDDING
         or ((MotionOverEstimationState(k-1) is BRAKING
               or MotionOverEstimationState(k-1) is SLIDING)
              and MaxMotionOdometerSignChanged(k)))):
        return True
    elif (MotionOverEstimationState(k-1) is COASTING
           and MotionUnderEstimationState(k-1) is COASTING)
        return False
    else:
        return SlipSlideModellingFault(k-1)
#
@
ValidSlipSlideModelling，打滑补偿模型有效
$
If overestimation model was fault, then ATP considers the model invalid. 
%
def ValidSlipSlideModelling(k):
    if (ValidSlipSlideModelling(k-1))
        return not SlipSlideModellingFault(k)
    elif ((MotionOverEstimationState(k) is COASTING)
            and MotionUnderEstimationState(k) is COASTING
            and WheelFilteredStopped(k))
        return True
    else:
        return ValidSlipSlideModelling(k-1)
#
@
MaximumSScompensatedMotion，经过打滑空转补偿后的最大位移
%
def MaximumSScompensatedMotion(k):
    if ValidSlipSlideModelling(k):
        return (sign(OverestimatedMotionMax(k))
                 * max(abs(OverestimatedMotionMax(k)), abs(UnderestimatedMotionMax(k)))
    else:
        return WheelMaximumMovement(k)
#
@
MinimumSScompensatedMotion，经过打滑空转补偿后的最小位移
%
def MinimumSScompensatedMotion(k):
    if ValidSlipSlideModelling(k):
        return (sign(OverestimatedMotionMin(k))
                 * min(abs(OverestimatedMotionMin(k)), abs(UnderestimatedMotionMin(k)))
    else:
        return WheelMinimumMovement(k)
#
@
RadarRawSpeed，直接获取的雷达测速值，该值始终为正。
%
def RadarRawSpeed(k):
    if RadarInfo(k).DrsValid:
        return RadarInfo(k).DrsSpeed
    else:
        return MAX_RADAR_SPEED
#
@
RadarDirection，雷达测得方向，向End1方向为+1，向End2为-1，其余为0
%
def RadarDirection(k):
    if not RadarInfo(k).DrsValid:
        return 0
    elif ((CoreId(k) is END_1
           and RadarInfo(k).DrsDirection > 0)
         or (CoreId(k) is END_2
             and RadarInfo(k).DrsDirection <= 0)):
        return 1
    else:
        return -1
#
@
RadarMotionMax，绝对值向上过估的雷达最大位移，向END1方向该值为正，向END2方向该值为负。
%
def RadarMotionMax(k):
    if not RadarInfo(k).DrsValid:
        return 0
    elif RadarRawSpeed(k) >= ATPsetting.RadarSpeedThreshold:
        return (ATP_CYCLE_TIME * RadarDirection(k) * (RadarRawSpeed(k)
                + RadarRawSpeed(k) * ATPsetting.RadarDeviationAboveThreshold / 1000))
    else:
        return (ATP_CYCLE_TIME * RadarDirection(k)
                 * (RadarRawSpeed(k) + ATPsetting.RadarDeviationBelowThreshold))
#
@
RadarMotionMin，绝对值向下过估的雷达最小位移，向END1方向该值为正，向END2方向该值为负。
%
def RadarMotionMin(k):
    if not RadarInfo(k).DrsValid:
        return 0
    elif RadarRawSpeed(k) >= ATPsetting.RadarSpeedThreshold:
        return (ATP_CYCLE_TIME * RadarDirection(k) * (RadarRawSpeed(k)
                - RadarRawSpeed(k) * ATPsetting.RadarDeviationAboveThreshold / 1000))
    else:
        return (ATP_CYCLE_TIME * RadarDirection(k)
                 * max(0, RadarRawSpeed(k) - ATPsetting.RadarDeviationBelowThreshold))
#
@
RadarSpeedValid，判断雷达速度是否可用
%
def RadarSpeedValid(k):
    return (ATPsetting.RadarApplied
            and  RadarInfo(k).DrsValid
            and (not ValidSlipSlideModelling(k)
                 or (RadarDirection(k) * MaximumSScompensatedMotion(k) >= 0
                     and abs(RadarMotionMin(k)) <= abs(MaximumSScompensatedMotion(k))
                     and abs(RadarMotionMax(k)) >= abs(MinimumSScompensatedMotion(k)))))
#
@
OdometerSpeedAvailable，当前里程计测速是否可用于参考速度判断
%
OdometerSpeedAvailable(k):
    return (ValidWheelKinematic(k)
            and OdometerState(k) is INITIALIZED)
#
@
OdometerSpeedUnderThreshold，本端里程计测速低于阈值。
$
ATP shall detect whether the measured wheel speed is under threshold.
%
def OdometerSpeedUnderThreshold(k):
    return (WheelMinSpeed(k) < ATPsetting.OdoLockedAxleThresholdSpeed)
#
@
ReferenceSpeedUnderThreshold_1，来自CCNV的参考速度1是否小于指定阈值。
$
ReferenceSpeedUnderThreshold_1 defines whether the referenced speed 1 from CCNV is lower than a configurable threshold.
%
def ReferenceSpeedUnderThreshold_1(k):
    if RadarSpeedValid(k):
        return (RadarRawSpeed(k) < ATPsetting.OdoLockedAxleThresholdSpeed)
    else:
        return (ATOcontrolTimeValid(k)
                and NonVitalRequest.OdometerRef1SpeedUnderThreshold(k))
#
@
ReferenceSpeedAvailable_1，来自CCNV的参考速度1是否可用
$
ReferenceSpeedAvailable_1 defines whether the referenced speed 1 from CCNV is valid or not. 
%
def ReferenceSpeedAvailable_1(k):
    return (RadarSpeedValid(k)
            or (ATOcontrolTimeValid(k)
                and NonVitalRequest.OdometerRef1Available(k)))
#
@
ReferenceSpeedUnderThreshold_2，来自CCNV的参考速度2是否小于指定阈值。
$
ReferenceSpeedUnderThreshold_2 defines whether the referenced speed 2 from CCNV is lower than a configurable threshold. 
%
if (ATOcontrolTimeValid(k) == True)
    ReferenceSpeedUnderThreshold_2(k) = NonVitalRequest.OdometerRef2SpeedUnderThreshold(k)
else:
    ReferenceSpeedUnderThreshold_2 = False
#
@
ReferenceSpeedAvailable_2，来自CCNV的参考速度2是否可用
$
ReferenceSpeedAvailable_2 shows whether the referenced speed 2 from CCNV is effective or not. 
%
if (ATOcontrolTimeValid(k) == True)
    ReferenceSpeedAvailable_2(k) = NonVitalRequest.OdometerRef2Available(k)
else:
    ReferenceSpeedAvailable_2 = False
#
@
OdometerRef_1.PossiblyDisabled，当本端里程计可用且不为0速，而参考速度1可用但为0速时，则认为参考速度1可能错误
$
The independent source of odometry reference 1 said to disable if following conditions reached: local source of odometry is available (ValidWheelKinematic),and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,and source of odometry reference 1 is available,and odometer reference 1 indicates that train speed is less than reference speed threshold.
%
OdometerRef_1. PossiblyDisabled(k)
   = (ReferenceSpeedAvailable_1(k)
      and ReferenceSpeedUnderThreshold_1(k)
      and OdometerSpeedAvailable(k)
      and not OdometerSpeedUnderThreshold(k))
#
@
OdometerRef_2. PossiblyDisabled，当本端里程计可用且不为0速，而参考速度2可用但为0速时，则认为参考速度2可能错误
$
The independent source of odometry reference 2 said to disable if following conditions reached:local source of odometry is available (ValidWheelKinematic),and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,and source of odometry reference 2 is available,and odometer reference 2 indicates that train speed is less than reference speed threshold.
%
OdometerRef_2. PossiblyDisabled(k)
   = (ReferenceSpeedAvailable_2(k)
      and ReferenceSpeedUnderThreshold_2(k)
      and OdometerSpeedAvailable(k)
      and not OdometerSpeedUnderThreshold(k))
#
@
OdometerRef_1.PossiblyEnabled，当本端里程计和参考速度1均可用且测得列车在动时，认为参考速度1可能已恢复有效。
$
The independent source of odometry reference 1 said to enable if following conditions reached:local source of odometry is available,and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,and source of odometry reference 1 is available,
and odometer reference 1 indicates that train speed is greater than reference speed threshold.
%
OdometerRef_1. PossiblyEnabled(k)
  = (ReferenceSpeedAvailable_1(k)
      and not ReferenceSpeedUnderThreshold_1(k)
      and OdometerSpeedAvailable(k)
      and not OdometerSpeedUnderThreshold(k))
#
@
OdometerRef_2.PossiblyEnabled，当本端里程计和参考速度2均可用且测得列车在动时，认为参考速度2可能已恢复有效。
$
The independent source of odometry reference 2 said to enable if following conditions reached:local source of odometry is available,and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,and source of odometry reference 2 is available,
and odometer reference 2 indicates that train speed is greater than reference speed threshold.
%
OdometerRef_2. PossiblyEnabled(k)
  = (ReferenceSpeedAvailable_2(k)
     and not ReferenceSpeedUnderThreshold_2(k)
     and OdometerSpeedAvailable(k)
     and not OdometerSpeedUnderThreshold(k))
#
@
OdometerRef_1.OutOfOrder，当判断参考速度1可能不可用时，延迟一段时间，若仍不可用，则判断参考速度1失效。当判断参考速度1可能可用时，延迟一段时间，若仍可用，则判断参考速度1有效
$
The independent source of odometry reference 1 is said to be out of order if it is possibly disabled during more than ATPsetting.OdoLockedAxleDisablingLatency. When the independent source of odometry reference 1 had out of order, it considered not out of order one if the source of odometry reference 1 is possibly enabled during more than ATPsetting.OdoLockedAxleEnablingLatency:
%
if (OdometerRef_1.PossiblyDisabled(k) == True
    and OdometerRef_1.PossiblyDisabled(k-1) == True
    ...
    and OdometerRef_1.PossiblyDisabled(k+1-ATPsetting.OdoLockedAxleDisablingLatency) == True)
OdometerRef_1.OutOfOrder  = True
if (OdometerRef_1.PossiblyEnabled(k) == True
    and OdometerRef_1.PossiblyEnabled(k-1) == True
    ...
    and OdometerRef_1.PossiblyEnabled(k+1-ATPsetting.OdoLockedAxleEnablingLatency) == True)
    OdometerRef_1.OutOfOrder = False
#
@
OdometerRef_2.OutOfOrder，当判断参考速度2可能不可用时，延迟一段时间，若仍不可用，则判断参考速度2失效。当判断参考速度2可能可用时，延迟一段时间，若仍可用，则判断参考速度2有效。
$
The independent source of odometry reference 2 is said to be out of order if it is possibly disabled during more than ATPsetting.OdoLockedAxleDisablingLatency. When the independent source of odometry reference 2 had out of order, It considered not out of order one if the source of odometry reference 2 is possibly enabled during more than ATPsetting.OdoLockedAxleEnablingLatency:
%
if (OdometerRef_2.PossiblyDisabled(k) == True
     and OdometerRef_2.PossiblyDisabled(k-1) == True
     ...
     and OdometerRef_2.PossiblyDisabled(k+1-ATPsetting.OdoLockedAxleDisablingLatency) == True)
OdometerRef_2.OutOfOrder = True
if (OdometerRef_2.PossiblyEnabled(k) == True
    and OdometerRef_2.PossiblyEnabled(k-1) == True
    ...
    and OdometerRef_2.PossiblyEnabled(k+1-ATPsetting.OdoLockedAxleEnablingLatency) == True)
   OdometerRef_2.OutOfOrder = False
#
@
OdometerRef_1.Contradictory，若参考速度1有效且判断车动，而本端里程计判断车静止，则认为参考速度1判断出里程计可能故障。
$
The source of odometry reference 1 said to be contradictory with local source of odometry if:local source of odometry is available (ValidWheelKinematic)
and OdometerSpeedUnderThreshold indicates that wheel speed is less than reference speed threshold,and source of odometry reference 1 is available and not out of order,and odometer reference 1 indicates that train speed is greater than reference speed threshold.
%
OdometerRef_1. Contradictory(k)
 = (not OdometerRef_1.OutOfOrder(k)
     and ReferenceSpeedAvailable_1(k)
     and not ReferenceSpeedUnderThreshold_1(k)
     and ValidWheelKinematic(k)
     and OdometerSpeedUnderThreshold(k))
#
@
OdometerRef_2. Contradictory，若参考速度2有效且判断车动，而本端里程计判断车静止，则认为参考速度2判断出里程计可能故障。
$
The source of odometry reference 2 said to be contradictory with local source of odometry if:local source of odometry is available (ValidWheelKinematic)
and OdometerSpeedUnderThreshold indicates that wheel speed is less than reference speed threshold,and source of odometry reference 2 is available and not out of order,and odometer reference 2 indicates that train speed is greater than reference speed threshold.
%
OdometerRef_2.Contradictory (k)
 = (not OdometerRef_2.OutOfOrder(k)
     and ReferenceSpeedAvailable_2(k)
     and not ReferenceSpeedUnderThreshold_2(k)
     and ValidWheelKinematic(k)
     and OdometerSpeedUnderThreshold(k))
#
@
AxlePossiblyLocked，在两路参考速度都正常（没有失效out of order）的情况下，当两路参考速度均判断本端里程计可能故障的情况下，认为当前可能轴锁。或者，当有一路参考速度认为轴锁，而另一路参考速度失效或不可用，也认为当前可能轴锁。
$
Odometer axle shall consider possibly locked if:Both independent sources of odometry indicates a contradiction with local odometer,Or one source of odometry is contradictory and the other one is out of order (or not available).
%
AxlePossiblyLocked(k)
 = ((OdometerRef_1.Contradictory(k) and OdometerRef_2.Contradictory(k))
    or (OdometerRef_1.Contradictory(k)
         and (OdometerRef_2.OutOfOrder(k) or  not ReferenceSpeedAvailable_2(k)))
    or (OdometerRef_2.Contradictory(k)
         and (OdometerRef_1.OutOfOrder(k) or not ReferenceSpeedAvailable_1(k))))
#
@
UnrecoverableAxleLocked，当连续若干个周期判断可能轴锁，或者已经判断为轴锁，则永久轴锁.
$
If AxlePossiblyLocked situation lasts more than ATPsetting.OdoLockedAxleTimeout, the odometer axle shall be considered locked. Once UnrecoverableAxleLocked set to True, it will stay at state True unless ATP re-initialized.
%
UnrecoverableAxleLocked(k)
 = UnrecoverableAxleLocked(k-1)
   or (AxlePossiblyLocked(k)
        and AxlePossiblyLocked(k-1)
        and ...
        and AxlePossiblyLocked(k+1-ATPsetting.OdoLockedAxleTimeout)
#
@
AxleLockedDetectionAvailable，只要有一路参考速度可以工作，就认为轴锁侦测可用。
$
If only one or no source of odometry is available, then ATP shall invalidate kinematic while this situation lasting.
%
AxleLockedDetectionAvailable
  = ((not OdometerRef_1.OutOfOrder and ReferenceSpeedAvailable_1(k))
    or (not OdometerRef_2.OutOfOrder and ReferenceSpeedAvailable_2(k)))
#
@
WheelTrainKinematicCorrelation，车轮和列车的速度一致性
$
Wheel and train kinematic shall consider correctly correlated if and only if:
odometer axle is not detected locked,and odometer axle detection is available
%
WheelTrainKinematicCorrelation(k)
 = AxleLockedDetectionAvailable(k) and not UnrecoverableAxleLocked(k)
#
@
ValidTrainKinematic，列车位移速度计算有效的条件
$
Train kinematic information shall declare invalid if at least one of following condition is True:odometer kinematic is not valid,or neither radar speed nor over-estimation modeling of train movement is valid,or train movement and wheel movement has been detected de-correlated.
%
def ValidTrainKinematic(k):
    return ((ValidSlipSlideModelling(k)
              or RadarSpeedValid(k))
            and WheelTrainKinematicCorrelation(k)
            and ValidWheelKinematic(k))
#
@
MaximumTrainMotion，根据来自里程计或雷达的信息，计算列车的周期最大位移。该值为矢量，向END_1方向为正，END_2方向为负。
%
def MaximumTrainMotion(k):
    if (not RadarSpeedValid(k)):
        return MaximumSScompensatedMotion(k)
    elif (not ValidSlipSlideModelling(k)):
        return RadarMotionMax(k)
    else:
        return (min(abs(MaximumSScompensatedMotion(k)), abs(RadarSpeedMax(k)))
                * sign(MaximumSScompensatedMotion(k)))
#
@
MinimumTrainMotion，根据来自里程计或雷达的信息，计算列车的周期最小位移。该值为矢量，向END_1方向为正，END_2方向为负。
%
def MinimumTrainMotion(k):
    if (not RadarSpeedValid(k)):
        return MinimumSScompensatedMotion(k)
    elif (not ValidSlipSlideModelling(k)):
        return RadarMotionMin(k)
    else:
        return (max(abs(MinimumSScompensatedMotion(k)), abs(RadarSpeedMin(k)))
                * sign(MinimumSScompensatedMotion(k)))
#
$
TrainStopped, train shall consider strictly stopped if and only if:wheel is detected strictly stopped,and train kinematic elaboration is valid,and wheel is not detected sliding.
%
TrainStopped(k)
 = ((WheelStopped(k) == True)
    and ((MotionOverEstimationState == COASTING)
           or (MotionOverEstimationState == BRAKING))
    and (ValidTrainKinematic(k) == True))
#
@
TrainFilteredStopped，列车准静止判断。
$
Train shall consider stopped with the tolerance of one cog detection if:wheel is detected at filtered stop,and train kinematic elaboration is valid,and wheel is not detected sliding.
%
TrainFilteredStopped(k)
 = ((WheelFilteredStopped(k) == True)
    and ((MotionOverEstimationState == COASTING)
          or (MotionOverEstimationState == BRAKING))
    and (ValidTrainKinematic(k) == True))
#
@
TrainHasMoved，表明自上电以后，列车是否移动过。
%
def TrainHasMoved(k):
    if (Initialization):
        return False
    elif (not TrainHasMoved(k-1)
          and not TrainFilteredStopped(k)
          and (TeethCounter(k) != TeethCounter(k-1))):
        return True
    else:
        return TrainHasMoved(k-1)
#
@
TrainMinSpeed，计算列车最小速度。
%
def TrainMinSpeed(k):
    if (OdometerSpeedAvailable(k)):
        return max(0, (round.floor(abs(MinimumTrainMotion(k) / ATP_CYCLE_TIME))
                       + ((ATPsetting.BrakingMinAcc - ATPsetting.MaxGradientAcc)
                           * ATP_CYCLE_TIME / 2)))
    else:
        return 0
#
@
TrainMaxSpeed，考虑打滑过估补偿的列车最大速度，该速度为非负值。
$
According to the matching of odometer cog counter and code, maximum train speed shall computed using the followings expressions:
%
def TrainMaxSpeed(k):
    if (OdometerSpeedAvailable(k)):
        return (round.ceil(abs(MaximumTrainMotion(k) / ATP_CYCLE_TIME))
                + ((ATPsetting.TractionMaxAcc[TrainMinSpeed(k)] + ATPsetting.MaxGradientAcc)
                   * ATP_CYCLE_TIME / 2))
    else:
        return round.ceil(abs(MaximumTrainMotion(k)) / ATP_CYCLE_TIME)
#
@
NewBeaconObtained，表明收到了可用的RB
%
def NewBeaconObtained(k):
    if (BeaconMessageReceive(k)
        and ValidTrainKinematic(k)
        and not TrainFilteredStopped(k)
        and OdometerState(k) is INITIALIZED):
        NewBeaconObtained = True
    else:
        NewBeaconObtained = False
#
@
BeaconBeforeLastObtained，记录读到的次新的信标
%
def BeaconBeforeLastObtained(k):
    if (Initialization):
        BeaconBeforeLastObtained = None
    elif (NewBeaconObtained(k)):
        BeaconBeforeLastObtained = BeaconLastObtained(k-1)
    else:
        BeaconBeforeLastObtained = BeaconBeforeLastObtained(k-1)
    return BeaconBeforeLastObtained
#
@
BeaconLastObtained，记录读到的最新的信标
%
def BeaconLastObtained(k):
    if (Initialization):
        BeaconLastObtained = None
    elif (NewBeaconObtained(k)):
        BeaconLastObtained = TrackMap.Beacons[LockedBeaconMsgByte.Id]
    else:
        BeaconLastObtained = BeaconLastObtained(k-1)
    return BeaconLastObtained
#
@
在本周期的里程计和测速信息有效的情况下，需要根据当前齿数和锁存的读到信标时的Top-loc信息，计算DistLastBeaconMax和DistLastBeaconMin，表示当前经过信标后已运行的最大最小距离。
$
If a valid beacon with top-loc received between cycle k-1 and k, then minimum and maximum distance ran since top-loc shall evaluate as the difference between current teeth counter and recorded cog position just before or after top-loc. If there is no beacon received, ATP updates distances from last beacon using the train movements.
%
if (NewBeaconObtained(k)):
    DistLastBeaconMin(k)= MinCogCalibration(k) * (TeethCounter(k)- CogPositionAfterTopLoc(k))
    DistLastBeaconMax(k)= MaxCogCalibration(k) * (TeethCounter(k)- CogPositionBeforeTopLoc(k))
else:
    DistLastBeaconMin = DistLastBeaconMin(k-1) + MinimumTrainMotion(k)
    DistLastBeaconMax = DistLastBeaconMax(k-1) + MaximumTrainMotion(k)
#
@
End2RunningForward，根据车轮旋转方向，判断列车是否向END_2方向运行
%
def End2RunningForward(k):
    if (OdometerState(k) is INITIALIZED):
        return (MaximumTrainMotion(k) < 0)
    else:
        return True
#
@
End1RunningForward，根据车轮旋转方向，判断列车是否向END_1方向运行
%
def End1RunningForward(k):
    if (OdometerState(k) is INITIALIZED):
        return (MaximumTrainMotion(k) > 0)
    else:
        return True
#
@
在CALI_WATING状态下使用默认齿距值
$
From power-up and while calibration process is not successfully performed, ATP shall use default calibration to compute train motion and shall consider itself in the state of waiting for the first beacon belonging to a couple of calibration.
%
if (Initialization)
    CalibrationState =  CALI_WAITING
    MinCogCalibration = ATPsetting.OdoCaliDefaultCogLengthMin
    MaxCogCalibration = ATPsetting.OdoCaliDefaultCogLengthMax
#
@
当读到线路地图中的MTIB1时，齿距校准状态从CALI_WAITING转入CALI_MEASURING。
$
If ATP is in the state of CALI_WAITING, can transform to the measuring state if following conditions fulfilled:a valid beacon has been received and this beacon belongs to a couple of calibration,and train kinematic was valid,and no excessive slip/slide effect was detected,and WheelMinimumMovement is not null,Then, ATP shall memorize:position of the wheel before and after top location signal of received beacon,the ID of received beacon,the sign of the movement when crossing beacon,and shall consider itself as CALI_MEASURING.
%
if ((CalibrationState(k-1) =  CALI_WAITING)
    and (NewBeaconObtained(k) == True)
    and (TrackMap.BeaconBelongsToCalibrationCouple(BeaconMessage.Id(k)) == True)
    and (SlipSlideDetected(k) == False))
    CalibrationMeasurementStartPositionMin = CogPositionBeforeTopLoc(k)
    CalibrationMeasurementStartPositionMax = CogPositionAfterTopLoc(k)
    CalibrationMeasurementStartBeacon = BeaconMessage.Id(k)
    CalibrationEnd1RunningForward = End1RunningForward(k)
    CalibrationState = CALI_MEASURING
#
@
当读到线路地图中与之前MTIB1匹配的MTIB2时，根据经过的齿数值，在ATPsetting中查表得到最大最小齿距，并比较测得的齿距结果：如果测得的最大最小齿距在理论值范围内，则齿距校准状态从CALI_MEASURING到CALI_VALIDATING；如果在理论范围外，则状态从CALI_MEASURING转入CALI_WAITING。其中最大最小测得齿距是根据校准过程中测得齿数，在离线工具计算的齿数-齿距对照表中查到的。其中CaliMinRatio和CaliMaxRatio是离线工具计算的该校准信标所对应的MTIB结构的相关属性，表示该对MTIB的间距与标准间距（21米）的比率，该结构定义见[REF11]。
$
If ATP is in the state of CALI_MEASURING and following conditions fulfilled: a valid beacon has been received and the beacon and first memorized calibration beacon is one of possible dedicated couple of calibration,and train kinematic was valid,and no excessive slip/slide effect was detected,and sign of train motion is still identical to thus detected on first beacon signaling,
Then,if resulting calibration range is included in default calibration range, then ATP shall: memorize: position of the wheel before and after top location signal of received beacon, the id of received beacon,and shall consider itself as CALI_VALIDATING. else: ATP shall consider that calibration process has failed and back to CALI_WAITING. Among them, the measured maximum and minimum calibration fetches from the offline-generated counter-calibration table, based on the calculated cog counter. The CaliMinRation and CaliMaxRation are elements of structure MTIB generated by offline tool for each couple of calibration beacons. Refer to [REF11] for the definition of MTIB.
%
if ((CalibrationState(k-1) == CALI_MEASURING)
     and (NewBeaconObtained(k) == True)
     and (TrackMap.AreNeighbouredBeacons(BeaconMessage.Id(k),
                                                CalibrationMeasurementStartBeacon(k)) == True)
     and (SlipSlideDetected(k) == False)
     and (CalibrationEnd1RunningForward(k-1) == End1RunningForward(k)))
    if ((ATPsetting.OdoCaliDefaultCogLengthMax >= MaxCogCalibrationMeasured)
        and (ATPsetting.OdoCaliDefaultCogLengthMin <= MinCogCalibrationMeasured))
         CalibrationValidationStartPositionMin = CogPositionBeforeTopLoc(k)
         CalibrationValidationStartPositionMax = CogPositionAfterTopLoc(k)
         CalibrationValidationStartBeacon = BeaconMessage.Id(k))
         CalibrationResultMin = MinCogCalibrationMeasured
         CalibrationResultMax = MaxCogCalibrationMeasured
         CalibrationState =  CALI_VALIDATING
    else:
         CalibrationState = CALI_WAITING
MinCogCalibrationMeasured
 = CaliMinRatio * ATPsetting.MeterCaliMaxMinCalibration[1]
[|CalibrationMeasurementStartPositionMin(k)-CogPositionAfterTopLoc(k)|
 - ATPsetting.OdoCaliCogCounterMin]
MaxCogCalibrationMeasured
 = CaliMaxRatio * ATPsetting.MeterCaliMaxMinCalibration[0]
[|CalibrationMeasurementStartPositionMax(k)-CogPositionBeforeTopLoc(k)|
 - ATPsetting.OdoCaliCogCounterMin]

#
@
如果校准过程中发生下列情况，则从CALI_MEASURING回到CALI_WAITING
$
If ATP is in the state of CALI_MEASURING and following conditions fulfilled:
train kinematic has been detected not valid,or excessive slip/slide effect has been detected,or WheelMinimumMovement sign is in the opposite direction of thus observed on first beacon or becomes null,or an unexpected beacon has been received. That is, a beacon not belonging calibration measurement couple.Then, ATP shall abort calibration process and back to CALI_WAITING.
%
if ((CalibrationState(k-1) =  CALI_MEASURING)
     and ((ValidTrainKinematic(k) == False)
          or (OdometerState(k) is INVALID)
          or (SlipSlideDetected(k) == True)
          or (CalibrationEnd1RunningForward(k-1) != End1RunningForward(k))
          or (TrainFilteredStopped(k) == True)
          or ((NewBeaconObtained(k) == True)
              and TrackMap.BeaconBelongsToCalibrationCouple(BeaconMessage.Id(k)) == False)))
    CalibrationState = CALI_WAITING
#
@
当发生以下情况时，认为校准失败，从CALI_VALIDATING回到CALI_WAITING
$
If ATP is in the state of calibration validation in progress and following conditions fulfilled:train kinematic has been detected not valid,or excessive slip/slide effect has been detected,or WheelMinimumMovement sign is in the opposite direction of thus observed on first beacon or becomes null,or an unexpected beacon has been received. That is, a beacon not belonging calibration validation couple.In such case, then ATP shall consider that calibration process as not sable and so back to CALI_WAITING.
%
if ((CalibrationState(k-1) =  CALI_VALIDATING)
     and ((ValidTrainKinematic(k) == False)
           or (OdometerState(k) is INVALID)
           or (SlipSlideDetected(k) == True)
           or ((CalibrationEnd1RunningForward(k-1) != End1RunningForward(k))
           or (TrainFilteredStopped(k) == True)
           or ((NewBeaconObtained(k) == True)
               and (TrackMap.IsCalibrationValidationBeacon(BeaconMessage.Id(k),
                                                      CalibrationValidationStartBeacon(k)) == False))))
    CalibrationState = CALI_WAITING
#
@
当读到有效的验证信标，并判断之前测得齿距在有效范围内时，认为校准成功，转入CALI_COMPLETED状态；否则，校准失败，返回CALI_WATING状态。
$
If ATP is in the state of calibration validation in progress and following conditions fulfilled: a valid beacon has been received and this beacon is one of possible confirmation beacons related to second beacon signaled of possible confirmation beacons related to second beacon signaled of calibration measurement,and train kinematic was valid,and no excessive slip/slide effect was detected,and sign of train motion is still identical to thus detected on first beacon signaling,and WheelMinimumMovement is not null. Then,if resulting calibration range fully includes the calibration range in track map, then ATP shall: update ATP minimum and maximum calibration with last calibration computed on beacons,and shall consider that calibration process is CALI_COMPLETED.else: ATP shall consider that calibration process is not usable and so back to CALI_WATING waiting for new measurement calibration beacons.
%
if (CalibrationState(k-1) =  CALI_VALIDATING)
    and (NewBeaconObtained(k) == True)
    and (TrackMap.IsCalibrationValidationBeacon(BeaconMessage.Id(k),
                                                        CalibrationValidationStartBeacon(k)))
    and (SlipSlideDetected(k) == False)
    and (CalibrationEnd1RunningForward(k-1) == End1RunningForward(k)))
    if ((TrackMap.CalibrationCoupleMaxDistance(BeaconMessage.Id(k),
                              CalibrationValidationStartBeacon(k)) <= MaxDistanceRanForValidation)
        and TrackMap.CalibrationCoupleMinDistance(BeaconMessage.Id(k),
                             CalibrationValidationStartBeacon(k)) >= MinDistanceRanForValidation)
         MinCogCalibration = CalibrationResultMin(k)
         MaxCogCalibration = CalibrationResultMax(k)
         CalibrationState = CALI_COMPLETED
    else:
         CalibrationState = CALI_WAITING
MaxDistanceRanForValidation
 =(abs(CalibrationValidationStartPositionMin(k)― CogPositionAfterTopLoc(k)) + 1)
   * CalibrationResultMax(k)
MinDistanceRanForValidation
 =(abs(CalibrationValidationStartPositionMax(k)― CogPositionBeforeTopLoc(k)) - 1)
   * CalibrationResultMin(k)
#
@
End2OrientationByBeacon，当定位初始化时，通过经过的信标，判断END_2驾驶室所面对的运营方向。
$
The orientation of the train END means the UP or DOWN orientation which this END toward to. When a pair of consecutive beacon read, ATP can determine the orientation for each train END according to the direction of these beacons in track map and the direction of train movement.
%
def End2OrientationByBeacon(k):
    if (Initialization
        or not MovingInitialByBeacon(k)):
        return DOT_UNKNOWN
    elif (ATPsetting.PolarizedTrain):
        return ATPsetting.End2Orientation
    elif (NewBeaconObtained(k)
          and TrackMap.AreNeighbouredBeacons(BeaconBeforeLastObtained(k),
                                                    BeaconLastObtained(k))):
        if (End2RunningForward(k)):
            return (TrackMap.OrientationOfNeighbouredBeacons(BeaconBeforeLastObtained(k),
                                                                       BeaconLastObtained(k)))
        else:
            return (TrackMap.OrientationOfNeighbouredBeacons(BeaconLastObtained(k),
                                                                       BeaconBeforeLastObtained(k)))
    else:
        return End2OrientationByBeacon(k-1)
#
@
BeaconLocation，如果本周期读到了重定位信标（无论是否已经在定位状态），则ATP需根据该信标在线路地图中的坐标计算读到信标时刻END_2车头的位置：
$
If a valid beacon read, ATP shall calculate actual maximum and minimum location of the END_2 according to the beacon location in track map, the distance from beacon antenna to the END_2, the distance after top-loc, the orientation of END_2 and the direction of train movement. The beacon location indicate the actual external location of the END_2.
%
def BeaconLocation(k):
    if (NewBeaconObtained(k)):
        if (End2OrientationByBeacon(k) is not None):
            BeaconLocation.Ext2 = (TrackMap.LocationUpdateExt2
                                       (End2RunningForward(k),
                                        End2OrientationByBeacon(k),
                                        BeaconLastObtained.Location(k),
                                        MaxMotionOfEnd2(k),
                                        MinMotionOfEnd2(k)))
        elif (TrainLocalized(k-1)):
            BeaconLocation.Ext2 = (TrackMap.LocationUpdateExt2
                                       (End2RunningForward(k),
                                        TrainLocation(k-1).Ext2.Ort,
                                        BeaconLastObtained.Location(k),
                                        MaxMotionOfEnd2(k),
                                        MinMotionOfEnd2(k)))
        else:
            BeaconLocation.Ext2 = None
            
        BeaconLocation.Uncertainty = (2 * BeaconLastObtained(k).PositionTolerance
                                            + abs(DistLastBeaconMax(k) - DistLastBeaconMin(k))) 
        BeaconLocation.Int2 = UpdateInt2FromExt2
        BeaconLocation.Ext1 = UpdateExt1FromExt2
        BeaconLocation.Int1 = UpdateInt1FromExt2
    else:
        BeaconLocation = None
    return BeaconLocation
def MaxMotionOfEnd2(k)
    return (DistLastBeaconMax(k)
            - ATPsetting.CCcoreEnd2BeaconAntennaDistance[CoreId(k)]
            - BeaconLastObtained(k).PositionTolerance)
def MinMotionOfEnd2(k)
    return (DistLastBeaconMin(k)
            - ATPsetting.CCcoreEnd2BeaconAntennaDistance[CoreId(k)]
            - BeaconLastObtained(k).PositionTolerance)
#
@
MovingInitialByBeacon，是否在信标初始化定位过程中。
%
def MovingInitialByBeacon(k):
    if (Initialization
        or TrainLocalized(k-1)
        or TrainFilteredStopped(k)
        or (End1RunningForward(k) and not End1RunningForward(k-1))
        or (End2RunningForward(k) and not End2RunningForward(k-1))
        or abs(DistLastBeaconMax(k)) >= ATPsetting.BeaconPairMaxDistance):
        return False
    elif (NewBeaconObtained(k)):
        return True
    else:
        return MovingInitialByBeacon(k-1)
#
@
TrainLocatedOnBeacon，列车通过信标进行初始化定位（该值仅在处理信标的周期为True）。如果在定位初始化阶段读到信标，且能够根据该信标的位置计算出列车的定位，（即车身范围内没有轨道边界或未知状态的道岔），即认为初始化定位成功。
%
def TrainLocatedOnBeacon(k):
    return (MovingInitialByBeacon(k)
              and NewBeaconObtained(k)
              and (ATPsetting.PolarizedTrain
                    or (MovingInitialByBeacon(k-1)
                         and TrackMap.AreNeighbouredBeacons(BeaconBeforeLastObtained(k),
                                                                   BeaconLastObtained(k))))
              and BeaconLocation(k) is not None)
#
@
MemorizedLocationAuthorized，项目配置是否授权使用记忆定位
%
def MemorizedLocationAuthorized(k):
    return Offline.GetMemorizedLocationAuthorized(k)
#
@
MemorizedLocationEnable，仅在刚上电车还未动时允许使用记忆定位
%
def MemorizedLocationEnable(k):
    return (not TrainHasMoved(k))
#
@
MemorizedLocationAvailable，记忆定位是否可用
%
def MemorizedLocationAvailable(k):
    return (TrainFilteredStopped(k)
            and ValidTrainKinematic(k)
            and MemorizedLocationAuthorized(k)
            and MemorizedLocationEnable(k)
            and Message.VitalChecksumValid(MemLocation)
            and MemLocation.MemLocVersion == MEM_LOCATION_VERSION
            and MemLocation.TrainType == TrainType(k)
            and MemLocation.TrainId == SubSystemId(k)
            and MemLocation.SleepAreaId == (TrackMap.ExistZoneLocationIncluded
                                                  (SGL_SLEEPING_ZONE, MemLocation(k).Ext2).Id)
            and MemLocation.SleepAreaVersion == (TrackMap.ExistZoneLocationIncluded
                                                   (SGL_SLEEPING_ZONE, MemLocation(k).Ext2).Version)
            and MemLocation.TrainLength == ATPsetting.LocationTrainLength)
#
@
MotionSinceMemorizedLocation，记录自唤醒后运行了多少距离
%
def MotionSinceMemorizedLocation(k):
    if (TrainLocatedOnOtherATP(k-1)):
        return OtherATP(k).MotionSinceMemLoc
    elif (MemorizedLocationAvailable(k)
          or not MemLocationNotConfirmed(k-1)):
        return 0
    else:
        return (MotionSinceMemorizedLocation(k-1) + MaximumTrainMotion(k)) 
#
@
TrainPresumablyLocalized，列车使用记忆定位，但还未读到确认信标的状态。待已经通过信标重定位，或者失位后，清除该值。
%
def TrainPresumablyLocalized(k):
    if (MemorizedLocationAvailable(k)
        and not TrainPresumablyLocalized(k-1)):
        return True
    elif (TrainPresumablyLocalized(k-1)
          and (not TrainLocalized(k-1)
               or TrainRealignmentOnBeacon(k-1)):
        return False
    else:
        return TrainPresumablyLocalized(k-1)
#
@
TrainStoppedStartTime，记录开始停车的时间
%
def TrainStoppedStartTime(k):
    if (Initialization
        or (not TrainFilteredStopped(k-1)
             and TrainFilteredStopped(k)):
        return ATPtime(k)
    else:
        return TrainStoppedStartTime(k-1)
#
@
TrainLocatedOnOtherATP，本端和远端都在停车状态时，才有可能使用远端定位
$
Only when ATP and redundant ATP are all in filtered stopped state, can ATP use redundant ATP location for initialization.
%
def TrainLocatedOnOtherATP(k):
    if (OtherATP(k).LocatedOnKnownPath
        and TrainFilteredStopped(k)
        and OtherATP(k).TrainFilteredStopped
        and Message.IsMoreRecent(OtherATP(k).LatestTimeOtherCore, TrainStoppedStartTime(k))
        and not TrainLocatedOnKnownPath(k-1)
        and not TrainPresumablyLocalized(k)):
        TrainLocatedOnOtherATP = True
    else:
        TrainLocatedOnOtherATP = False
    return TrainLocatedOnOtherATP
#
@
TrainInitialLocation，记录列车通过远端ATP、记忆定位、或信标初始化时的位置。如果列车失位，则清除该位置；如果列车保持定位，则保留该位置。
$
ATP determine the initial train location by redundant ATP, memorized location and beacon location in order. If train delocalized, the train location should be clear.
%
def TrainInitialLocation(k):
    if (TrainLocatedOnOtherATP(k)):
        return OtherATP(k).Location
    elif (TrainPresumablyLocalized(k)
          and not TrainHasMoved(k)):
        return MemLocation(k)
    elif (TrainLocatedOnBeacon(k)):
        return BeaconLocation(k)
    elif (TrainLocalized(k-1)):
        return TrainInitialLocation(k-1)
    else:
        return None
#
@
LocationBeforeReloc，上周期列车已定位的情况下，使用里程计测得的位移来更新列车定位。
$
If train has localized on the track map, according to the orientation of END_2, ATP using the maximum and minimum train motion to update the external or internal location of the END_2.
%
def LocationBeforeReloc(k):
    if (TrainLocalized(k-1) and ValidTrainKinematic(k)):
        if (OdometerState(k) is INITIALIZED):
            if (End2RunningForward(k)):
                LocationBeforeReloc.Uncertainty = (TrainLocation(k-1).Uncertainty
                                                     - (MaximumTrainMotion(k) - MinimumTrainMotion(k)))
            else:
                LocationBeforeReloc.Uncertainty = (TrainLocation(k-1).Uncertainty
                                                     + (MaximumTrainMotion(k) - MinimumTrainMotion(k)))
        else:
            LocationBeforeReloc.Uncertainty = (TrainLocation(k-1).Uncertainty
                                                      + abs(MaximumTrainMotion(k))
                                                      + abs(MinimumTrainMotion(k))) 

        LocationBeforeReloc.Ext2 = (TrackMap.LocationUpdateExt2(End2RunningForward(k),
                                                                           TrainLocation(k-1).Ext2.Ort,
                                                                           TrainLocation(k-1).Ext2,
                                                                           MaximumTrainMotion(k),
                                                                           MinimumTrainMotion(k)))
        LocationBeforeReloc.Int2 = UpdateInt2FromExt2
        LocationBeforeReloc.Ext1 = UpdateExt1FromExt2
        LocationBeforeReloc.Int1 = UpdateInt1FromExt2
    else:
        LocationBeforeReloc = None
    return LocationBeforeReloc
#
@
LocationUntravelable，判断车身范围内是否有线路边界或者状态不符的道岔。当上周期列车定位，并满足以下条件时，本周期设置为True。如果车尾最小定位到车头最大定位之间存在状态未知的道岔(包括发散或汇聚节点)；或者，如果车尾最小定位到车头最大定位之间存在变量状态与之前列车位置不符的发散汇聚节点；或者，轨道边界在列车定位范围内；否则，设置该值为False。
$
ATP shall determine whether there is an unknown-status point intersecting with the train location.If the train has localized at the previous cycle, and fulfills one of the following conditions: There is an unknown-status divergence of convergence located in the range from train tail to train head, then ATP shall set as True; Or else:, if there is a convergence with reverse route located in the range from train tail to train head, the ATP shall set as True;Or else, train crossed the boundary of ATC area, shall set as True.Otherwise, set as False.
%
def LocationUntravelable(k):
    return (TrainLocalized(k-1)
             and (not (TrackMap.ReachableBetweenTwoLocations
                         (LocationBeforeReloc(k).Ext2, LocationBeforeReloc(k).Ext1,
                          (abs(MaximumTrainMotion) + ATPsetting.LocationTrainLength
                                + LocationBeforeReloc(k).Uncertainty)))
                   or not (TrackMap.ReachableBetweenTwoLocations
                            (LocationBeforeReloc(k).Ext1, LocationBeforeReloc(k).Ext2,
                             (abs(MaximumTrainMotion) + ATPsetting.LocationTrainLength
                              + LocationBeforeReloc(k).Uncertainty)))))
#
@
InverseLocation，判断END_2车头的外侧和内侧定位顺序是否正确。
$
ATP shall determine the correct order of the external and internal location of train END.
%
def InverseLocation(k):
    return (LocationBeforeReloc(k).Uncertainty < 0)
#
@
LocationUncertaintyExceed，列车定位状态下，每周期计算列车外侧定位和内侧之间的距离是否超过最大允许误差。
$
ATP shall calculate the uncertain distance between the external and internal locations of train END_2.
%
def LocationUncertaintyExceed(k):
    return (LocationBeforeReloc(k).Uncertainty > ATPsetting.LocationMaxUncertaintyConfirmed)
#
@
TrainRealignmentOnBeacon，是否在信标上重定位成功
%
def TrainRealignmentOnBeacon(k):
    return (TrainLocalized(k-1)
            and NewBeaconObtained(k)
            and (TrackMap.IntersectionOfTwoZones(BeaconLocation.Int2, BeaconLocation.Ext2,
                                                    LocationBeforeReloc.Int2, LocationBeforeReloc.Ext2)
                  is not None))
#
@
RealignmentFailed，上周期定位状态下，如果读到新的重定位信标，但ATP根据位移计算的最大最小定位，与通过读到信标位置计算的最大最小定位之间没有交集，则认为重定位失败。
%
def RealignmentFailed(k):
    return (TrainLocalized(k-1)
             and NewBeaconObtained(k)
             and (TrackMap.IntersectionOfTwoZones(BeaconLocation.Int2, BeaconLocation.Ext2,
                                                    LocationBeforeReloc.Int2, LocationBeforeReloc.Ext2)
                  is None))
#
@
LocationAfterReloc，经过信标重定位后的列车定位
%
def LocationAfterReloc(k):
    if (TrainRealignmentOnBeacon(k)):
        (LocationAfterReloc.Int2,
       LocationAfterReloc.Ext2) = (TrackMap.IntersectionOfTwoZones(LocationBeforeReloc(k).Int2,
                                                                               LocationBeforeReloc(k).Ext2,
                                                                               BeaconLocation(k).Int2,
                                                                               BeaconLocation(k).Ext2))
        LocationAfterReloc.Uncertainty = (TrackMap.DistanceBtwTwoLocs(LocationAfterReloc.Int2,
                                                                                  LocationAfterReloc.Ext2,
                                                           ATPsetting.LocationMaxUncertaintyConfirmed))
        LocationAfterReloc.Int1 = UpdateInt1FromExt2
        LocationAfterReloc.Ext1 = UpdateExt1FromExt2
    elif (not TrainLocalized(k-1)):
        LocationAfterReloc = None
    else:
        LocationAfterReloc = LocationAfterReloc(k-1)
    return LocationAfterReloc
#
@
LocPermanentFailure，在列车已定位，且未使用非确认的BM变量情况下，若发生重定位失败，则永久失位。
%
def LocPermanentFailure(k):
    return (LocPermanentFailure(k-1)
              or (TrainLocatedOnKnownPath(k-1)
                   and RealignmentFailed(k)))
#
@
MotionSinceLastReloc，记录自上次信标重定位后的运行距离绝对值
%
def MotionSinceLastReloc(k):
    if (TrainLocatedOnOtherATP(k)):
        return OtherATP(k).MotionSinceLastReloc
    elif (TrainRealignmentOnBeacon(k)):
        return abs(DistLastBeaconMax(k))
    elif (not TrainLocalized(k-1)):
        return 0
    else:
        return (MotionSinceLastReloc(k-1) + abs(MaximumTrainMotion(k)))
#
@
CBTCwithoutKnownPath，在CBTC下，若上周期定位path为假，则失位
%
def CBTCwithoutKnownPath(k):
    return (TrainLocalized(k-1)
             and not LocationPathKnown(k-1)
             and not BlockModeUsed(k))
#
@
TrainUnitIntegrity，任一端车头能保证列车完整性，则认为车辆完整性能被保证。如果该项目未配置列车完整性采集，则认为列车完整性已由车辆保证。其状态来自于项目可配置的列车输入采集。
$
If either of ends can ensure the train integrity, ATP shall set TrainUnitIntegrity as True. If the project is not configured with the capture of train integrity, it is sure that the train can guarantees the integrity.
%
def TrainUnitIntegrity(k):
    return Offline.GetTrainUnitIntegrity(k)
#
@
LocalizationFault用于表明是否发生定位错误。判断条件如下:
$
If the localization state is not NOT_LOCALIZED, ATP shall determine whether the localization fault happens or not, according to the following pseudo-codes:
%
def LocalizationFault(k):
    return (not TrainUnitIntegrity(k)
             or not ValidTrainKinematic(k)
             or LocationUntravelable(k)
             or InverseLocation(k)
             or LocationUncertaintyExceed(k)
             or RealignmentFailed(k)
             or LocPermanentFailure(k)
             or (MotionSinceLastReloc(k) > ATPsetting.LocationBeaconValidityDistance)
             or (MemLocationNotConfirmed(k-1)
                 and abs(MotionSinceMemorizedLocation(k)) >= ATPsetting.MemLocValidityDistance)
             or CBTCwithoutKnownPath(k)
             or CoupledTypeInconsistent(k))
#
@
TrainLocalized，表示当前列车是否定位。当列车定位初始化后，ATP可根据里程计测得并经打滑补偿和轴锁判断处理的列车位移，每周期更新列车在线路地图中的位置。如果再读到信标，则ATP可根据该信标的位置对之前的定位进行重新校正。考虑到安全，ATP需维护列车每端车头的外侧和内侧两组定位信息。
$
Only the localization state is LOCALIZED, ATP shall consider the train has localized. When the train passed the continuous two beacons, ATP can judge the initial location and direction according to the position and the sequences of above-mentioned beacons in track map. Later, ATP can update the train location in the track map in each cycle based on the train movement combined with sliding overestimation and wheel block consideration. If ATP received a new beacon, it will realign the train location according to this beacon. For safety, ATP needs to maintain the location information from the external and internal side of each train 
end.
%
def TrainLocalized(k):
    if (Initialization
        or LocalizationFault(k)):
        return False
    elif (not TrainLocalized(k-1)
          and (TrainPresumablyLocalized(k)
               or TrainLocatedOnOtherATP(k)
               or TrainLocatedOnBeacon(k))):
        return True
    else:
        return TrainLocalized(k-1)
#
@
TrainLocation，列车End1和End2端定位。分为以下四种情况：本周期非定位；本周期刚初始化；本周期经过信标重定位；本周期使用位移累加定位。
%
def TrainLocation(k):
    if (not TrainLocalized(k)):
        return None
    elif (not TrainLocalized(k-1)):
        return TrainInitialLocation(k)
    elif (TrainRealignmentOnBeacon(k)):
        return LocationAfterReloc(k)
    else:
        return LocationBeforeReloc(k)
#
@
DriverInCab_1或DriverInCab_2，如果采集到某端的驾驶室被激活，则ATP认为司机在该端驾驶室。其状态来自于项目可配置的列车输入采集。
$
ATP shall consider the driver is in this cab if it captures that either end of cab activated, which shown by the data from DriverInCab_1 or DriverInCab_2.
%
def DriverInCab_1(k):
    return Offline.GetDriverInCab_1(k)
def DriverInCab_2(k):
    return Offline.GetDriverInCab_2(k)
#
@
DriverInTrain，当前是否有司机在车内
$
If the active status is different between two ENDs of the train, ATP consider there is a driver in train.
%
def DriverInTrain(k):
    return (DriverInCab_1(k) is not DriverInCab_2(k))
#
@
NonVitalSelectedFrontEnd，来自CCNV的车头选择信息
￥
NonVitalSelectedFrontEnd represents the train front choice from CCNV. 
%
if (ATOcontrolTimeValid(k) == True)
    NonVitalSelectedFrontEnd = NonVitalRequest.SelectedFrontEnd(k)
else:
    NonVitalSelectedFrontEnd = UNKNOW
#
@
TrainFrontEnd，判断司机在END_1还是END_2还是由CCNV选择。
$
If there is a driver in the train, the train front is the activated END. or else: the front determined by CCNV.Otherwise, the train front is the default one or the front one when train is moving.
%
def TrainFrontEnd(k):
    if (Initialization):
       return END_2
    elif (DriverInTrain(k)):
        if (DriverInCab_1(k)):
            return END_1
        else:
            return END_2
    elif (NonVitalSelectedFrontEnd(k) is END_1
          or NonVitalSelectedFrontEnd(k) is END_2):
        return NonVitalSelectedFrontEnd(k)
    elif (WheelFilteredStopped(k)):
        return TrainFrontEnd(k-1)
    elif (not End2RunningForward(k)):
        return END_1
    else:
        return END_2
#
@
TrainFrontOrientation，列车运营方向.
$
The train front orientation is the orientation of the active train END.
%
def TrainFrontOrientation(k):
    if (TrainFrontEnd(k) is END_2):
        return TrainLocation.Ext2.Ort(k)
    else:
        return TrainLocation.Ext1.Ort(k)
#
@
TrainFrontLocation，车头定位的更新:
$
ATP updates the train front location according to the active train END.
%
def TrainFrontLocation(k):
    if (TrainFrontEnd(k) is END_1):
        TrainFrontLocation.Max = TrainLocation.Ext1
        TrainFrontLocation.Min = TrainLocation.Int1
    else:
        TrainFrontLocation.Max = TrainLocation.Ext2
        TrainFrontLocation.Min = TrainLocation.Int2
    return TrainFrontLocation
#
@
TrainRearLocation，车尾定位的更新:
$
ATP updates the train rear locations according to the active train END.
%
def TrainRearLocation(k):
    if (TrainFrontEnd(k) is END_1):
        TrainRearLocation.Max = TrainLocation.Int2
        TrainRearLocation.Min = TrainLocation.Ext2
    else:
        TrainRearLocation.Max = TrainLocation.Int1
        TrainRearLocation.Min = TrainLocation.Ext1
    return TrainRearLocation
#
@
LocationPathKnown，判断列车在Block模式没有移动授权条件下是否经过道岔导致非确认定位。
$
In BM mode, if train localized but EOA is invalid, LocationPathKnown cannot be TRUE when train cross switch. After train crossed switch and relocalized by beacon successfully, LocationPathKnown can be set to TRUE.
%
def LocationPathKnown(k):
    if (Initialization 
        or (BlockModeUsed(k)
            and TrainLocalized(k)
            and not BlockModeEOAvalid(k-1)
            and not TrainFilteredStopped(k)
            and TrackMap.ExistSwitchBtwTwoLocs(TrainRearLocation(k).Min,
                                                      TrainFrontLocation(k).Max))):
        return False
    elif (TrainLocatedOnBeacon(k)
          or TrainRealignmentOnBeacon(k)
          or TrainLocatedOnOtherATP(k)
          or (TrainPresumablyLocalized(k) and not TrainHasMoved(k))):
        return True
    else:
        return LocationPathKnown(k-1)
#
@
TrainLocatedOnKnownPath，判断列车是否定位并已知LocationPathKnown。
%
def TrainLocatedOnKnownPath(k):
    return (TrainLocalized(k)
             and LocationPathKnown(k))
#
@
LocalizationState，列车的定位状态，用于用于维护诊断功能。
%
def LocalizationState(k):
    if (TrainLocatedOnKnownPath(k)
        and not MemLocationNotConfirmed(k)):
        return LOCALIZED_CONFIRMED
    elif (TrainLocalized(k)):
        return LOCALIZED_NOT_CONFIRMED
    elif (MovingInitialByBeacon(k)):
        return MOVING_INIT
    else:
        return NOT_LOCALIZED
#
@
MemLocationNotConfirmed，是否通过本端或远端的记忆定位初始化列车定位，但还未通过重定位信标确认定位。
%
def MemLocationNotConfirmed(k):
    if (Initialization
        or not TrainLocalized(k)
        or TrainRealignmentOnBeacon(k)):
        return False
    elif (TrainPresumablyLocalized(k)):
        return True
    elif (TrainLocatedOnOtherATP(k)):
        return OtherATP.LocatedWithMemLocation(k)
    else:
        return MemLocationNotConfirmed(k-1)
#
@
LocationUncertaintyExceedTime，记录超过最大定位误差的时间
%
def LocationUncertaintyExceedTime(k):
    if (Initialization):
        return 0
    elif (TrainLocalized(k)
          and ((MemLocationNotConfirmed(k) or not LocationPathKnown(k))
                and (TrainLocation(k).Uncertainty
                     > ATPsetting.LocationMaxUncertaintyNotConfirmed))):
        return (ATPtime(k) + ATPsetting.LocReportValidityTime)
    else:
        return LocationUncertaintyExceedTime(k-1)
#
@
LocationNotUncertaintyExceed，判断是否还处在最大定位误差的确认时间内
%
def LocationNotUncertaintyExceed(k):
    if (Initialization):
        return False
    elif (TrainLocalized(k)):
        return Message.IsMoreRecent(ATPtime(k), LocationUncertaintyExceedTime(k))
    else:
        return LocationNotUncertaintyExceed(k-1)
#
@
LocalizedAuthorizationForSweepping，发给ZC的是否定位信息。
$
ATP shall send the current localization status to the ZC.
%
def LocalizedAuthorizationForSweepping(k):
    return (TrainLocalized(k)
            and LocationNotUncertaintyExceed(k))
#
@
TrainConfirmedLocalized，发给ZC的是否确认定位信息。
$
ATP shall send the status of the localization status whether confirmed.
%
def TrainConfirmedLocalized(k):
    return (LocationPathKnown(k)
            and not MemLocationNotConfirmed(k))
#
@
TrainIncludedInSleepingZone，列车停车后定位完全所在的Sleeping zone
%
def TrainIncludedInSleepingZone(k):
    if (not TrainFilteredStopped(k)):
        return None
    else:
        for SleepZone in (TrackMap.AllSingsBtwTwoLocs(SGL_SLEEPING_ZONE,
                                                       TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                                                       TrainFrontLocation(k).Max)):
            if (TrackMap.LocationInZone(TrainFrontLocation(k).Max,
                                             SleepZone.Location,
                                             SleepZone.Length,
                                             SleepZone.Orientation)
                and TrackMap.LocationInZone(TrainRearLocation(k).Min,
                                                 SleepZone.Location,
                                                 SleepZone.Length,
                                                 SleepZone.Orientation)):
                return SleepZone
            else:
                continue:
        return None
#
@
WritingMemLocRequest，是否写入记忆定位。
$
Only when train has moved and filtered stopped in sleeping zone, can ATP writing memorized location information.
%
def WritingMemLocRequest(k):
    return (TrainHasMoved(k)
              and TrainIncludedInSleepingZone(k) is not None
              and TrainLocatedOnKnownPath(k))
#
@
ClearingMemLocRequest，是否清除记忆定位
$
When train has moved and does not fulfill the condition of writing memory location, ATP shall clear memorized location information.
%
def ClearingMemLocRequest(k):
    return (not WritingMemLocRequest(k) and TrainHasMoved(k))
#
@
MemLocWritten，写入记忆定位的内容
%
def MemLocWritten(k):
    if (WritingMemLocRequest(k)):
        MemLocWritten.MemLocVersion = MEM_LOCATION_VERSION
        MemLocWritten.SleepAreaId = TrainIncludedInSleepingZone(k).Id
        MemLocWritten.SleepAreaVersion = TrainIncludedInSleepingZone(k).Version
        MemLocWritten.TrainType = TrainType(k)
        MemLocWritten.TrainId = SubSystemId(k)
        MemLocWritten.Ext2 = TrainLocation.Ext2
        MemLocWritten.Ext1 = TrainLocation.Ext1
        MemLocWritten.Uncertainty = TrainLocation.Uncertainty
        MemLocWritten.TrainLength = ATPsetting.LocationTrainLength
    elif (ClearingMemLocRequest(k)):
        MemLocWritten.MemLocVersion = None
        MemLocWritten.SleepAreaId = None
        MemLocWritten.SleepAreaVersion = None
        MemLocWritten.TrainType = None
        MemLocWritten.TrainId = None
        MemLocWritten.Ext2 = None
        MemLocWritten.Ext1 = None
        MemLocWritten.Uncertainty = None
        MemLocWritten.TrainLength = None
    else:
        MemLocWritten = MemLocWritten(k-1)
    return MemLocWritten
#
@
RestrictiveSignalOverrun，BM模式下，本周期列车车头最大定位是否冒进限制状态的信号机。当满足以下所有条件时，ATP认为列车冒进了限制状态的信号机，需设置RestrictiveSignalOverrun为True。本周期列车已定位，即TrainLocalized为True；本周期使用BM变量；上周期RestrictiveSignalOverrun为False；本周期列车位移MaximumTrainMotion向激活的驾驶室方向运行；本周期列车车头最大定位TrainFrontLocation经过了一个信号机奇点；该信号机为限制状态，或者建立了Overlap的状态。否则，设置RestrictiveSignalOverrun为False。
$
RestrictiveSignalOverrun, ATP shall determine whether the location of maximum train head overruns a restricted signal in BLOCK mode.When all of the following conditions fulfilled, ATP considers the train has overrun a restricted signal in this cycle, and set RestrictiveSignalOverrun as True.Train has localized;And the current type of EOA is BLOCK_MODE_EOA; And RestrictiveSignalOverrun was False at the last cycle;And the moving direction in current cycle is toward on the train front end; And the maximum location of train front end passes the position of the signal in this cycle;And the status of the signal is restriction or overlap established.Otherwise, ATP set RestrictiveSignalOverrun as False.
%
def RestrictiveSignalOverrun(k):
    sing = TrackMap.ExistSingBtwTwoLocs(SGL_SIGNAL, TrainFrontLocation(k-1).Max,
                                               TrainFrontLocation(k).Max)
    return (sing is not None
            and BMvariantValidWhileTemporallyValid(k)
            and ((TrainFrontEnd(k) is END_2 and End2RunningForward(k))
                 or (TrainFrontEnd(k) is END_1 and End1RunningForward(k)))
            and not BMvariantValue(sing.Variant, k))
#
@
TrainInBMinitialZone，车头最小定位在在BM初始化区域内。
%
def TrainInBMinitialZone(k):
    NewBlock = TrackMap.ExistSingularityInZone(SGL_NEW_BLOCK, TrainFrontLocation(k).Min,
                                                           ATPsetting.BMinitAreaLength)
    Signal = (TrackMap.ExistSingularityInReverseZone(SGL_SIGNAL,
                                                              NewBlock.Location,
                                                              ATPsetting.BMinitAreaLength))
    if (Signal is not None
        and Signal.BmInitialization):
        return Signal
    else:
        return None
#
@
TrainEnteredInBMinitialZoneAge， 如果列车在BM初始化区域内，则记录已在该区域内运行的时间
%
def TrainEnteredInBMinitialZoneAge(k):
    if (TrainInBMinitialZone(k) is None):
        TrainEnteredInBMinitialZoneAge = 0
    else:
        TrainEnteredInBMinitialZoneAge = TrainEnteredInBMinitialZoneAge(k-1) + 1
    return TrainEnteredInBMinitialZoneAge 
#
@
StopAssuredPointCrossed，本周期是否通过了信号机前方的BMCP点
%
def StopAssuredPointCrossed(Cbi, k):
    Bmcp = TrackMap.ExistSingBtwTwoLocs(SGL_BMCP, TrainFrontLocation(k-1).Max,
                                               TrainFrontLocation(k).Max)
    return (Bmcp is not None
             and cbi == Bmcp.CbiId)
#
@
CBIminProductionAgeSinceSSAcrossing，记录从通过上个BMCP点开始到现在已经过了多长时间
%
def CBIminProductionAgeSinceSSAcrossing(Cbi, k):
    if (Initialization
        or CBIminProductionAgeSinceSSAcrossing(k-1)>= REPORT_AGE_MAX):
        return REPORT_AGE_MAX
    elif (StopAssuredPointCrossed(Cbi, k)):
        return ATPsetting.VariantsBMALSpresenceTimer
    else:
        return (CBIminProductionAgeSinceSSAcrossing(Cbi, k-1) + 1)
#
@
CBIminProductionAge，对于每个联锁，ATP维护最后收到其变量消息时联锁的最小时间，到现在经过的时间。
%
def CBIminProductionAge(cbi, k):
    return min(CBIminProductionAgeSinceSSAcrossing(Cbi, k),
                 CBIvariantReportLastAge(Cbi, k))
#
@
ReceivedVariantsAfterEnteredBMinitialZone，先进入BM初始化区，再收到无线或者信标的变量
%
def ReceivedVariantsAfterEnteredBMinitialZone(k):
    CbiId = TrackMap.CbiId(TrainInBMinitialZone(k).Block)
    return (TrainInBMinitialZone(k) is not None
            and ((CBIvariantMoreAvailableThanBeacon(CbiId, k)
                  and ((CBIvariantReportLastAge(CbiId, k)
                         + ATPsetting.VariantsBMproductionLatencyRadio)
                       < TrainEnteredInBMinitialZoneAge(k)))
                 or (BMbeaconReadAge(k) + ATPsetting.VariantsBMproductionLatencyBeacon
                     < TrainEnteredInBMinitialZoneAge(k))))
#
@
BlockModeEOAvalid，BM下的移动授权是否可用
%
def BlockModeEOAvalid(k):
    if (Initialization
        or not BlockModeUsed(k)
        or TrainFrontEnd(k) is not TrainFrontEnd(k-1)
        or not TrainLocatedOnKnownPath(k)
        or HazardousMotionOnNonExclusiveRoute(k)
        or RestrictiveSignalOverrun(k)):
        return False
    elif (not BlockModeEOAvalid(k-1)
          and TrainInBMinitialZone(k) is not None
          and BMvariantValue(TrainInBMinitialZone.Variant(k), k)
          and ReceivedVariantsAfterEnteredBMinitialZone(k)):
        return True
    else:
        return BlockModeEOAvalid(k-1)
#
@
TrainInSMIzone，判断当车头最大定位在SMI区域内，且车速小于SMI限速时，可使用ZC的EOA消息中的WithoutSpacingEoa进行监控。
%
def TrainInSMIzone(k):
    Smi = TrackMap.ExistZoneLocationIncluded(SGL_SMI_ZONE, TrainFrontEnd(k).Max)
    return (Smi is not None
            and TrainMaxSpeed(k) < Smi.SpeedLimit(k))
#
@
CBTCmodeEOAvalid，CBTC模式下判断来自ZC的EOA是否有效。如果在SMI区域内且车速小于SMI限速，则应当使用WithoutSpacingEOA；否则，应当使用普通的EOA
%
def CBTCmodeEOAvalid(k):
    return (not BlockModeUsed(k)
            and ReceivedEOAreport.TrainFrontEnd == TrainFrontEnd(k)
            and ((TrainInSMIzone(k)
                  and (Message.IsMoreRecent(ReceivedEOAreport(k).WithoutSpacing.ValidityTime,
                                                 ATPtime(k)))
                  and (ReceivedEOAreport(k).WithoutSpacing.Location.Block != 0)
                  and (TrackMap.DistanceBtwTwoLocs(TrainFrontLocation(k).Min,
                                                         ReceivedEOAreport(k).WithoutSpacing.Location,
                                                         ATPsetting.EOAmaxDistance) is not None))
                 or (not TrainInSMIzone(k)
                     and TrainLocatedOnKnownPath(k)
                     and (Message.IsMoreRecent(ReceivedEOAreport(k).Classic.ValidityTime,
                                                    ATPtime(k)))
                     and (ReceivedEOAreport(k).Classic.Location.BlockId != 0)
                     and (TrackMap.DistanceBtwTwoLocs(TrainFrontLocation(k).Min,
                                                             ReceivedEOAreport(k).Eoa.Location,
                                                             ATPsetting.EOAmaxDistance) is not None))))
#
@
CBTCmodeEOAlocation，CBTC下的EOA位置。
%
def CBTCmodeEOAlocation(k):
    if (CBTCmodeEOAvalid(k)):
        if (TrainInSMIzone(k)):
            return ReceivedEOAreport.WithoutSpacing.Location
        else:
            return ReceivedEOAreport.Classic.Location
    else:
        return None
#
@
EndOfAuthorityValid，统一BM或CBTC下的EOA是否可用。
%
def EndOfAuthorityValid(k):
    if (BlockModeUsed(k)):
        return BlockModeEOAvalid(k)
    else:
        return CBTCmodeEOAvalid(k)
#
@
TractionAuthorisedSenseEnd1，如果EOA有效且在END_1方向，则ATP授权列车向END_1方向运行。
$
If current EOA is valid and whose orientation is END_1, ATP shall authorize the train can move toward END_1.
%
def TractionAuthorisedSenseEnd1(k):
    if (EndOfAuthorityValid(k)
        and TrainFrontEnd(k) is END_1):
        TractionAuthorisedSenseEnd1 = True
    else:
        TractionAuthorisedSenseEnd1 = False
    return TractionAuthorisedSenseEnd1
#
@
TractionAuthorisedSenseEnd2，如果EOA有效且在END_2方向，则ATP授权向驾驶室2方向运行。
$
If current EOA is valid and whose orientation is END_2, ATP shall authorize the train can move toward END_2.
%
def TractionAuthorisedSenseEnd2(k):
    if (EndOfAuthorityValid(k)
        and TrainFrontEnd(k) is END_2):
        TractionAuthorisedSenseEnd2 = True
    else:
        TractionAuthorisedSenseEnd2 = False
    return TractionAuthorisedSenseEnd2
#
@
BMoverlapReleasableSendable，在BM下且未被ATC切除状态下，通过无线发给CI解锁信息。
%
def BMoverlapReleasableSendable(k):
    return Offline.GetBMoverlapReleasableSendable(k)
#
@
OverlapReleasable，可发送Overlap解锁信息
%
def OverlapReleasable(k):
    return (BMoverlapReleasableSendable(k)
            and TrainFilteredStopped(k)
            and BlockModeEOAvalid(k)
            and NonVitalRequest.OverlapRelease(k))
#
@
CrossedOverlapTimerInitialSignal，即本周期通过一个overlap timer初始化信号机时，返回该信号机奇点
%
def CrossedOverlapTimerInitialSignal(k):
    Signal = TrackMap.ExistSingBtwTwoLocs(SGL_SIGNAL, TrainFrontLocation(k-1).Max,
                                                  TrainFrontLocation(k).Max)
    if (Signal is not None
        and Signal.BmOverlapTimerInit):
        return Signal
    else:
        return None
#
@
OverlapTimer，当经过具有Overlap初始化属性的信号机时，将OverlapTimer设置为当时信号机的变量有效期。
%
def OverlapTimer(k):
    if (not BlockModeEOAvalid(k)
        or OverlapReleasable(k)):
        return 0
    elif (BMvariantValidWhileTemporallyValid(k)
          and CrossedOverlapTimerInitialSignal(k) is not None):
        return BMvariantRemainingTime(CrossedOverlapTimerInitialSignal(k).CBIvariant.Id, k)
    else:
        return OverlapTimer(k-1) - 1
#
@
OverlapTimerPermissive，用于判断是否在BM下强制Overlap状态建立.
%
def OverlapTimerPermissive(k):
    return (OverlapTimer(k) > 0)
#
@
NotCoercedRestrictive_1，非强制限制1
%
def NotCoercedRestrictive_1(k):
    return Offline.GetNotCoercedRestrictive_1(k)
#
@
NotCoercedRestrictive_2，非强制限制2
%
def NotCoercedRestrictive_2(k):
    return Offline.GetNotCoercedRestrictive_2(k)
#
@
NotCoercedRestrictive_3，非强制限制3
%
def NotCoercedRestrictive_3(k):
    return Offline.GetNotCoercedRestrictive_3(k)
#
@
NotCoercedRestrictive_4，非强制限制4
%
def NotCoercedRestrictive_4(k):
    return Offline.GetNotCoercedRestrictive_4(k)
#
@
CoercedRestrictive，等于相应的“非强制限制”取反。
%
def CoercedRestrictive(ncr, k):
    if (ncr is NOT_COERCED_RESTRICTIVE_1):
        CoercedRestrictive = not NotCoercedRestrictive_1(k)
    elif (ncr is NOT_COERCED_RESTRICTIVE_2):
        CoercedRestrictive = not NotCoercedRestrictive_2(k)
    elif (ncr is NOT_COERCED_RESTRICTIVE_3):
        CoercedRestrictive = not NotCoercedRestrictive_3(k)
    elif (ncr is NOT_COERCED_RESTRICTIVE_4):
        CoercedRestrictive = not NotCoercedRestrictive_4(k)
    elif (ncr is VARIANTS_RECEIVED_FROM_CBI_ID):
        CoercedRestrictive = not CBIvariantLowValidity(VARIANTS_RECEIVED_FROM_CBI_ID, k)
    else:
        CoercedRestrictive = False
    return CoercedRestrictive
#
@
CoercedPermissive_1，强制允许输入1
%
def CoercedPermissive_1 (k):
    CoercedPermissive_1 = Offline.GetCoercedPermissive_1(k)
    return CoercedPermissive_1
#
@
CoercedPermissive_2，强制允许输入2
%
def CoercedPermissive_2(k):
    CoercedPermissive_2 = Offline.GetCoercedPermissive_2(k)
    return CoercedPermissive_2
#
@
CoercedPermissive_3，强制允许输入3
%
def CoercedPermissive_3(k):
    CoercedPermissive_3 = Offline.GetCoercedPermissive_3(k)
    return CoercedPermissive_3
#
@
CoercedPermissive_4，强制允许输入4
%
def CoercedPermissive_4(k):
    CoercedPermissive_4 = Offline.GetCoercedPermissive_4(k)
    return CoercedPermissive_4
#
@
CoercedPermissive，返回采集到的“强制允许”结果
%
def CoercedPermissive(cr, k):
    if (cr is COERCED_PERMISSIVE_1):
        CoercedPermissive = CoercedPermissive_1(k)
    elif (cr is COERCED_PERMISSIVE_2):
        CoercedPermissive = CoercedPermissive_2(k)
    elif (cr is COERCED_PERMISSIVE_3):
        CoercedPermissive = CoercedPermissive_3(k)
    elif (cr is COERCED_PERMISSIVE_4):
        CoercedPermissive = CoercedPermissive_4(k)
    elif (cr is VARIANTS_OVERLAP_PERMISSIVE):
        CoercedPermissive = OverlapTimerPermissive(k)
    else:
        CoercedPermissive = False
#
@
TSRreportReceived，收到TSR消息
%
def TSRreportReceived(lcId, k):
    return Message.Received(TSRdownloadContent(lcId), k)
#
@
TSRreportAvailable，TSR消息可用
%
def TSRreportAvailable(lcId, k):
    return Message.Available(TSRreportReceived(lcId, k),
                             TSRdownloadContent.CcLoopHour,
                             ATPsetting.TSRvalidityTime,
                             LastTSRreportAge(lcId, k-1),
                             k)
#
@
LastTSRreportAge，记录当前使用的TSR消息已经过了多长时间。
%
def LastTSRreportAge(lcId, k):
    return Message.LastAge(TSRreportAvailable(lcId, k),
                            TSRdownloadContent.CcLoopHour,
                            LastTSRreportAge(lcId, k-1),
                            k)
#
@
ReceivedTSRdatabase，将LC发送的TSR消息报文映射到BLOCK数组中。对于线路上的每个BLOCK，判断其是否有对应的TSR，若有，则更新其首末点坐标和限速值，其中需将TSR消息中的坐标和速度单位转化为ATP软件使用的坐标和速度单位。
$
ATP shall map the TSR message received from LC to structure of block. It need to judge whether there is corresponding TSR for each BLOCK in the track map. If yes, ATP shall update the abscissa of the starting and ending points, as well as the restriction speed. During the process, it need to transfer the abscissa and speed unit of TSR message to the corresponding one used in ATP.
%
def ReceivedTSRdatabase(lc, k):
    if (Initialization
        or (Message.Exists(DateSynchronizationReport(lc), k)
            and Message.Exists(VersionAuthorization(lc), k)
            and not Message.Exists(TSRdownloadContent(lc), k))
        or (not Message.IsMoreRecent(ReceivedTSRdatabase(lc, k-1).ValidityTime, ATPtime(k))
            and not TSRreportAvailable(k))):
            SetAllBlockAsDefaultTsr
    elif (TSRreportAvailable(lc, k)):
        NewValidity = 0
        if (Message.ReplyLocalCC(TSRdownloadContent(lc).CcLoopHour)):
            NewValidity = (TSRdownloadContent(lc).CcLoopHour + ATPsetting.TSRvalidityTime)
        else:
            NewValidity = (ATPtime(k) + ATPsetting.TSRvalidityTime
                            - (OtherATPmaxTime(k) - TSRdownloadContent(lc).CcLoopHour))
        ReceivedTSRdatabase.ValidityTime = NewValidity

        for tsr in range(0, TSRdownloadContent(lc).NumberOfTsr):
            SetTsrInFirstBlock
            SetTsrInLastBlock
            for blk in range(TSRdownloadContent(lc).Tsr[tsr].FirstBlockId + 1,
                              TSRdownloadContent(lc).Tsr[tsr].LastBlockId):
                SetTsrInIntermediateBlock

    else:
        ReceivedTSRdatabase = ReceivedTSRdatabase(lc, k-1)
    return ReceivedTSRdatabase
#
@
TrainEnergy，计算EB施加时刻的列车动能，作为能量监控使用的列车能量。
$
ATP shall calculate the train energy where EB indeed applied. The calculation shall consider the kinetic energy and the error of the potential energy. The ATPsetting.MPauthAltitudeMaxErrorEnergy means an algorithm error caused by offline tool to calculate the compensation gradients.
%
TrainEnergy = V2EbApplied * V2EbApplied
               + ATPsetting.MPauthAltitudeMaxErrorEnergy
#
@
ZoneVSLNotExceedTrainSpeedLimit，ATP应始终将项目配置的限速值为ATPsetting.MPauthLimitSpeed作为安全速度限制区域。限制区能量
%
def ZoneVSLNotExceedTrainSpeedLimit(k):
    return (TrainEnergy(k) < pow(ATPsetting.MPauthLimitSpeed))
#
@
ZoneVSLnotExceedPSR，PSR作为区域型限速的情形，ATP应将以下两种类型的PSR作F为限制区域进行监控：该PSR是车尾最小定位上游的第一个PSR（即从该PSR所在位置到车尾最小定位之间没有其他PSR），如Figure 518中的PSR2；该PSR位于车尾最小定位下游到EB实际位置之间，如Figure 518中的PSR2,PSR3和PSR4。
%
def ZoneVSLnotExceedPSR(k):
    for Psr in TrackMap.AllSingsBtwTwoLocs(SGL_PSR,
                                                   TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                                                   TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                                      X2EbApplied(k))):
        if (TrainEnergy(k) >= pow(Psr.SpeedLimit)
             and (not TrackMap.LocationBtwTwoLocs(Psr.Location,
                                                        TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                                                        TrainRearLocation(k).Min)
                   or (TrackMap.ExistSingBtwTwoLocs(SGL_PSR, Psr.Location,
                                                          TrainRearLocation(k).Min) is None))):
            return False
        else:
            continue
    return True
#
@
PointVSLnotExceedPSR，PSR作为点型限速的情形。其中，Energy.AccumulationPotentialEnergy表示根据限制点所在坡度或EB最小保障率累加计算目标位置的势能，EB最小保障率应根据所在位置的Grip值（Normal或Reduce）选取ATPsetting.EBguaranteedAccNormalGrip或ATPsetting.EBguaranteedAccReducedGrip。能量计算的原理和方法见[REF10]。当车尾在一个较低的PSR（或TSR）中时，若当前车速小于该PSR限速，而计算出的V2速度大于该PSR限速，按照上述处理方式，也会导致EB，尽管当列车运行到X2位置时，列车也许已经离开了该PSR区域。
$
If the train tail intersected with a PSR (or TSR) area, and the speed of train is lower but the V2EbApplied is higher than the limitation. In accordance with the above approach will result in EB, although when the train runs to the EB applied position, the train may have left the PSR area.
%
def PointVSLnotExceedPSR(k):
    for Psr in (TrackMap.AllSingsInZone(SGL_PSR,
                                TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                                ATPsetting.EOAmaxDistance)):
        if (TrainEnergy(k) >= (pow(Psr.SpeedLimit)
                                   + (Energy.AccumulationPotentialEnergy
                                       (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                           X2EbApplied(k)),
                                        Psr.Location)))):
            return False 
        else:
            continue
    return True
#
@
ZoneVSLnotExceedBSR，车身范围内有BSR的情形
%
def ZoneVSLnotExceedBSR(k):
    for Block in (TrackMap.AllSingsBtwTwoLocs(SGL_NEW_BLOCK,
                             TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                             TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):
        if (Block.Bsr is not None
            and not CoercedPermissive(Block.CoercedPermissive, k)
            and not VariantValue(Block.Bsr.Variant, k)
            and TrainEnergy(k) >= pow(Block.Bsr.Speed)):
            return False
        else:
            continue
    return True
#
@
PointVSLnotExceedBSR，列车下游有BSR的情形
%
def PointVSLnotExceedBSR(k):
    for Block in (TrackMap.AllSingsInZone(SGL_NEW_BLOCK,
                               TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                               ATPsetting.EOAmaxDistance)):
        if (Block.Bsr is not None
            and not CoercedPermissive(Block.Bsr.CoercedPermissive, k)
            and not VariantValue(Block.Bsr.Variant, k)
            and TrainEnergy(k) >= (pow(Block.Bsr.Speed)
                                       + (Energy.AccumulationPotentialEnergy
                                          (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                              X2EbApplied(k)),
                                           Block.Bsr.Position)))):
            return False 
        else:
            continue
    else:
        return True
#
@
TSRcontrolInhibition，不处理TSR信息。其状态来自于项目可配置的列车输入采集。
$
According to the status of TSRcontrollinhibition, ATP can judge whether it is necessary to handle TSR information.
%
def TSRcontrolInhibition(k):
    return Offline.GetTSRcontrolInhibition(k)
#
@
ZoneVSLnotExceedTSR，TSR作为区域型限速的情形。即对于从车尾所在Block起始点到EB施加位置内的所有Block，当满足以下条件时，认为列车超过了TSR限速：未禁止处理TSR信息；且该Block存在TSR；且列车定位与该TSR区域有交集；且计算的列车能量大于上述TSR的限制能量。其中TSRonBlock表示获取指定Block上TSR的值。
%
def ZoneVSLnotExceedTSR(k):
    for Blk in (TrackMap.AllSingsBtwTwoLocs(SGL_NEW_BLOCK,
                              TrackMap.BlockOrigin(TrainRearLocation(k).Min)
                              TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):
        Tsr = TSRonBlock(Blk, TrackMap.OppositeOrientation(TrainFrontOrientation(k)), k)
        if (not TSRcontrolInhibition(k)
            and Tsr is not None
            and not TrackMap.LocationBtwTwoLocs(Tsr.Position,
                                                       TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                                                       TrainRearLocation(k).Min)
            and TrainEnergy(k) >= pow(Tsr.Value)):
            return False
        else:
            continue
return True
def TSRonBlock(blockId, direction, k):
    if (not ReceivedTSRdatabase.Blocks[blockId].NotRestrictionApplication):
        if (direction is UP):
            return (ReceivedTSRdatabase.Blocks[blockId].Position[0],
                      ReceivedTSRdatabase.Blocks[blockId].Value)
        else:
            return (ReceivedTSRdatabase.Blocks[blockId].Position[1],
                      ReceivedTSRdatabase.Blocks[blockId].Value)
    else:
        return None
#
@
PointVSLnotExceedTSR，TSR作为点型限速的情形
%
def PointVSLnotExceedTSR(k):
    for Blk in (TrackMap.AllSingsInZone(SGL_NEW_BLOCK,
                                TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                                ATPsetting.EOAmaxDistance)):
        Tsr = TSRonBlock(Blk, TrainFrontOrientation(k), k)
        if (not TSRcontrolInhibition(k)
            and Tsr is not None
            and TrainEnergy(k) >= (pow(Tsr.Value)
                                       + (Energy.AccumulationPotentialEnergy
                                           (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                               X2EbApplied(k)),
                                           Tsr.Position)))):
            return False
        else:
            continue
    else:
        return True
#
@
ZoneVSLnotExceedOTE，Open track end作为区域型限速的情形
%
def ZoneVSLnotExceedOTE(k):
    if (TrackMap.ExistSingularityInZone(SGL_OPEN_TRACK_END, TrainFrontLocation(k).Max,
                                               X2EbApplied(k)) is not None)):
        return False
    else: 
        return True
#
@
PointVSLnotExceedOTE，Open track end作为点型限速的情形
%
def PointVSLnotExceedOTE(k):
     Ote = (TrackMap.ExistSingularityInZone(SGL_OPEN_TRACK_END,
                                TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                                ATPsetting.EOAmaxDistance)
    if (Ote is not None)
        and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy
                                   (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                       X2EbApplied(k)),
                                    Ote.Location))):
        return False
    else:
        return True
#
@
ZoneVSLnotExceedCTE，Close track end作为区域型限速的情形
%
def ZoneVSLnotExceedCTE(k):
    cte = (TrackMap.ExistSingularityInZone(SGL_CLOSE_TRACK_END, TrainFrontLocation(k).Max,
                                                   X2EbApplied(k)))
    if (cte is not None
        and TrainEnergy(k) >= pow(cte.SpeedLimit)):
        return False
    else: 
        return True
#
@
PointVSLnotExceedCTE，Close track end作为点型限速的情形
%
def PointVSLnotExceedCTE(k):
    cte = (TrackMap.ExistSingularityInZone(SGL_CLOSE_TRACK_END,
                                TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                                ATPsetting.EOAmaxDistance))
    if (cte is not None
        and TrainEnergy(k) >= (pow(cte.SpeedLimit)
                                   + (Energy.AccumulationPotentialEnergy
                                       (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                           X2EbApplied(k)),
                                      cte.Location)))):
        return False
    else:
        return True
#
@
ZoneVSLnotExceedSignal，信号机作为区域型限速的情形
%
def ZoneVSLnotExceedSignal(k):
    for Sig in TrackMap.AllSingsInZone(SGL_SIGNAL, TrainFrontLocation(k).Max, X2EbApplied(k)):
        if ((CoercedRestrictive(Sig.NotCoercedRestrictive, k)
             or not VariantValue(Sig.Variant, k))
            and (not CoercedPermissive(Sig.CoercedPermissive, k)
                 and not VariantValue(Sig.OverlapVariant, k))):
            return False
        else: 
            continue
    else:
        return True
#
@
PointVSLnotExceedSignal，信号机作为点型限速的情形
%
def PointVSLnotExceedSignal(k):
    for Sig in TrackMap.AllSingsInZone(SGL_SIGNAL,
                                TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                                ATPsetting.EOAmaxDistance)):
        if ((CoercedRestrictive(Sig.NotCoercedRestrictive, k)
             or not VariantValue(Sig.Variant, k))
            and (not CoercedPermissive(Sig.CoercedPermissive, k)
                 and not VariantValue(Sig.OverlapVariant, k))):
            and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy
                                      (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                          X2EbApplied(k)),
                                      Sig.Location))):
            return False
        else:
            continue
    else:
        return True
#
@
ZoneVSLnotExceedOverlap，Overlap作为区域型限速的情形
%
def ZoneVSLnotExceedOverlap(k):
    for Overlap in TrackMap.AllSingsInZone(SGL_OVERLAP_END, TrainFrontLocation(k).Max,
                                                   X2EbApplied(k)):
        Signal = TrackMap.ExistSingBtwTwoLocs(SGL_SIGNAL, TrainFrontLocation(k).Max,
                                                     Overlap.Location)
        if (Signal is not None
            and (CoercedRestrictive(Signal.NotCoercedRestrictive, k)
                 or not VariantValue(Signal.Variant, k))
            and (CoercedPermissive(Signal.CoercedPermissive, k)
                 or VariantValue(Overlap.Variant, k))):
            return False
        else: 
            continue
    return True
#
@
PointVSLnotExceedOverlap，Overlap作为点型限速的情形
%
def PointVSLnotExceedOverlap(k):
    for Overlap in (TrackMap.AllSingsInZone(SGL_OVERLAP_END, 
                               TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                               ATPsetting.EOAmaxDistance)):
        Signal = (TrackMap.ExistSingBtwTwoLocs(SGL_SIGNAL,
                          TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                          Overlap.Location))
        if (Signal is not None
            and (CoercedRestrictive(Signal.NotCoercedRestrictive, k)
                 or not VariantValue(Signal.Variant, k))
            and (CoercedPermissive(Signal.CoercedPermissive, k)
                 or VariantValue(Overlap.Variant, k))
            and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy
                                      (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                          X2EbApplied(k)),
                                       Overlap.Location))):
            return False
        else:
            continue
    return True
#
@
ZoneVSLnotExceedSwitch，非受控道岔作为区域型限速的情形
%
def ZoneVSLnotExceedSwitch(k):
    for Switch in TrackMap.AllSwitchesInZone(TrainFrontLocation(k).Max, X2EbApplied(k)):
        if (VariantValue(Switch.Variant1, k) == VariantValue(Switch.Variant2, k)):
            return False
        else: 
            continue
    return True
#
@
PointVSLnotExceedSwitch，非受控道岔作为点型限速的情形
%
def PointVSLnotExceedSwitch(k):
    for Switch in (TrackMap.AllSwitchesInZone
                      (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                       ATPsetting.EOAmaxDistance)):
        if (VariantValue(Switch.Variant1, k) == VariantValue(Switch.Variant2, k)
            and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy
                                      (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                          X2EbApplied(k)),
                                       Switch.Location))):
            return False
        else: 
            continue
    return True
#
@
ZoneVSLnotExceedPZ，PZ作为区域型限速。ATP应监控与列车定位有以下两种关系的限制状态保护区：该保护区的起始点在车尾最小定位到紧急制动施加位置之间；或，该保护区起始点在车尾最小定位上游，但车尾最小定位在该保护区范围内。
%
def ZoneVSLnotExceedPZ(k):
    for Pz in (TrackMap.AllSingsInZone(SGL_PROTECTION_ZONE,
                                              TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                             TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):
        if ((not TrackMap.LocationBtwTwoLocs(Pz.Location,
                                                    TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                                                    TrainRearLocation(k).Min)
              or TrackMap.LocationInZone(TrainRearLocation(k).Min, Pz.Location, Pz.Length))
            and not CoercedPermissive(Pz.CoercedPermissive, k)
            and (CoercedRestrictive(Pz.NotCoercedRestrictive, k)
                 or not VariantValue(Pz.Variant, k))):
            return False
        else:
            continue
    return True
#
@
PointVSLnotExceedPZ，PZ作为点型限速的情形
%
def PointVSLnotExceedPZ(k):
    for Pz in (TrackMap.AllSingsInZone(SGL_PROTECTION_ZONE, 
                               TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                               ATPsetting.EOAmaxDistance)):
        if (not CoercedPermissive(Pz.CoercedPermissive, k)
            and (CoercedRestrictive(Pz.NotCoercedRestrictive, k)
                 or not VariantValue(Pz.Variant, k))
            and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy
                                      (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                          X2EbApplied(k)),
                                       Pz.Location))):
            return False
        else:
            continue
    return True
#
@
ZoneVSLnotExceedPSD，PSD作为区域型限速。ATP应监控与列车定位有以下两种关系的限制状态屏蔽门区域：该屏蔽门区的起始点在车尾最小定位到紧急制动施加位置之间；或，该屏蔽门区起始点在车尾最小定位上游，但车尾最小定位在该屏蔽门区范围之内。
%
def ZoneVSLnotExceedPSD(k):
    for Psd in (TrackMap.AllSingsBtwTwoLocs(SGL_PSD_ZONE,
                                                   TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                              TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):
        if ((not TrackMap.LocationBtwTwoLocs(Psd.Location,
                                                    TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                                                    TrainRearLocation(k).Min)
              or TrackMap.LocationInZone(TrainRearLocation(k).Min, Psd.Location, Psd.Length))
            and not CoercedPermissive(Psd.CoercedPermissive, k)
            and (CoercedRestrictive(Psd.NotCoercedRestrictive, k)
                 or not VariantValue(Psd.Variant, k))):
            return False
        else:
            continue
    return True
#
@
PointVSLnotExceedPSD，PSD作为点型限速的情形
%
def PointVSLnotExceedPSD(k):
    for Psd in (TrackMap.AllSingsInZone(SGL_PSD_ZONE,
                              TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k) ),
                              ATPsetting.EOAmaxDistance)):
        if (not CoercedPermissive(Psd.CoercedPermissive, k)
            and (CoercedRestrictive(Psd.NotCoercedRestrictive, k)
                 or not VariantValue(Psd.Variant, k))
            and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy
                                      (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                          X2EbApplied(k)),
                                       Psd.Location))):
            return False
        else:
            continue
    return True
#
@
ZoneVSLnotExceedZC，非授权ZC作为区域型限速的情形
%
def ZoneVSLnotExceedZC(k):
    for block in (TrackMap.AllSingsBtwTwoLocs(SGL_NEW_BLOCK, TrainRearLocation(k).Min,
                              TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):
        if (not BlockModeUsed(k)
            and not VersionAuthorizedByLC(TrackMap.ZCId(block.Id), k)):
            return False
        else:
            continue
    return True
#
@
PointVSLnotExceedZC，非授权ZC边界作为点型限速的情形
%
def PointVSLnotExceedZC(k):
    for NewBlock in (TrackMap.AllSingsInZone(SGL_NEW_BLOCK, 
                                TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),
                                ATPsetting.EOAmaxDistance)):
        if (not BlockModeUsed(k)
            and not VersionAuthorizedByLC(TrackMap.ZCId(NewBlock.Id), k)
            and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy
                                       (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                           X2EbApplied(k)),
                                       NewBlock.Location))):
            return False
        else:
            continue
    return True
#
@
ZoneVSLnotExceedEOA，CBTC下EOA作为区域型限速的情形
%
def ZoneVSLnotExceedEOA(k):
    if (CBTCmodeEOAvalid(k)
        and (TrackMap.LocationBtwTwoLocs(CBTCmodeEOAlocation(k),
                             TrainFrontLocation(k).Min,
                             TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k))))):
        return False
    else:
        return True
#
@
PointVSLnotExceedEOA，CBTC下EOA作为点型限速的情形
%
def PointVSLnotExceedEOA(k):
    if (CBTCmodeEOAvalid(k)
        and not (TrackMap.LocationBtwTwoLocs(CBTCmodeEOAlocation(k),
                              TrainFrontLocation(k).Min,
                              TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k))))
        and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy
                                   (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,
                                                                       X2EbApplied(k)),
                                   CBTCmodeEOAlocation(k)))):
        return False
    else:
        return True
#
@
ZoneVSLNotExceed，判断有无限制区域超能。
$
ATP shall determine whether train exceeds the vital speed limitation of the restrictive zone, by comparing the energy between the energy of the train and the energy of the zone.
%
 def ZoneVSLNotExceed(k):
    return (EndOfAuthorityValid(k)
            and ZoneVSLNotExceedTrainSpeedLimit(k)
            and ZoneVSLnotExceedPSR(k)
            and ZoneVSLnotExceedBSR(k)
            and ZoneVSLnotExceedTSR(k)
            and ZoneVSLnotExceedOTE(k)
            and ZoneVSLnotExceedCTE(k)
            and ZoneVSLnotExceedSignal(k)
            and ZoneVSLnotExceedOverlap(k)
            and ZoneVSLnotExceedSwitch(k)
            and ZoneVSLnotExceedPZ(k)
            and ZoneVSLnotExceedPSD(k)
            and ZoneVSLnotExceedZC(k)
            and ZoneVSLnotExceedEOA(k))
#
@
PointVSLNotExceed，判断有无限制点超能。
$
ATP shall determine whether train exceeds the vital speed limitation of the restrictive point,  by comparing the energy between the energy of the train and the kinetic added potential energy of the point.
%
def PointVSLNotExceed(k):
    return (EndOfAuthorityValid(k)
            and PointVSLnotExceedPSR(k)
            and PointVSLnotExceedBSR(k)
            and PointVSLnotExceedTSR(k)
            and PointVSLnotExceedOTE(k)
            and PointVSLnotExceedCTE(k)
            and PointVSLnotExceedSignal(k)
            and PointVSLnotExceedOverlap(k)
            and PointVSLnotExceedSwitch(k)
            and PointVSLnotExceedPZ(k)
            and PointVSLnotExceedPSD(k)
            and PointVSLnotExceedZC(k)
            and PointVSLnotExceedEOA(k))
#
@
MotionProtectionInhibition，表示ATP不负责列车位置的监控。其状态来自于项目可配置的列车输入采集。
%
def MotionProtectionInhibition(k):
    return Offline.GetMotionProtectionInhibition(k)
#
@
TrainPossiblyInOverEnergy，列车能量大于限制点或限制区能量，即超能。
$

If the train energy exceeds the zone of point vital speed limitation, ATP shall consider the train possibly over energy.
%
def TrainPossiblyInOverEnergy(k):
    return (not ZoneVSLNotExceed(k)
        or not PointVSLNotExceed(k))
#
@
TrainEnergyControlDisabled，在RM模式下不报超能。
$
If the RMF or RMR mode selected, ATP shall not monitor the train energy.
%
def TrainEnergyControlDisabled(k):
    return MotionProtectionInhibition(k)
#
@
EBforOverEnergy，超能后是否输出EB
$
ATP shall request emergency braking if train is possibly in over-energy and train speed control enabled and if following conditions fulfilled:the train is not detected at filtered stop,or the train is detected at filtered stop and: safe immobilization customization setting for this control indicates to use emergency brake，or safe immobilization customization setting for this control indicates to use emergency brake when it was already applied.
%
def EBforOverEnergy(k):
    return (TrainPossiblyInOverEnergy(k)
            and not TrainEnergyControlDisabled(k)
            and (not TrainFilteredStopped(k)
                 or (TrainFilteredStopped(k)
                     and (ATPsetting.MPauthImmoBehaviourAtFS
                          is IB_APPLY_EMERGENCY_BRAKE)
                     or ((ATPsetting.MPauthImmoBehaviourAtFS
                          is IB_APPLY_EMERGENCY_BRAKE_WHEN_TRIGGERED)
                         and not InhibitEmergencyBrake(k-1)))))
#
@
PBforOverEnergy，超能停车后是否继续输出PB
$
ATP shall request parking braking if train is possibly in over-energy and train speed control enabled and if following conditions fulfilled:the train is detected at filtered stop,and safe immobilization customization setting for this control indicates to use parking brake.
%
def PBforOverEnergy(k):
    return (TrainPossiblyInOverEnergy(k)
            and not TrainEnergyControlDisabled
            and (TrainFilteredStopped(k)
                 and (ATPsetting.MPauthImmoBehaviourAtFS is IB_APPLY_PARKING_BRAKE))) 
#
@
NotOnRestrictiveMoralTimeArea_1，当列车定位时，ATP需判断END_1端车头的内外侧 定位是否与该端车头朝向的“限制状态”信号机下游的模糊时间区有无交集。其中模糊时间区定义为信号机下游长度为ATPsetting.MTdistance的一段范围。当满足下列所有条件时，设置NotOnRestrictiveMoralTimeArea_1为True：列车已确认定位；并且：END_1端车头的内外侧定位与END_1端车头朝向的信号机下游模糊区没有交集；或者，END_1端车头的内外侧定位与END_1端车头朝向的信号机下游模糊区有交集，但该信号机是允许状态。否则，应设置NotOnRestrictiveMoralTimeArea_1为False。
%
def NotOnRestrictiveMoralTimeArea_1(k):
    Signal = TrackMap.ExistSingularityInReverseZone(SGL_SIGNAL,
                                              TrainLocation.Ext1,
                                              ATPsetting.MTdistance + TrainLocation(k).Uncertainty)
    return (TrainLocatedOnKnownPath(k)
            and (Signal is None
                 or not Signal.BmMoralTime
                 or VariantValue(Signal.Variant, k)))
#
@
NotOnRestrictiveMoralTimeArea_2，当列车定位时，ATP需判断END_2端车头的内外侧定位是否与该端车头朝向的“限制状态”信号机下游的模糊时间区有无交集。当满足下列所有条件时，设置NotOnRestrictiveMoralTimeArea_2为True：列车已确认定位；并且：END_2端车头的内外侧定位与END_2端车头朝向的信号机下游模糊区没有交集；或者，END_2端车头的内外侧定位与END_2端车头朝向的信号机下游模糊区有交集，但该信号机是允许状态。否则，应设置NotOnRestrictiveMoralTimeArea_2为False。
%
def NotOnRestrictiveMoralTimeArea_2(k):
    Signal = TrackMap.ExistSingularityInReverseZone(SGL_SIGNAL,
                                              TrainLocation.Ext2,
                                              ATPsetting.MTdistance + TrainLocation(k).Uncertainty)
    return (TrainLocatedOnKnownPath(k)
            and (Signal is None
                 or not Signal.BmMoralTime 
                 or VariantValue(Signal.Variant, k)))
#
@
RouteExclusivityGuaranted_1，如果列车在车头1对应方向且限制状态的模糊时间区内超过项目设定时间，则ATP应将该值设为限制状态。其中MoralTimeTimer_1为记录列车在车头1对应方向的限制状态模糊时间区内的时间。
$
If ATP cannot determine train is NotOnRestrictiveMoralTimeArea_1, and if this situation lasts more than ATPsetting. MTtimeout cycles, ATP shall consider that route exclusivity is not guaranteed and RouteExclusivityGuaranted_1 shall be set to False. If ATP detects that train is NotOnRestrictiveMoralTimeArea_1, route exclusivity shall consider as guaranteed for that direction of travel and RouteExclusivityGuaranted_1 shall set to True
%
def RouteExclusivityGuaranted_1(k):
    if (Initialization):
        RouteExclusivityGuaranted_1 = False
    elif (RouteExclusivityGuaranted_1(k-1)
          and not NotOnRestrictiveMoralTimeArea_1(k)):
        if (MoralTimeTimer_1(k-1) < round.floor(ATPsetting.MTtimeout)):
            MoralTimeTimer_1 = MoralTimeTimer_1(k-1) + 1
        else:
            RouteExclusivityGuaranted_1 = False
    elif (NotOnRestrictiveMoralTimeArea_1(k)):
        MoralTimeTimer_1 = 1
        RouteExclusivityGuaranted_1 = True
    else:
        RouteExclusivityGuaranted_1 = RouteExclusivityGuaranted_1(k-1)
    return RouteExclusivityGuaranted_1
#
@
RouteExclusivityGuaranted_2，如果列车在车头2对应方向且限制状态的模糊时间区内超过项目设定时间，则ATP应将该值设置为限制状态，其中MoralTimeTimer_2为记录列车在车头2对应方向限制状态模糊时间区内的时间。
$
If ATP cannot determine train is NotOnRestrictiveMoralTimeArea_2, and if this situation lasts more than ATPsetting.MTtimeout cycles, ATP shall consider that route exclusivity is not guaranteed and RouteExclusivityGuaranted_2 shall set to False. If ATP detects that train is NotOnRestrictiveMoralTimeArea_2, route exclusivity shall consider as guaranteed for that direction of travel and RouteExclusivityGuaranted_2 shall set to True
%
def RouteExclusivityGuaranted_2(k):
    if (Initialization):
        RouteExclusivityGuaranted_2 = False
    elif (RouteExclusivityGuaranted 2(k-1)
          and not NotOnRestrictiveMoralTimeArea_2(k)):
        if (MoralTimeTimer_2(k-1) < round.floor(ATPsetting.MTtimeout)):
            MoralTimeTimer_2 = MoralTimeTimer_2(k-1) + 1
        else:
            RouteExclusivityGuaranted_2 = False
    elif (NotOnRestrictiveMoralTimeArea_2(k)):
        MoralTimeTimer_2 = 1
        RouteExclusivityGuaranted_2 = True
    else:
        RouteExclusivityGuaranted_2 = RouteExclusivityGuaranted_2(k-1)
    return RouteExclusivityGuaranted_2
#
@
HazardousMotionOnNonExclusiveRoute，非RM的BM模式下，如果列车在激活端车头方向的限制状态的Moral Time区停止超时预设时间，则ATP认为当前处于“非独占进路”的风险之中。
$
If RouteExclusivityGuaranted_1 is False, ATP shall request emergency braking if and only if:TrainFrontEnd is not END_2,RM forward nor RM reverse are not selected,and block mode is not selected. If RouteExclusivityGuaranted_2 is False, ATP shall request emergency braking if and only if:TrainFrontEnd is not END_1,RM forward nor RM reverse driving mode are not selected,and block mode is not selected.
%
def HazardousMotionOnNonExclusiveRoute(k):
    return (((not RouteExclusivityGuaranted_1(k) and (TrainFrontEnd(k)!= END_2))
             or (not RouteExclusivityGuaranted_2(k) and (TrainFrontEnd(k)!= END_1)))
            and not MotionProtectionInhibition(k)
            and BlockModeUsed(k)) 
#
@
PBonNonExclusiveRoute，当由于MoralTime监控导致的停车后，是否保持输出停车制动的取决于项目配置。
$
ATP shall request parking braking if train considered too near from a non-exclusive route and if following conditions are fulfilled:the train is detected at filtered stop,safe immobilization customization setting for this control indicates to use parking brake.
%
PBonNonExclusiveRoute(k)
= HazardousMotionOnNonExclusiveRoute(k)
 and TrainFilteredStopped(k)
 and (ATPsetting.MTimmoBehaviourAtFS == IB_APPLY_PARKING_BRAKE)
#
@
EBonNonExclusiveRoute，如果当前处于“非独占进路”的风险中，且列车在移动，则ATP应当输出EB；如果当前已停车，则是否继续输出EB取决于项目配置。
$
ATP shall request emergency braking if train considered too near from a non-exclusive route and if following conditions are fulfilled:the train is not detected at filtered stop,or the train is detected at filtered stop and:safe immobilization customization setting for this control indicates to use emergency brake,or safe immobilization customization setting for this control indicates to use emergency brake when it was already applied.
%
EBonNonExclusiveRoute(k)
= （HazardousMotionOnNonExclusiveRoute(k)
    and (not TrainFilteredStopped(k)
         or (TrainFilteredStopped(k)
              and ((ATPsetting.MTimmoBehaviourAtFS == IB_APPLY_EMERGENCY_BRAKE)
                 or ((ATPsetting.MTimmoBehaviourAtFS == IB_APPLY_EMERGENCY_BRAKE_WHEN_TRIGGERED)
                      and not InhibitEmergencyBrake(k-1))))))
#
@
PermissiveZoneLogicalInput，允许区逻辑输入。其中，列车定位完全包含在vital zone中的条件如下：
%
def PermissiveZoneLogicalInput(PzType, k):
    return (TrainLocatedOnKnownPath(k)
            and IncludedInVitalZone(PzType, k))
def IncludedInVitalZone(PzType, k):
    for Vz in (TrackMap.AllSingsBtwTwoLocs(SGL_VITAL_ZONE, 
                                                   TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                                                   TrainFrontLocation(k).Max)):
        if (Vz.PermissiveZoneLogicalInput is PzType
            and TrackMap.LocationInZone(TrainFrontLocation(k).Max,
                                          Vz.Location,
                                          Vz.Length,
                                          Vz.Orientation)
            and TrackMap.LocationInZone(TrainRearLocation(k).Min,
                                          Vz.Location,
                                          Vz.Length,
                                          Vz.Orientation)
            and (Vz.Variant is None
                 or (VariantValue(Vz.Variant, k)))):
            return True
        else:
            continue
    return False
#
@
NotRestrictiveZoneLogicalInput，非限制区逻辑输入。其中，列车与vital zone没有交集的判别条件如下：
%
def NotRestrictiveZoneLogicalInput(NrzType, k):
    return (TrainLocatedOnKnownPath(k)
            and NotIntersectVitalZone(NrzType, k))
def NotIntersectVitalZone(NrzType, k):
    for Vz in (TrackMap.AllSingsBtwTwoLocs(SGL_VITAL_ZONE,
                                                   TrackMap.BlockOrigin(TrainRearLocation(k).Min),
                                                   TrainFrontLocation(k).Max)):
        if (Vz.NotRestrictiveZoneLogicalInput is NrzType
            and (TrackMap.IntersectionOfTwoZones(TrainRearLocation(k).Min,
                                                TrainFrontLocation(k).Max,
                                                vz.Location,
                                                TrackMap.CalculateZoneBorder(vz.Location, vz.Length))
                   is not None)
            and (Vz.Variant is None
                 or not VariantValue(Vz.Variant, k))):
            return False
        else:
            continue
   return True
#
@
NoUndetectableDanger_1，已监控向END_1方向的运行，其状态来自于项目可配置的列车输入采集。
$
The No Undetectable Danger in Extremity 1 shall be consider as permissive status according to project configuration.
%
def NoUndetectableDanger_1(k):
    return Offline.NoUndetectableDanger_1(k)
#
@
NoUndetectableDanger_2，其状态来自于项目可配置的列车输入采集。
$
The "No Undetectable Danger in Extremity 2" shall be consider as permissive status according to project configuration.
%
def NoUndetectableDanger_2(k):
    return Offline.NoUndetectableDanger_2(k) 
#
@
UndetectableDangerRiskForNoNUDE，当前两端车头都没有NUDE输入，则认为列车存在“无法侦测的风险”。
$
If there is neither No Undetectable Danger in Extremity 1 nor No Undetectable Danger in Extremity 2 inputs, ATP shall consider the train is possible under the risk of undetectable danger.
%
def UndetectableDangerRiskForNoNUDE(k):
    return (not NoUndetectableDanger_1(k)
             and not NoUndetectableDanger_2(k))
#
@
PBforUndetectableDangerRisk，当停车且存在“无法侦测的风险”时，如果项目配置为输出停车制动，则ATP应当输出停车制动。
$
ATP shall request a parking braking if the possibility of an undetected danger has proven to be and if following conditions are fulfilled:the train is detected at filtered stop,safe immobilization customization setting for this control indicates to use parking brake.
%
PBforUndetectableDangerRisk(k)
 = (UndetectableDangerRiskForNoNUDE(k)
    and TrainFilteredStopped(k)
    and (ATPsetting.NUDEimmoBehaviourAtFS == IB_APPLY_PARKING_BRAKE))
#
@
NUDEdistanceAccount_1，监控当司机未授权向END_1方向运行时，列车向END_1方向运行的距离，该值为非负数，若在初始化阶段，或NUDE1为True，或已经EB并停车，则等于0；否则，当测速无效时，将其设置为默认值; 否则，当里程计已初始化后：如果MaximumTrainMotion大于0，则等于上周期累加距离加上本周期最大位移，最小取0。而如果MaximumTrainMotion小于等于0，则使用上周期值加最小位移（实际上就是减小该累加值，倒车），最小取0。否则，保持累加距离不变。
$
When the driver does not authorize the train running toward the END_1, ATP shall accumulate the distance of the train running toward to the END_1.If in initialization, or the NoUndetectableDanger_1 is True, or the train has triggered EB and has stopped, ATP set this distance to 0;Else if train kinematic has invalid, ATP set this distance to the default value.Else if the odometer has initialized:If the MaximumTrainMotionis greater than 0, ATP accumulate the maximum movement in this cycle with the distance of last cycle;Or if the MaximumTrainMotionis less than or equal to 0, ATP use the minimum movement of this cycle plus to the distance last cycle (in fact, decrease the accumulated distance). The minimum of this accumulated distance is 0.Otherwise, keep the distance unchanged.
%
def NUDEdistanceAccount_1(k):    
    if (INTIALIZATION
         or NoUndetectableDanger_1(k)
         or (EBappliedForMotionWithoutNUDE(k-1) and TrainFilteredStopped(k)))
        return 0
    elif (ValidTrainKinematic(k) != True)
        return ATPsetting.NUDEdistanceWithoutMotionAvailable
    elif (OdometerState(k) is INITIALIZED)
        if (End1RunningForward(k))
             return max(0, NUDEdistanceAccount_1(k-1)+ MaximumTrainMotion(k))
        else:
             return max(0, NUDEdistanceAccount_1(k-1)+ MinimumTrainMotion(k))
    else:
        return  NUDEdistanceAccount_1(k-1)
#
@
NUDEdistanceAccount_2，监控当司机未授权向END_2方向运行时，列车向END_2方向运行的距离，该值为非正数，若在初始化阶段，或NUDE2为True，或已经EB并停车，则等于0；否则，当测速无效时，将其设置为默认值；否则，当里程计已经初始化后：若 MaximumTrainMotion小于0，则等于上周期累加距离加上本周期最大位移，最大取0。若MaximumTrainMotion大于等于0，则使用上周期值加最小位移，最大取0。否则，保持累加距离不变。
$
When the driver does not authorize the train running toward the END_2, ATP shall accumulate the distance of the train running toward to the END_2.If in initialization, or the NoUndetectableDanger_2 is True, or the train has triggered EB and has stopped, ATP set this distance to 0;Else if train kinematic has invalid, ATP set this distance to the default value.Else if the odometer has initialized:if the MaximumTrainMotion is less than 0, ATP accumulate the maximum movement in this cycle with the distance of last cycle;Else: if the MaximumTrainMotion is greater than or equal to 0, ATP use the minimum movement of this cycle plus to the distance last cycle (in fact, decrease the accumulated distance). The minimum of this accumulated distance is 0.Otherwise, keep the distance unchanged.
%
def NUDEdistanceAccount_2(k):
    if (INTIALIZATION
         or NoUndetectableDanger_2(k)
         or (EBappliedForMotionWithoutNUDE(k-1) and TrainFilteredStopped(k)))
        return 0
    elif (ValidTrainKinematic(k) != True)
        return -1 * ATPsetting.NUDEdistanceWithoutMotionAvailable(k)
    elif (OdometerState(k) is INITIALIZED)
        if (End2RunningForward(k))
             return min(0, NUDEdistanceAccount_2(k-1)+ MaximumTrainMotion(k))
        else:
             return min(0, NUDEdistanceAccount_2(k-1)+ MinimumTrainMotion(k))
    else:
        return NUDEdistanceAccount_2(k-1)
#
@
UndetectDangerMotionWithoutNUDE，列车运行超过限定距离，但仍有车头未检测到NUDE。
$
When the train has moved without NUDE more than project-restricted distance, ATP shall set this value to True.
%
UndetectDangerMotionWithoutNUDE(k)
 = (not NoUndetectableDanger_1(k)
       and (NUDEdistanceAccount_1(k)> ATPsetting.NUDElimitDistance))
    or (not NoUndetectableDanger_2(k)
         and (NUDEdistanceAccount_2(k)< -1 * ATPsetting.NUDElimitDistance)))
#
@
EBappliedForMotionWithoutNUDE，保证由NUDE导致的EB会延迟一段时间。即：当UndetectDangerMotionWithoutNUDE为True时，设置EBappliedForMotionWithoutNUDE为True；当UndetectDangerMotionWithoutNUDE由True变为False后，还需保持EBappliedForMotionWithoutNUDE 在ATPsetting.NUDEtrainStopDurationBeforeEBrelease时间内为True；超过上述时间后，该值为False。
$
The EB request shall be maintained to True during the application time ATPsetting.NUDEtrainStopDurationBeforeEBrelease, if the train has moved without NUDE more than project restricted distance. When?UndetectDangerMotionWithoutNUDE is?True,?ATP shall set?EBappliedForMotionWithoutNUDE?to?True;When?UndetectDangerMotionWithoutNUDE change from?True?to False,  ATP shall
maintain?EBappliedForMotionWithoutNUDE?to True in period ATPsetting.NUDEtrainStopDurationBeforeEBrelease；Over?the?time,?set this value to?False.
%
def EBappliedForMotionWithoutNUDE(k):
    if (UndetectDangerMotionWithoutNUDE(k)):
        NudeEBreleaseCounter = 0
        return True
    elif (NudeEBreleaseCounter < ATPsettings.NUDEtrainStopDurationBeforeEBrelease):
        NudeEBreleaseCounter = NudeEBreleaseCounter(k-1) + 1
        return True
    else:
        return False
#
@
EBforUndetectableDangerRisk，由“无法侦测的危险”导致EB并停车后，ATP应当根据项目配置判断是否输出EB。
$
When the train has triggered emergency brake causing by the "undetectable danger risk" and has stopped, ATP shall determine whether keeping the EB output according to the project configuration.
%
EBforUndetectableDangerRisk(k)
 = (EBappliedForMotionWithoutNUDE(k)
   or (UndetectableDangerRiskForNoNUDE(k)
       and (not TrainFilteredStopped(k)
            or (ATPsetting.NUDEimmoBehaviourAtFS == IB_APPLY_EMERGENCY_BRAKE)
            or ((ATPsetting.NUDEimmoBehaviourAtFS == IB_APPLY_EMERGENCY_BRAKE_WHEN_TRIGGERED)
                  and (not InhibitEmergencyBrake(k-1))))))
#
@
ConditionForRMlimitSpeed，当前应用哪种RM限速。ATP最多支持项目配置MAX_RM_CONDITION_NB种RM限速。
%
def ConditionForRMlimitSpeed(i, k):
    return Offline.GetConditionForRMlimitSpeed(i, k)
#
@
RMlimitSpeedApplied，根据列车输入，判断当前应当监控的RM限速
%
def RMlimitSpeedApplied(k):
    for i in range(0, MAX_RM_CONDITION_NB):
        if (ConditionForRMlimitSpeed(i, k)):
            return ATPsetting.MPinhibitionLimitSpeed[i]
        else:
            continue
    return 0
#
@
NoDangerForRMoverSpeed，列车速度小于等于RM模式下的限速。
$
ATP estimates that current train maximum speed not exceeds the RM limit speed.
%
def NoDangerForRMoverSpeed(k):
    return (ValidTrainKinematic(k)
            and TrainMaxSpeed(k) <= RMlimitSpeedApplied(k)) 
#
@
EBforRMoverSpeed，若在RM模式下，列车速度大于RM模式限速，则将输出EB。
%
def EBforRMoverSpeed(k):
    return (not NoDangerforRMoverSpeed(k)
             and MotionProtectionInhibition(k))
#
@
NoDangerForMemorizedLocationOverSpeed，在使用记忆定位而还未读到确认信标时，ATP监控列车速度是否超过项目限制值。
%
def NoDangerForMemorizedLocationOverSpeed(k):
    return (not MemLocationNotConfirmed(k)
            or TrainMaxSpeed < ATPsetting.MemLocLimitSpeed)
#
@
EBforMemorizedLocationOverSpeed，在使用记忆定位而还未读到确认信标时，ATP应确保列车速度不超过项目限制值。
%
def EBforMemorizedLocationOverSpeed(k):
    return (not NoDangerforMemorizedLocationOverSpeed(k)
            and not MotionProtectionInhibition(k))
#
@
RMRselectedDrivingMode，是否选择了RMR倒车模式。其状态来自于项目可配置的列车输入采集。
$
RMRselectedDrivingMode represents the choice of RMR. 
%
def RMRselectedDrivingMode(k):
    return Offline.GetRMRselectedDrivingMode(k)
#
@
RollbackDistanceAccount_1，累计回溜的距离（负值表示在回溜）：初始化时设置该值为0；否则，如果列车运动学无效，则设置为配置参数的默认值；否则，在END_1激活且未选择RMR模式的前提下：若里程计已初始化，且列车向END_1方向运行，则累加最小位移，若超过0则取0，否则是一个负值。否则，若里程计齿数齿号匹配，则累加列车最大位移; 否则，即里程计未初始化，则保持累计距离不变。其他情况，保持累计距离不变。
$
When train front extremity is END_1 and traction effort is supposed to be in the direction of travel, RollbackDistanceAccount_1 is the estimated maximum distance which separates current front extremity 1 position to last most forward position reached by this extremity. ATP shall evaluate RollbackDistanceAccount_1 in order to control that speed does not exceed ATPsetting.MPnotAuthLimitSpeed .
%
def RollbackDistanceAccount_1(k):
    if (Initialization)
        return 0
    elif (not ValidTrainKinematic(k)):
        return (-1 * ATPsetting.MPnotAuthDistWithoutMotionAvailable)
    elif (TrainFrontEnd(k) is END_1
           and not RMRselectedDrivingMode(k)):
        if (OdometerState(k) is INITIALIZED):
            if (End1RunningForward(k)):
                return min(0, RollbackDistanceAccount_1(k-1) + MinimumTrainMotion(k))
            else:
                return (RollbackDistanceAccount_1(k-1) + MaximumTrainMotion(k))
        else:
            return RollbackDistanceAccount_1(k-1)
    else:
        return RollbackDistanceAccount_1(k-1)
#
@
RollbackDistanceAccount_2，累计回溜的距离（负值表示在回溜）：初始化时设置该值为0；否则，如果列车运动学无效，则设置为配置参数的默认值；否则，在END_2激活且未选择RMR模式的前提下：若里程计已初始化，且列车向END_2方向运行，则减去最小位移，若超过0则取0，否则是一个负值。否则，若里程计已初始化，则减去列车最大位移;否则，即里程计还未初始化，则保持累计距离不变。其他情况，保持累计距离不变。
$
When train front extremity is END_2 and traction effort is supposed to be in the direction of travel, RollbackDistanceAccount_2 is the estimated maximum distance which separates current front extremity 2 position to last most forward position reached by this extremity. ATP shall evaluate RollbackDistanceAccount_2 in order to control that speed does not exceed ATPsetting.MPnotAuthLimitSpeed.
%
def RollbackDistanceAccount_2(k):
    if (Initialization)
        return 0
    elif (not ValidTrainKinematic(k)):
        return (-1 * ATPsetting.MPnotAuthDistWithoutMotionAvailable)
    elif (TrainFrontEnd(k) is END_2
           and not RMRselectedDrivingMode(k)):
        if (OdometerState(k) is INITIALIZED):
            if (End2RunningForward(k)):
                return min(0, RollbackDistanceAccount_2(k-1) - MinimumTrainMotion(k))
            else:
                return (RollbackDistanceAccount_2(k-1) ― MaximumTrainMotion(k))
        else:
            return RollbackDistanceAccount_2(k-1)
    else:
        return RollbackDistanceAccount_2(k-1)
#
@
UnrecoverableRollbackOverSpeed，如果ATP检测到列车已经回退超过项目限制的最大距离，则设置永久回退超速
$
From ATP power-up, UnrecoverableRollbackOverSpeed shall initialize to False. UnrecoverableRollbackOverSpeed shall be set to True if and only if following conditions are fulfilled:driving selector indicates that traction effort is supposed to be in the direction of travel,train front extremity is END_2 or END_1,and rollback limit speed currently applicable is null for this direction of travel.Once UnrecoverableRollbackOverSpeed set as True, it shall stay at state True while ATP is not reboot.
%
def UnrecoverableRollbackOverSpeed(k):
    return (UnrecoverableRollbackOverSpeed(k-1)
            or (not RMRselectedDrivingMode(k)
                and ((TrainFrontEnd(k) is END_2
                      and (abs(RollbackDistanceAccount_2(k))
                           >  ATPsetting.MPnotAuthLimitDistance))
                     or (TrainFrontEnd(k) is END_1
                         and (abs(RollbackDistanceAccount_1(k))
                              >  ATPsetting.MPnotAuthLimitDistance))))) 
#
@
RollbackOverSpeed，下列任一条件满足，认为回退超速若车头2激活，位移为END_1方向，未选择RMR模式;车速大于当前回退距离所在限速;若车头1激活，位移为END_2方向，未选择RMR模式;车速大于当前回退距离所在限速;列车运动学无效;已发生了永久回退超速错误
$
RollbackOverSpeed shall be True if and only if following conditions are fulfilled:driving selector indicates that traction effort is supposed to be in the direction of travel,train front extremity is END_2 or END_1,and movement observed is in the opposite direction of travel, and over-estimated train speed is greater than ATPsetting.MPnotAuthLimitSpeed currently applicable for this direction of travel and rollback speed restrictions is not null.Or: train has reached a position due a rollback movement which is unrecoverable,Or: train kinematic is invalid,
%
def RollbackOverSpeed(k):
    return (not ValidTrainKinematic(k)
            or UnrecoverableRollbackOverSpeed(k)
            or (not RMRselectedDrivingMode(k)
                and (TrainMaxSpeed(k) >= ATPsetting.MPnotAuthLimitSpeed
                     and ((TrainFrontEnd(k) is END_2
                            and End1RunningForward(k) and not End2RunningForward(k))
                          or (TrainFrontEnd is END_1
                            and End2RunningForward(k) and not End1RunningForward(k))))))
#
@
EBforRollbackOverSpeed，如果ATP检测到回溜超速，则输出EB
$
ATP shall request emergency braking if a reverse speed limit is over-run for unwilling rollback or excessive reverse motion.
%
EBforRollbackOverSpeed = RollbackOverSpeed(k)
#
@
LongDistanceReverseAuthorized，长距离倒车模式是否授权，其状态来自于项目可配置的列车输入采集。
$
LongDistanceReverseAuthorized represents the authorization of long distance reverse. 
%
def LongDistanceReverseAuthorized(k):
    return Offline.GetLongDistanceReverseAuthorized(k)
#
@
ReverseDistanceAccount_1，累加RMR模式下的倒车距离（负值表示倒车）：
初始化时设置该值为0；否则，如果列车运动学无效，则设置为配置参数的默认值；否则，在END_1激活且非长距离倒车授权的前提下：若里程计已初始化，且列车向END_1方向运行，则减小倒车距离绝对值，大于零则等于0。否则，如果里程计已初始化，且选择RMR模式，则累加倒车距离。否则，即里程计还未初始化，则保持距离不变。其他情况，保持累计距离不变。
$
When train front extremity is END_1 and traction effort is supposed to be in the opposite direction of travel, ReverseDistanceAccount_1 is the estimated maximum distance which separates current front extremity 1 position to last most forward position reached by this extremity. ATP shall evaluate ReverseDistanceAccount_1 in order to control that speed does not exceed reverse speed limit function.
%
def ReverseDistanceAccount_1(k):
    if (Initialization)
        return 0
    elif (not ValidTrainKinematic(k)):
        return ATPsetting.ReverseDistWithoutMotionAvailable
    elif (TrainFrontEnd is END_1
           and not LongDistanceReverseAuthorized(k)):
        if (OdometerState(k) is INITIALIZED):
            if (End1RunningForward(k)):
                return min(0, ReverseDistanceAccount_1(k-1) + MinimumTrainMotion(k))
            elif (RMRselectedDrivingMode(k)):
                return (ReverseDistanceAccount_1(k-1) + MaximumTrainMotion(k))
            else:
                return ReverseDistanceAccount_1(k-1)
        else:
            return ReverseDistanceAccount_1(k-1)
    else:
        return ReverseDistanceAccount_1(k-1)
#
@
ReverseDistanceAccount_2，累加RMR模式下的倒车距离（负值表示倒车）：初始化时设置该值为0；否则，如果列车运动学无效，则设置为配置参数的默认值；否则，在END_2激活且非长距离倒车授权的前提下：如果里程计已初始化，且列车向END_2方向运行，则减小倒车距离绝对值，大于零则等于0。否则，如果里程计已初始化，且选择RMR模式时累加倒车距离。否则，即里程计未初始化，则保持距离不变；其他情况，保持累计距离不变。
$
When train front extremity is END_2 and traction effort is supposed to be in the opposite direction of travel, ReverseDistanceAccount_2 is the estimated maximum distance which separates current front extremity 2 position to last most forward position reached by this extremity. ATP shall evaluate ReverseDistanceAccount_2 in order to control that speed does not exceed ReverseSpeedRestrictions reverse speed limit function.
%
def ReverseDistanceAccount_2(k):
    if (Initialization)
        return 0
    elif (not ValidTrainKinematic(k)):
        return ATPsetting.ReverseDistWithoutMotionAvailable
    elif (TrainFrontEnd(k) is END_2
           and not LongDistanceReverseAuthorized(k)):
        if (OdometerState(k) is INITIALIZED):
            if (End2RunningForward(k))
                return min(0, ReverseDistanceAccount_2(k-1) - MinimumTrainMotion(k))
            elif (RMRselectedDrivingMode(k)):
                return (ReverseDistanceAccount_2(k-1) ― MaximumTrainMotion(k))
            else:
                return ReverseDistanceAccount_2(k-1)
        else:
            return ReverseDistanceAccount_2(k-1)
    else:
        return ReverseDistanceAccount_2(k-1)
#
@
ReverseOverSpeed，超过RMR模式限速的条件：
$
ReverseOverSpeed shall be True if following conditions fulfilled:driving selector indicates that traction effort is supposed to be in the opposite direction of travel,train front extremity is END_2 or END_1,and movement observed is the opposite direction of travel,and:over-estimated train speed is greater than reverse speed restrictions currently applicable for this direction of travel,or else: if reverse speed restrictions currently applicable is null for this direction of travel,Or else: train kinematic is invalid.
%
def ReverseOverSpeed(k):
    if (not RMRselectedDrivingMode(k)
         or LongDistanceReverseAuthorized(k)):
        return False
    elif (not ValidTrainKinematic(k)):
        return True
    else:
        return ((TrainFrontEnd(k) is END_2):
                   and ((End1RunningForward(k) and not End2RunningForward(k)
                          and (TrainMaxSpeed(k)
                                > ReverseSpeedRestrictions(ReverseDistanceAccount_2(k))))
                        or (ReverseSpeedRestrictions(ReverseDistanceAccount_2(k)) == 0)))
                  or (TrainFrontEnd(k) is END_1
                       and ((End2RunningForward(k) and not End1RunningForward(k)
                  and (TrainMaxSpeed(k) > ReverseSpeedRestrictions(ReverseDistanceAccount_1(k))))
                             or (ReverseSpeedRestrictions(ReverseDistanceAccount_1(k)) == 0))))
#
@
EBforReverseOverSpeed，由于RMR下倒车超速而导致EB
$
ATP shall request emergency braking if a reverse speed limit is over-run for unwilling rollback or excessive reverse motion.
%
EBforReverseOverSpeed = ReverseOverSpeed(k)
#
@
TrainEmergencyBrakeApplied，列车是否施加了紧急制动。其状态来自于项目可配置的列车输入采集。
$
TrainEmergencyBrakeApplied shows that whether the train has applied emergency brake. If the project is not configured, ATP shall consider the emergency brake has not applied by the train. Otherwise, if either of the end is in emergency brake, ATP considers the emergency brake has applied.
%
def TrainEmergencyBrakeApplied(k):
    return Offline.GetTrainEmergencyBrakeApplied(k)
#
@
TrainParkingBrakeApplied，任一端车头已施加停车制动，则认为停车制动已施加。其状态来自于项目可配置的列车输入采集。
$
The term TrainParkingBrakeApplied stands for that either of the train ends is in parking brake.
%
def TrainParkingBrakeApplied(k):
    return Offline.GetTrainParkingBrakeApplied(k)
#
@
TrainSafelyImmobilised，判断是否已经安全停车
$
ATP shall consider that train safely immobilized if:Train brake has detected safely applied, or train parking brake is detected;And train is detected at filtered stop.
%
def TrainSafelyImmobilised(k):
    return ((TrainEmergencyBrakeApplied(k)
             or TrainParkingBrakeApplied(k))
            and TrainFilteredStopped(k))
#
@
NoVitalCorrectlyDocked，CCNV判断列车是否停在开门授权区内
%
def NoVitalCorrectlyDocked(k):
    return (ATOcontrolTimeValid(k)
            and NonVitalRequest(k).TrainInCorrectlyDockedZone)
#
@
LocalATPenableDoorOpening_A，本ATP是否在站内允许开A侧车门：
$
ATP shall determine whether train doors on side A opening. The rules are following:
%
def LocalATPenableDoorOpening_A(k):
    return (TrainLocatedOnKnownPath(k)
            and TrainIncludedInVPEZ_A(k)
            and NoVitalCorrectlyDocked(k)
            and TrainSafelyImmobilised(k))
#
@
LocalATPenableDoorOpening_B，本ATP是否授权开启B侧车门：
$
ATP shall determine whether train doors on side B opening. The rules are following:
%
def LocalATPenableDoorOpening_B(k):
    return (TrainLocatedOnKnownPath(k)
            and TrainIncludedInVPEZ_B(k)
            and NoVitalCorrectlyDocked(k)
            and TrainSafelyImmobilised(k))
#
@
EnableDoorOpening_A，结合远端ATP结果的开门授权信息。
%
def EnableDoorOpening_A(k):
    return (LocalATPenableDoorOpening_A(k)
            or OtherATP.EnableDoorOpening_A)
#
@
EnableDoorOpening_B，结合远端ATP结果的开门授权信息。
%
def EnableDoorOpening_B(k):
    return (LocalATPenableDoorOpening_B(k)
            or OtherATP(k).EnableDoorOpening_B)
#
@
PSDoperation_A和PSDoperation_B，其结构为ST_PSD_OPERATION，用于获取来自CCNV的屏蔽门控制指令。
$
PSDoperation_A and PSDoperation_B structured as ST_PSD_OPERATION, used to obtain the PSD controlling order from CCNV.
%
if (ATOcontrolTimeValid(k) == True)
    PSDoperation_A(k)= NonVitalRequest.PSDoperation_A(k)
    PSDoperation_B(k)= NonVitalRequest.PSDoperation_B(k)
else:
    PSDoperation_A(k).Id = None
    PSDoperation_B(k).Id = None
#
@
CommunicateWithPSD，ATP根据CCNV的请求，判断是否与联锁建立通信。当本周期来自CCNV的PSDoperation_A或PSDoperation_B不全为None时，设置CommunicateWithPSD为True；否则，设置CommunicateWithPSD为False。
$
ATP shall determine whether to establish communication with the correlative CI according to request from CCNV:When there is at least one id of PSDoperation_A or PSDoperation_B is not none, ATP shall set CommunicatedWithPSD to True:Otherwise, set CommunicatedWithPSD to False.
%
def CommunicateWithPSD(k):
    return (PSDoperation_A(k).Id is not None
            or PSDoperation_B(k).Id is not None)
#
@
UsingPSDstatusFromCI，只有当列车定位与PSD区域有交集，且列车静止或刚发车时，ATP使用来自CI的PSD状态信息。
$
Only when the train fulfilled the following conditions, ATP shall use the PSD status from the CI:The train location intersects with a PSD zone;And the train is filtered stopped or just started moving.
%
UsingPSDstatusFromCI = ((AlignPSDzone_A(k) or AlignPSDzone_B(k))
                             and (TrainFilteredStopped(k)
                                   or (TrainFilteredStopped(k-1)
                                        and not TrainFilteredStopped(k))))
#
@
MasterCCcore，来自CCNV的当前是否为主控CC信息
$
MasterCCcore shows whether the status from CCNV is the main controlled CC.
%
if (ATOcontrolTimeValid(k) == True)
    MasterCCcore = NonVitalRequest.MasterCcCore(k)
else:
    MasterCCcore = False
#
@
PSDzoneStatus_A, 如果ATP所在为主控CC，则对A侧PSD状态的更新规则如下： 
$
If the ATP is the master CC, then the A-side PSD state updating rules are as follows:
%
if (MasterCCcore(k) == True)
    if ((PSDoperation_A.Id == None) or (PSDoperation_A.Id != PSDid_A(k)))
        PSDzoneStatus_A.Id(k)= None
        PSDzoneStatus_A.Validity = 0
        PSDzoneStatus_A.AllPSDclosed = False
    else:
        PSDzoneStatus_A(k).Id = PSDoperation_A(k).Id
        if (UsingPSDstatusFromCI(k))
             PSDzoneStatus_A.Validity(k) = TableOfPSDPlatform[PSDid_A(k)].DoorStatusValidityTime
             PSDzoneStatus_A.AllPSDclosed(k) = TableOfPSDPlatform[PSDid_A(k)].DoorClosed
        elif (CoercedPermissive(TrackMap.PSDs[PSDid_A(k)].CoercedPermissive, k))
             PSDzoneStatus_A.Validity = REPORT_AGE_MAX
             PSDzoneStatus_A.AllPSDclosed = True
        elif (CoercedRestrictive(TrackMap.PSDs[PSDid_A(k)].NotCoercedRestrictive, k))
             PSDzoneStatus_A.Validity = REPORT_AGE_MAX
             PSDzoneStatus_A.AllPSDclosed = False
        else:
             PSDzoneStatus_A.Validity(k) = ReceivedVariantReport[LineSectionOfPSD].ValidityTime
             PSDzoneStatus_A.AllPSDclosed(k)= VariantValue(TrackMap.PSDs[PSDid_A(k)].Variant, k)
#
@
PSDzoneStatus_B, 如果ATP所在为主控CC，则对B侧PSD状态的更新规则如下： 
$
If the ATP is the master CC, then the B-side PSD state updating rules are as follows:
%
if (MasterCCcore(k) == True)
    if ((PSDoperation_B.Id == None) or (PSDoperation_B.Id != PSDid_B(k)))
        PSDzoneStatus_B.Id(k)= None
        PSDzoneStatus_B.Validity = 0
        PSDzoneStatus_B.AllPSDclosed = False
    else:
        PSDzoneStatus_B.Id(k)= PSDoperation_B.Id
        if (UsingPSDstatusFromCI(k))
             PSDzoneStatus_B.Validity(k) = TableOfPSDPlatform[PSDid_B(k)].DoorStatusValidityTime
             PSDzoneStatus_B.AllPSDclosed(k) = TableOfPSDPlatform[PSDid_B(k)].DoorClosed
        elif (CoercedPermissive(TrackMap.PSDs[PSDid_B(k)].CoercedPermissive, k))
             PSDzoneStatus_B.Validity = REPORT_AGE_MAX
             PSDzoneStatus_B.AllPSDclosed = True
        elif (CoercedRestrictive(TrackMap.PSDs[PSDid_B(k)].NotCoercedRestrictive, k))
             PSDzoneStatus_B.Validity =  REPORT_AGE_MAX
             PSDzoneStatus_B.AllPSDclosed = False
        else:
             PSDzoneStatus_B.Validity(k) = ReceivedVariantReport[LineSectionOfPSD].ValidityTime
             PSDzoneStatus_B.AllPSDclosed(k)= VariantValue(TrackMap.PSDs[PSDid_B(k)].Variant, k)
#
@
如果ATP所在为备机CC，则对A侧PSD状态的更新规则如下：
$
If the ATP is not the master CC, then the A-side PSD state updating rules are as follows:
%
if (MasterCCcore != True)
    if (OtherATPmessageAvailable(k) == True)
        PSDzoneStatus_A.Id = OtherATP.PsdIdSide_A
        if (PSDzoneStatus_A.Id(k) != None)
             PSDzoneStatus_A.Validity(k) = (OtherATP.PsdValiditySide_A
                                     - Message.ModularSub(ATPtime(k), OtherATP.LatestTimeOtherCore))
             PSDzoneStatus_A.AllPSDclosed(k) = (OtherATP.PsdClosedSide_A
                                                       and (PSDzoneStatus_A.Validity(k) > 0))
        else:
             PSDzoneStatus_A.Validity = 0
             PSDzoneStatus_A.AllPSDclosed = False
    elif (PSDzoneStatus_A.Id(k-1) != None)
             PSDzoneStatus_A.Id = PSDzoneStatus_A.Id(k-1)
             PSDzoneStatus_A.Validity = PSDzoneStatus_A.Validity(k-1)- 1
             PSDzoneStatus_A.AllPSDclosed(k) = (PSDzoneStatus_A.AllPSDclosed(k-1)
                                                       and (PSDzoneStatus_A.Validity(k) > 0))
    else:
         PSDzoneStatus_A.Validity = 0
         PSDzoneStatus_A.AllPSDclosed = False
#
@
如果ATP所在为备机CC，则对B侧PSD状态的更新规则如下： 
$
If the ATP is not the master CC, then the B-side PSD state updating rules are as follows:
%
if (MasterCCcore != True)
    if (OtherATPmessageAvailable(k) == True)
        PSDzoneStatus_B.Id = OtherATP.PsdIdSide_B
        if (PSDzoneStatus_B.Id(k) != None)
             PSDzoneStatus_B.Validity(k) = (OtherATP.PsdValiditySide_B
                                     - Message.ModularSub(ATPtime(k), OtherATP.LatestTimeOtherCore))
             PSDzoneStatus_B.AllPSDclosed(k)
               = OtherATP.PsdClosedSide_B
                 and (PSDzoneStatus_B.Validity(k) > 0)
        else:
             PSDzoneStatus_B.Validity = 0
             PSDzoneStatus_B.AllPSDclosed = False
    elif (PSDzoneStatus_B.Id(k-1) != None)
             PSDzoneStatus_B.Id = PSDzoneStatus_B.Id(k-1)
             PSDzoneStatus_B.Validity = PSDzoneStatus_B.Validity(k-1) - 1
             PSDzoneStatus_B.AllPSDclosed(k)
               = PSDzoneStatus_B.AllPSDclosed(k-1)
                 and (PSDzoneStatus_B.Validity(k) > 0)
    else:
         PSDzoneStatus_B.Validity = 0
         PSDzoneStatus_B.AllPSDclosed = False
#
@
PSDstatusNonVital_A，用于CCNV发送给DMI显示的A侧PSD状态
%
def PSDstatusNonVital_A(k):
    if (PSDzoneStatus_A(k).Id is None
         or PSDzoneStatus_A(k).Validity <= 0):
        return PSD_STATE_UNKNOWN
    elif (PSDzoneStatus_A(k).AllPSDclosed):
        return PSD_STATE_CLOSED
    else:
        return PSD_STATE_OPENED
#
@
PSDstatusNonVital_B，用于CCNV发送给DMI显示的B侧PSD状态
%
def PSDstatusNonVital_B(k):
    if (PSDzoneStatus_B(k).Id is None
        or PSDzoneStatus_B(k).Validity <= 0):
        return PSD_STATE_UNKNOWN
    elif (PSDzoneStatus_B(k).AllPSDclosed):
        return PSD_STATE_CLOSED
    else:
        return PSD_STATE_OPENED
#
@
PSDmanagerOrder_A，A侧PSD的控制命令信息，其结构为ST_PSD_MANAGE。其中如果来自CCNV的A侧PSD标识不等于ATP读取SGD中A侧的标识，则禁止使用CCNV的标识开门。
$
The rules to generate the PSD manage order on side A shall follow the pseudo-codes. In which if the PSD id from CCNV is not equal to the id in ATP's track map, ATP shall prohibit the PSD opening.
%
def PSDmanagerOrder_A(k):
    PSDmanagerOrder_A.Id = PSDoperation_A.Id(k)
    if (PSDoperation_A.Id(k) == PSDid_A(k)
        and PSDoperation_A.Id(k) is not None
        and not PSDoperation_A.ClosingOrder(k)
        and PSDoperation_A.OpeningOrder(k)
        and EnableDoorOpening_A(k)):
        PSDmanagerOrder_A.Order = Open_PSD_Configuration
    elif (not PSDoperation_A.OpeningOrder(k)
           and PSDoperation_A.ClosingOrder(k)):
        PSDmanagerOrder_A.Order = Close_PSD_Of_Platform
    else:
        PSDmanagerOrder_A.Order = None
    return PSDmanagerOrder_A 
#
@
PSDmanagerOrder_B，B侧PSD的控制命令信息，其结构为ST_PSD_MANAGE。其中如果来自CCNV的B侧PSD标识不等于ATP读取SGD中B侧的标识，则禁止使用来自CCNV的标识开门。
$
The rules to generate the PSD manage order on side B shall follow the pseudo-codes. In which if the PSD id from CCNV is not equal to the id in ATP's track map, ATP shall prohibit the PSD opening.
%
def PSDmanagerOrder_B(k):
    PSDmanagerOrder_B.Id = PSDoperation_B.Id(k)
    if (PSDoperation_B.Id(k) == PSDid_B(k)
        and PSDoperation_B.Id(k) is not None
        and not PSDoperation_B.ClosingOrder(k)
        and PSDoperation_B.OpeningOrder(k)
        and EnableDoorOpening_B(k)):
        PSDmanagerOrder_B.Order = Open_PSD_Configuration
    elif (not PSDoperation_B.OpeningOrder(k)
           and PSDoperation_B.ClosingOrder(k)):
        PSDmanagerOrder_B.Order = Close_PSD_Of_Platform
    else:
        PSDmanagerOrder_B.Order = None
    return PSDmanagerOrder_B 
#
@
PSDplatformManagerOpeningOrder，本ATP是否发了开门命令.
$
ATP shall determine whether itself opening the PSD in this cycle.
%
if (Initialization)
    PSDplatformManagerOpeningOrder = False
elif ((PSDmanagerOrder_A.Order(k) == Open_PSD_Configuration)
        or (PSDmanagerOrder_B.Order(k) == Open_PSD_Configuration))
    PSDplatformManagerOpeningOrder = True
else:
    PSDplatformManagerOpeningOrder = False
#
@
PSDopeningCommand，本ATP或者冗余端ATP当前是否在发送开PSD命令.
$
ATP shall determine whether itself or the redundant ATP opening the PSD in this cycle.
%
if ((PSDplatformManagerOpeningOrder(k) == True)
    or (OtherATP.PsdManagerOpeningOrder(k) == True))
    PSDopeningCommand = True
else:
    PSDopeningCommand = False
#
@
在与联锁通信时，如果PSDmanagerOrder_A.Id有效，则根据PSDmanagerOrder_A.Order和离线配置数据设置发送给A侧屏蔽门的控制信息CIsetting[0]。
$
When communicating with the CI, if the PSDmanagerOrder_A which comes from CCNV was valid, ATP shall set the CIsetting[0] according to the PSDmanagerOrder_A and the configuration of the PSD.
%
if ((CommunicateWithPSD(k) == True)
     and (PSDmanagerOrder_A.Id != None))
    CIsetting[0].PlatformId = PSDmanagerOrder_A.Id
    if (PSDmanagerOrder_A.Order == Open_PSD_Configuration)
        CIsetting[0].Order = TrackMap.PSDs[PSDmanagerOrder_A.Id].DoorOpeningCode
    elif (PSDmanagerOrder_A.Order == Close_PSD_Configuration):
        CIsetting[0].Order = TrackMap.PSDs[PSDmanagerOrder_A.Id].DoorClosingCode
    else:
        CIsetting[0].Order = TrackMap.PSDs[PSDmanagerOrder_A.Id].DoorNoActionCode
else:
    CIsetting[0].PlatformId = None
    CIsetting[0].Order = None
#
@
在与联锁通信时，如果PSDmanagerOrder_B.Id有效，则根据PSDmanagerOrder_B.Order和离线配置数据设置发送给B侧屏蔽门的控制信息CIsetting [1]。
$
When communicating with the CI, if the PSDmanagerOrder_B, which comes from CCNV, was valid, ATP shall set the CIsetting[1] according to the PSDmanagerOrder_B and the configuration of the PSD.
%
if ((CommunicateWithPSD(k) == True)
     and (PSDmanagerOrder_B.Id != None)):
    CIsetting[1].PlatformId = PSDmanagerOrder_B.Id
    if (PSDmanagerOrder_B.Order == Open_PSD_Configuration)
        CIsetting[1].Order = TrackMap.PSDs[PSDmanagerOrder_B.Id].DoorOpeningCode
    elif (PSDmanagerOrder_B.Order == Close_PSD_Configuration):
        CIsetting[1].Order = TrackMap.PSDs[PSDmanagerOrder_B.Id].DoorClosingCode
    else:
        CIsetting[1].Order = TrackMap.PSDs[PSDmanagerOrder_B.Id].DoorNoActionCode
else:
    CIsetting[1].PlatformId = None
    CIsetting[1].Order = None
#
@
AllTrainDoorsClosedAndLocked，两端车头有任意一端采到TDCL，即认为两侧车门关闭并锁闭。
$
The AllTrainDoorsClosedAndLocked stands for the condition that either side of both train ends collect TDCL, i.e. both side of door is closed and locked.
%
def AllTrainDoorsClosedAndLocked(k):
    return Offline.GetAllTrainDoorsClosedAndLocked(k)
#
@
InhibitControlTrainDoorsStatus，不监控车门状态.
$
ATP shall not monitor the status of train doors when 
InhibitControlTrainDoorsStatus is selected.
%
def InhibitControlTrainDoorsStatus(k):
    return Offline.GetInhibitControlTrainDoorsStatus(k) 
#
@
NoDangerForTrainDoorsNotClosedAndLocked，当列车停车，且与PSD区或VPEZ有交集时，且TDCL丢失，则该值为假；否则，该值为真。
%
def NoDangerForTrainDoorsNotClosedAndLocked(k):
    return not (TrainFilteredStopped(k)
                 and not AllTrainDoorsClosedAndLocked(k)
                 and (AlignPSDzone_A(k) or AlignPSDzone_B(k)
                      or TrainInterVPEZ_A(k) or TrainInterVPEZ_B(k)))
#
@
PBforTrainDoorsNotClosedAndLocked，列车停车，且车身与PSD区或VPEZ区域有交集时，车门未关时保持PB输出。
$
If the train is aligning in a PSD or intersecting with a vital passage exchange zone, and the RMF or RMR does not selected, ATP shall keep triggering parking brake when the train doors does not closed and locked.
%
def PBforTrainDoorsNotClosedAndLocked(k):
     return (not NoDangerForTrainDoorsNotClosedAndLocked(k)
              and not InhibitControlTrainDoorsStatus(k))
#
@
EBforPBnotAppliedDueToTrainDoors，由于车门开而输出ZVRD，但未检测到ZVBA, 则ATP应当输出EB.
$
If ATP has triggered parking brake for train doors opening, but it does not applied by the rolling stock, ATP shall trigger the emergency brake.
%
EBforPBnotAppliedDueToTrainDoors(k)
 = ((PBforTrainDoorsNotClosedAndLocked(k) == True)
   and (TrainParkingBrakeApplied(k) != True))
#
@
NoDangerForDepartureWithoutTDCL，判断是否未处于上周期停车而本周期开始动车，且车门未关的条件。
$
ATP shall determine whether the train is departure without TDCL.
%
def NoDangerForDepartureWithoutTDCL(k):
    return (AllTrainDoorsClosedAndLocked(k)
            or TrainFilteredStopped(k)
            or not TrainFilteredStopped(k-1))
#
@
EBforDepartureWithoutTDCL，若ATP监控发车时丢失TDCL的情况，则输出EB。
$
If ATP needs to monitor the status of train doors, ATP shall trigger EB if train determine without TDCL:
%
def EBforDepartureWithoutTDCL(k):
    return (not NoDangerForDepartureWithoutTDCL(k)
            and not InhibitControlTrainDoorsStatus(k))
#
@
InhibitProtectionMovingWithoutTDCL，禁止监控非开门授权情况下车门打开的情形。
$
ATP shall not monitor the status of train doors open without door opening enable if InhibitProtectionMovingWithoutTDCL is selected.
%
def InhibitProtectionMovingWithoutTDCL(k):
    return Offline.GetInhibitProtectionMovingWithoutTDCL(k) 
#
@
NoDangerForMovingWithoutTDCL，监控非授权开门状态下车门打开
%
def NoDangerForMovingWithoutTDCL(k):
    return (AllTrainDoorsClosedAndLocked(k)
            or TrainFilteredStopped(k)
            or EnableDoorOpening_A(k)
            or EnableDoorOpening_B(k))
#
@
EBforMovingWithoutTDCL，禁止监控非开门授权情况下车门打开的情形。
%
def EBforMovingWithoutTDCL(k):
    return (not NoDangerForMovingWithoutTDCL(k)
            and not InhibitProtectionMovingWithoutTDCL(k))
#
@
InhibitControlPSDstatus，项目可配置不监控PSD状态的条件。
$
The conditions ATP does not control PSD can be configured by project.
%
def InhibitControlPSDstatus(k):
    return Offline.GetInhibitControlPSDstatus(k) 
#
@
AllPSDclosedAndLocked的判断，上周期或本周期停车，若有PSD且已获取其状态为关闭。
$
If the train stopped or just started moving, and the status of all aligned PSD are closed, ATP shall consider the AllPSDclosedAndLocked is True.
%
AllPSDclosedAndLocked(k)
 = ((TrainLocalized(k) == True)
    and ((TrainFilteredStopped(k) == True)
          or (TrainFilteredStopped(k-1) == True))
    and ((PSDid_A(k) == 0) and (PSDid_B(k) == 0))
          or ((PSDid_A(k) != 0) and (PSDzoneStatus_A.AllPSDclosed(k) == True)
               and (PSDid_B(k) == 0))
          or ((PSDid_B(k) != 0) and (PSDzoneStatus_B.AllPSDclosed(k) == True)
               and (PSDid_A(k) == 0))
          or ((PSDid_A(k) != 0) and (PSDzoneStatus_A.AllPSDclosed(k) == True)
               and (PSDid_B(k) != 0) and (PSDzoneStatus_B.AllPSDclosed(k) == True)))
#
@
NoDangerforUnexpectedPSDopening，判断在发车时是否PSD为开门状态.
$
ATP shall determine whether the train starts moving without the aligned PSD closed.
%
def NoDangerForUnexpectedPSDopening(k):
    return (not (AlignPSDzone_A(k) or AlignPSDzone_B(k))
            or AllPSDclosedAndLocked(k)
            or TrainFilteredStopped(k)
            or not TrainFilteredStopped(k-1))
#
@
EBforUnexpectedPSDopening，PSD区域内刚发车时PSD门开，则输出EB.
$
If in charge of the PSD control, ATP shall trigger emergency brake when train just started moving but PSD does not closed.
%
def EBforUnexpectedPSDopening(k):
    return (not NoDangerForUnexpectedPSDopening(k)
            and not InhibitControlPSDstatus(k))
#
@
NoDangerForPSDnotClosedAndLocked，列车停在PSD区域，且PSD状态为限制时，该值为假；否则，该值为真。
%
def NoDangerForPSDnotClosedAndLocked(k):
    return not (TrainFilteredStopped(k)
                 and not AllPSDclosedAndLocked(k)
                 and (AlignPSDzone_A(k) or AlignPSDzone_B(k))
#
@
PBforPSDnotClosedAndLocked，车停在PSD区域内，PSD开，且未限制监控该功能时，要求输出ZVRD。
$
If one of the statuses of the aligned PSD does not closed when train stopped, ATP shall trigger parking brake.
%
def PBforPSDnotClosedAndLocked(k):
    return (not NoDangerForPSDnotClosedAndLocked(k)
     and not InhibitControlPSDstatus(k))
#
@
EBforPBnotAppliedDueToPSD，由于PSD开而施加PB，但是未采到ZVBA。
$
If ATP has triggered the parking brake for the PSD opening, but it does not applied by the rolling stock, ATP shall trigger the emergency brake.
%
EBforPBnotAppliedDueToPSD(k)
 = ((PBforPSDnotClosedAndLocked(k) == True)
    and (TrainParkingBrakeApplied(k) != True))
#
@
InhibitPSDopeningSupervisedByATP，是否禁止ATP监控发送屏蔽门开启指令时输出PB。
%
def InhibitPSDopeningSupervisedByATP(k):
    return Offline.GetInhibitPSDopeningSupervisedByATP(k)
#
@
PBforPSDopenedAndSupervisedByATP，在PSD开门过程中输出PB
$
If ATP needs to supervise the PSD opening status, ATP shall trigger parking brake when the PSD opening command is valid.
%
def PBforPSDopenedAndSupervisedByATP(k):
    return (PSDopeningCommandValid(k)
            and not InhibitPSDopeningSupervisedByATP) 
#
@
EmergencyHandleNotPulledEnd1，END_1逃生门未开。如果该项目未配置驾驶室的逃生门，则认为该逃生门未开。其状态来自于项目可配置的列车输入采集。
$
EmergencyHandleNotPulledEnd1 stands for the closed emergency door of END_1. If the train does not allocate with emergency door in the cab, it is certain that the emergency door does not opened. 
%
def EmergencyHandleNotPulledEnd1(k):
    return Offline.GetEmergencyHandleNotPulledEnd1(k)
#
@
EmergencyHandleNotPulledEnd2，End_2逃生门未开。如果该项目未配置驾驶室的逃生门，则认为该逃生门未开。其状态来自于项目可配置的列车输入采集。
$
EmergencyHandleNotPulledEnd2 stands for the closed emergency door of End2. If the train does not allocate with emergency door in the cab, it is certain that the emergency door does not opened. 
%
def EmergencyHandleNotPulledEnd2(k):
    return Offline.GetEmergencyHandleNotPulledEnd2(k)
#
@
HoldDoorsClosedTrainEnd1，未拉END_1端驾驶室的逃生门紧急手柄，或者车在运动时，锁闭END_1端逃生门。
$
ATP shall keep hold the train END_1 door closed when one of the following conditions fulfilled:Train kinematics is valid and the train does not stop;Or the emergency handle of END_1 is not pulled;
%
HoldDoorsClosedTrainEnd1(k)
 = ((ValidTrainKinematic(k) and (not TrainFilteredStopped(k)))
     or EmergencyHandleNotPulledEnd1(k))
#
@
HoldDoorsClosedTrainEnd2，未拉END_2端驾驶室的逃生门紧急手柄，或者车在运动时，锁闭END_2端逃生门。
$
ATP shall keep hold the train END_2 door closed when one of the following conditions fulfilled:Train kinematics is valid and the train does not stop;Or the emergency handle of END_2 is not pulled;
%
HoldDoorsClosedTrainEnd2(k)
 = ((ValidTrainKinematic(k) and (not TrainFilteredStopped(k)))
    or EmergencyHandleNotPulledEnd2(k))
#
@
EBforNotAllTrainEndHoldDoorsClosed，驾驶室逃生门手柄拉下.
$
If ATP does not hold the train end door, then trigger emergency brake.
%
EBforNotAllTrainEndHoldDoorsClosed(k)
 = (not HoldDoorsClosedTrainEnd1(k)
     or not HoldDoorsClosedTrainEnd2(k))
#
@
EmergencyDetrainDoorLockingEnd1，要求车辆锁闭End1端驾驶室的紧急逃生门。
%
def EmergencyDetrainDoorLockingEnd1(k):
    return (HoldDoorsClosedTrainEnd1(k)
            or InhibitEmergencyBrake(k-1))
#
@
EmergencyDetrainDoorLockingEnd2，要求车辆锁闭End2端驾驶室的紧急逃生门。
%
def EmergencyDetrainDoorLockingEnd2(k):
    return (HoldDoorsClosedTrainEnd2(k)
            or InhibitEmergencyBrake(k-1))
#
@
HoldDoorsClosed_A，A侧车门锁闭.
$
The conditions ATP determining the HoldDoorsClosed_A show as following ARDL:
%
if (Initialization
     or (ValidTrainKinematic(k) != True))
    HoldDoorsClosed_A = False
elif (TrainMaxSpeed(k) > ATPsetting.DoorTrainLockingSpeed)
    HoldDoorsClosed_A = True
elif (TrainMaxSpeed(k) <= ATPsetting.DoorTrainUnlockingSpeed)
    HoldDoorsClosed_A(k)
      = ((EvacuationNotPossible_A(k) and (not EvacuationNotPossible_B(k)))
         or (EvacuationNotPossible_A(k) and EvacuationNotPossible_B(k)
              and ATPsetting.EvacuationTrainEnd))
else:
    HoldDoorsClosed_A = HoldDoorsClosed_A(k-1)
#
@
HoldDoorsClosed_B，B侧车门锁闭
$
The conditions ATP determining the HoldDoorsClosed_B show as following ARDL :
%
if (Initialization
     or (ValidTrainKinematic(k) != True))
    HoldDoorsClosed_B = False
elif (TrainMaxSpeed(k) > ATPsetting.DoorTrainLockingSpeed)
    HoldDoorsClosed_B = True
elif (TrainMaxSpeed(k) <= ATPsetting.DoorTrainUnlockingSpeed)
    HoldDoorsClosed_B(k)
      = ((EvacuationNotPossible_B(k) and (not EvacuationNotPossible_A(k)))
         or (EvacuationNotPossible_A(k) and EvacuationNotPossible_B(k)
              and ATPsetting.EvacuationTrainEnd))
else:
    HoldDoorsClosed_B = HoldDoorsClosed_B(k-1)
#
@
TrainDockedInStation，根据开门授权条件判断是否车停在站内。
$
ATP shall determine whether the train has docked in the station correctly according to conditions of train stopping and doors opening enable.
%
def TrainDockedInStation(k):
    return (TrainFilteredStopped(k)
             and (EnableDoorOpening_A(k)
                  or EnableDoorOpening_B(k)))
#
@
TrainLeavingStation，判断是否在离站过程中。从TrainDockedInStation由True变为False开始，如果列车测速有效，累加MaximumTrainMotion距离：如果其绝对值在[0, ATPsetting.EvacuationStationAreaLength]范围内，则设置TrainLeavingStation为True；否则为False。即如果列车出站后又倒车回到上述范围内，也应认为是TrainLeavingStation。如果列车运动学无效，则设置该值为False并清除累加距离。
$
The train is said to be leaving the station:if since last time train has been detected docked in station (TrainDockedInStation), the cumulated of the absolute value of MaximumTrainMotion is in the range [0,ATPsetting.EvacuationStationAreaLength] and no train kinematic invalidation occurs. or else, if the train kinematics is invalid, ATP shall set TrainLeavingStation as False and clear the cumulated distance.
%
def TrainLeavingStation(k):
    if (Initialization
        or not ValidTrainKinematic(k)):
        TrainHasDockedInStation = False
        LeavingStationDistance = 0
        return False
    elif (TrainDockedInStation(k)):
        TrainHasDockedInStation = True
        LeavingStationDistance = 0
        return False
    elif (not TrainHasDockedInStation(k)):
        LeavingStationDistance = 0
        return False
    else:
        LeavingStationDistance = LeavingStationDistance(k-1) + MaximumTrainMotion(k)
        return (abs(LeavingStationDistance) <= ATPsetting.EvacuationStationAreaLength)
#
@
EmergencyHandleNotPulledSide侧向的紧急手柄未落下。其状态来自于项目可配置的列车输入采集。
$
EmergencyHandleNotPulledSid shows that the emergency handles is not pulled down.
%
def EmergencyHandleNotPulledSide(k):
    return Offline.GetEmergencyHandleNotPulledSide(k)
#
@
EvacuationWhileLeavingStation，未完全出站时丢失车门状态则EB.
$
If the train is just leaving the station and the side doors emergency handles are pulled, ATP shall require EvacuationWhileLeavingStation.
%
EvacuationWhileLeavingStation(k)
 = ((EmergencyHandleNotPulledSide(k) != True)
    and (TrainLeavingStation(k) == True)
    and (TrainFilteredStopped(k) != True))
#
@
EvacuationWithTrainStopped，非开门区，停车且乘客紧急手柄拉下
$
If the train does not stop on the doors opening enable area and the side doors emergency handles pulled, ATP shall require EvacuationWithTrainStopped.
%
EvacuationWithTrainStopped(k)
 = ((EmergencyHandleNotPulledSide(k) != True)
    and (TrainFilteredStopped(k) == True)
    and not EnableDoorOpening_A(k)
    and not EnableDoorOpening_B(k))
#
@
InhibitProtectionEvacuationInDistance，在离站时禁止监控逃生手柄状态
%
def InhibitProtectionEvacuationInDistance(k):
    return Offline.GetInhibitProtectionEvacuationInDistance(k)
#
@
InhibitProtectionEvacuationWithStop，在站间停车时禁止监控逃生手柄状态。
%
def InhibitProtectionEvacuationWithStop(k):
    return Offline.GetInhibitProtectionEvacuationWithStop(k)
#
@
EBforEvacuationWhileTrainLeavingStation，出站时的逃生请求EB.
$
If the train leaving station evacuation has been required, ATP shall trigger the emergency brake.
%
def EBforEvacuationWhileTrainLeavingStation(k):
    return (EvacuationWhileLeavingStation(k)
             and not InhibitProtectionEvacuationInDistance(k))
#
@
EBforEvacuationWithTrainStopped，站间停车时的逃生请求EB.
$
If the train stopped evacuation has been required, ATP shall trigger the emergency brake.
%
def EBforEvacuationWithTrainStopped(k):
    return (EvacuationWithTrainStopped(k)
              and not InhibitProtectionEvacuationWithStop(k))
#
@
PBforOperationalRequest，来自CCNV的ZVRD输出请求
$
PBforOperationalRequest stands for the ZVRD output order from CCNV.
%
if (ATOcontrolTimeValid(k) == True)
    PBforOperationalRequest(k)
       = not NonVitalRequest.VitalParkingBrakingNotRequested(k)
else:
     PBforOperationalRequest = True
#
@
TrainParkingBrakeRequested，判断本周期是否需要施加停车制动。条件如下：由于moral time 导致需要输出停车制动；或者，由于超能导致需要输出
停车制动；或者，由于在PSD区域内车门未关闭而导致需要输出停车制动；或者，由于NUDE导致需要输出停车制动；或者，CCNV请求需要输出停车制动；或者，由于PSD未关闭而导致需要输出停车制动。或者，本周期已请求EB输出。
$
TrainParkingBrakeRequested, determine whether to apply parking brake. This variable shall be True when one of the following conditions met:Train is in front of a possibly non-exclusive route,Synthesis of speed constraints on the train implies that it is not allowed to move anymore. Any movement may lead to an hazardous situation,Train is located on a passenger exchange area with PSD and train doors are not proven closed and locked,Train is located on a passenger exchange area with PSD and PSD are not proven closed and locked,There is a possibility of undetectable dangers,An operational parking brake is requested,The PSD are opened and are under the supervision of ATP,The EB has been requested in this cycle.
%
TrainParkingBrakeRequested = (PBonNonExclusiveRoute(k)
                                    or PBforOverEnergy(k)
                                    or PBforTrainDoorsNotClosedAndLocked(k)
                                    or PBforPSDnotClosedAndLocked(k)
                                    or PBforUndetectableDangerRisk(k)
                                    or PBforOperationalRequest(k)
                                    or PBforPSDopenedAndSupervisedByATP(k)
                                    or not InhibitEmergencyBrake(k))
#
@
InhibitParkingBrake，当前不施加停车制动。
$
InhibitParkingBrake，ATP software do not apply the parking brake.
%
InhibitParkingBrake = not TrainParkingBrakeRequested(k)
#
@
IncompatibleDistantATP，判断本ATP与冗余ATP之间的Coreld和SubSystemID是否相匹配。当初始化，冗余ATP信息不可用，或者冗余ATP读取的Dataplug中的SSID与本ATP相一致而Coreld不一致时，认为两端ATP相互匹配；否则，ATP将触发紧急制动。
$
The Coreld and SubSystemID of the ATP and redundant ATP need to compare for the consistency, which records in IncompatibleDistantATP. In initialization, the message from redundant ATP cannot be used. On the other hand, when SubSystemID in the Dataplug read by redundant ATP is the same, but the Coreld is different, both ATP regards as consistency. Otherwise, ATP would trigger emergency brake. 
%
def IncompatibleDistantATP(k):
    if (Initialization
        or not OtherATPmessageValid(k)):
        return False
    elif (OtherCoreId(k) != OtherATP(k).CoreId
          or SubSystemId(k) != OtherATP(k).CC_SSID):
        return True
    else:
        return IncompatibleDistantATP(k-1)
#
@
EBforOperationalRequest，来自CCNV的EB输出请求
$
ATP shall trigger emergency brake according to CCNV‘s operational emergency brake request.
%
if (ATOcontrolTimeValid(k) == True)
    EBforOperationalRequest(k) = not NonVitalRequest.EmergencyBrakingNotRequested(k)
else:
    EBforOperationalRequest = True
#
@
TrainEmergencyBrakeRequested，判断本周期是否需要施加EB。
$
ATP shall control emergency brake output according following emergency braking requests from control functions:moral-time control function has detected an hazardous situation (route exclusivity violation);train speed is no longer compliant with respect of whole speed restriction of guide way;an approachable speed limit has been over-run (RM speed limit or memorized location speed limit);an over-speed in reverse direction of travel has been detected;an emergency evacuation is required for passengers;train departure with not all doors closed and locked has been detected;the train starts to move on a PSD zone which status is not "all PSD proven closed and locked";train has moved although there are potential undetectable dangers;an operational emergency braking has been requested by CC-Non Vital;train end doors are not closed and locked; not all doors closed and locked has been
detected on a PSD zone and parking brake is not applied, not all PSD closed and locked has been detected on a PSD zone and parking brake is not applied;the approachable signal is overrun;the VLE-2 safe timer failed;the information of Dataplug in both ends of cab is inconsistent.
%
TrainEmergencyBrakeRequested(k)
 = EBonNonExclusiveRoute(k)
   or EBforOverEnergy(k)
   or EBforRMoverSpeed(k)
   or EBforMemorizedLocationOverSpeed(k)
   or EBforRollbackOverSpeed(k)
   or EBforReverseOverSpeed(k)
   or EBforEvacuationWhileTrainLeavingStation(k)
   or EBforEvacuationWithTrainStopped(k)
   or EBforDepartureWithoutTDCL(k)
   or EBforMovingWithoutTDCL(k)
   or EBforUnexpectedPSDopening(k)
   or EBforUndetectableDangerRisk(k)
   or EBforOperationalRequest(k)
   or EBforNotAllTrainEndHoldDoorsClosed(k)
   or EBforPBnotAppliedDueToTrainDoors(k)
   or EBforPBnotAppliedDueToPSD(k)
   or ApproachableSignalOverrun(k)
   or SafeTimerFailed(k)
   or IncompatibleDistantATP(k)
#
@
InhibitEmergencyBrake，输出和缓解EB的条件
$
If an emergency braking request ordered by a control function, ATP shall not inhibit emergency brake until train filtered-stop reached. ATP shall inhibit emergency brake if and only if train detected at filtered stop and there is no emergency braking request from control functions.
%
if (InhibitEmergencyBrake(k-1) == True)
    InhibitEmergencyBrake = not TrainEmergencyBrakeRequested(k)
elif ((InhibitEmergencyBrake(k-1) == False)
         and (TrainFilteredStopped(k) == True))
    InhibitEmergencyBrake = not TrainEmergencyBrakeRequested(k)
else:
    InhibitEmergencyBrake = InhibitEmergencyBrake(k-1)
#
@
CCworkOvertime，监控CC是否连续工作超过MAX_RESET_TIME时间(该时间小于MAX_ATP_LOOP_HOUR)。如果CC运行超过MAX_RESET_TIME时间，则ATP需将所有对VIOM输出的端口置为限制状态。
$
ATP shall monitor the CC continuous work time. If the CC is running more than MAX_RESET_TIME (the value is far less than MAX_ATP_LOOP_HOUR), the ATP shall set all output to VIOM as restricted status.
%
def CCworkOvertime(k):
    return ((CoreId(k) is END_1
             and ((ATPtime(k) - CC1_INIT_TIME) > MAX_RESET_TIME))
            or (CoreId(k) is END_2
                and ((ATPtime(k) - CC2_INIT_TIME) > MAX_RESET_TIME)))
#
@
VIOM1OutNotDisabled，VIOM2OutNotDisabled，CCNV请求“非禁止安全输出”。当来自CCNV的消息无效时，应设置CCNV请求的“非禁止安全输出”为限制状态；否则，根据CCNV发送的状态字进行设置。
$
Whether CCNV request the channel of VIOM shall be disabled or not.
%
def VIOM1OutNotDisabled(port, k):
    return (ATOcontrolTimeValid(k)
            and NonVitalRequest(k).Viom1[port])
def VIOM2OutNotDisabled(port, k):
    return (ATOcontrolTimeValid(k)
            and NonVitalRequest(k).Viom2[port])
#
@
VIOM1VitalOut，VIOM2VitalOut，ATP输出给VIOM的车辆安全控制命令。
对于每一个端口的具体含义，是由项目配置的。ATP支持的可配置端口如Table 514所示。只有当CC未工作超时且CCNV未禁止该端口输出时，才能根据ATP计算结果输出该端口；否则，ATP默认该端口为限制状态。
%
def VIOM1VitalOut(k):     
    for port in range(0, MAX_VITAL_OUTPUT_NB):
        if (not CCworkOvertime(k)
            and not MatchRebootCondition(k) 
            and VIOM1OutNotDisabled(k)[port]):
            VIOM1VitalOut[port] = Offline.GetVIOM1VitalOut(port)
        else:
            VIOM1VitalOut[port] = False
    return VIOM1VitalOut
def VIOM2VitalOut(k):
    for port in range(0, MAX_VITAL_OUTPUT_NB):
        if (not CCworkOvertime(k)
            and not MatchRebootCondition(k)
            and VIOM2OutNotDisabled(k)[port]):
            VIOM2VitalOut[port] = Offline.GetVIOM2VitalOut(port)
        else:
            VIOM2VitalOut[port] = False
    return VIOM2VitalOut
#
@
TrainHeadMinLocation，车头最小定位位置。根据[REF5]，在LocReport中的坐标单位为0.5米，因此需进行单位转换。转换时应当向列车的“后方”即上游方向取整。如果列车失位，则设置相关定位信息为无效值；否则，如果列车向UP方向运行，则：车头最小定位所在BLOCK号不变；车头最小定位所在坐标以0.5米为单位向下取整；车头方向为LOCREPORT_DIRECTION_UP。
否则，如果车头最小定位坐标加0.5米小于该BLOCK长度，则：车头最小定位所在BLOCK号不变；车头最小定位所在坐标以0.5米为单位向上取整；车头方向为LOCREPORT_DIRECTION_DOWN。否则，如果车头最小定位所在BLOCK，与该BLOCK的UP方向下个BLOCK之间存在灯泡线极点，则：车头最小定位所在BLOCK需改为其UP方向的下个BLOCK；车头最小定位所在坐标为下个BLOCK长度以0.5米为单位向下取整；车头方向为LOCREPORT_DIRECTION_UP。否则：车头最小定位所在BLOCK需改为其UP方向的下个BLOCK；车头最小定位所在坐标为0；车头方向为LOCREPORT_DIRECTION_DOWN。
$
ATP shall send the minimum head location of the active cab to the ZC, including the block id and its abscissa. According to [REF5], the unit of the abscissa in Location Report is 0.5 meter, so the ATP needs to convert its internal unit to match that. The conversion shall be safety-oriented, which means the envelope of the train location tend to be "stretched" to the both ends. The rules of conversion are as following ARDL:
%
def TrainHeadMinLocation(k):
    if (not TrainLocalized(k)):
        TrainHeadMinLocation.Block = 0
        TrainHeadMinLocation.Abscissa= 0
        TrainHeadOrientation = LOCREPORT_DIRECTION_UNKNOWN
    elif (TrainFrontLocation(k).Min.Ort is UP):
        TrainHeadMinLocation.Block = TrainFrontLocation(k).Min.Block(k)
        TrainHeadMinLocation.Abscissa = (round.floor(TrainFrontLocation(k).Min.Abscissa(k)
                                                              / ABSCISSA_TO_HALF_METER))
        TrainHeadOrientation = LOCREPORT_DIRECTION_UP
    elif (TrainFrontLocation(k).Min.Abscissa(k) + ABSCISSA_TO_HALF_METER
          <= TrackMap.Blocks[TrainFrontLocation(k).Min.Block].Length):
        TrainHeadMinLocation.Block = TrainFrontLocation(k).Min.Block(k)
        TrainHeadMinLocation.Abscissa = round.ceil(TrainFrontLocation(k).Min.Abscissa(k)
                                                            / ABSCISSA_TO_HALF_METER)
        TrainHeadOrientation = LOCREPORT_DIRECTION_DOWN
    else:
        NextBlock = TrackMap.NextBlock(TrackMap.Blocks[TrainFrontLocation(k).Min.Block], UP)
        if TrackMap.ExistThePole(TrainFrontLocation(k).Min.Block, NextBlock.Id):
            TrainHeadMinLocation.Block = NextBlock.Id
            TrainHeadMinLocation.Abscissa = round.floor(NextBlock.Length
                                                                / ABSCISSA_TO_HALF_METER)
            TrainHeadOrientation = LOCREPORT_DIRECTION_UP
        else:
            TrainHeadMinLocation.Block = NextBlock.Id
            TrainHeadMinLocation.Abscissa = 0
            TrainHeadOrientation = LOCREPORT_DIRECTION_DOWN
    return TrainHeadMinLocation
#
@
TrainHeadCoupledStatus，车头连挂状态。
$
ATP shall send the coupled status of the active train cab to the ZC.
%
def TrainHeadCoupledStatus(k):
    if (TrainFrontEnd(k) is END_1):
        return ((TrainCoupledType(k) is TRAIN_NOT_COUPLED)
                or (TrainCoupledType(k) is TRAIN_COUPLED_END2))
    else:
        return ((TrainCoupledType(k) is TRAIN_NOT_COUPLED)
                or (TrainCoupledType(k) is TRAIN_COUPLED_END1))
#
@
TrainTailCabId，车尾ID号。
$
ATP shall send the current inactive cab id to the ZC.
%
def TrainTailCabId(k):
    if (TrainFrontEnd(k) is END_1):
        return END_2
    else:
        return END_1
#
@
TrainTailMinLocation，车尾最小定位所在位置。根据[REF5]，在LocReport中的坐标单位为0.5米，因此需进行单位转换。转换时应当导向ZC处理的安全侧，偏向将列车包络定位“拉长”，即向列车的上游方向取整。如果列车失位，设置上述定位信息为0；否则，如果列车车尾朝DOWN方向，则：车尾最小定位所在BLOCK号不变；车尾最小定位所在坐标以0.5米为单位向下取整；车尾方向为LOCREPORT_DIRECTION_DOWN。否则，如果车尾最小定位坐标加0.5米小于该BLOCK长度，则：车尾最小定位所在BLOCK号不变；车尾最小定位所在坐标以0.5米为单位向上取整；车尾方向为LOCREPORT_DIRECTION_UP。否则，如果车尾最小定位所在BLOCK找不到UP方向的下个BLOCK，则：车尾最小定位所在BLOCK号不变，车尾最小定位所在坐标以0.5米为单位向上取整（此时由于发送的坐标超过了Block长度，ZC会将本LocReport丢弃，不会影响安全）。车尾方向为LOCREPORT_DIRECTION_UP。否则，如果车尾最小定位所在BLOCK，与该BLOCK的UP方向下个BLOCK之间存在灯泡线极点，则：车尾最小定位所在BLOCK需改为其上行方向的下个BLOCK；车尾最小定位所在坐标为下游BLOCK长度以0.5米为单位向下取整；车尾方向为LOCREPORT_DIRECTION_DOWN。否则，车尾最小定位所在BLOCK需改为其上行方向的下个BLOCK；车尾最小定位所在坐标为0；车尾方向为LOCREPORT_DIRECTION_UP。
$
ATP shall send the minimum tail location of the active cab to the ZC, including the block id and its abscissa. According to [REF5], the unit of the abscissa in Location Report is 0.5 meter, so the ATP needs to convert its internal unit to match that. The convertion shall be safety-oriented, which means the envelope of the train location tend to be "stretched" to the both ends. The rules of convertion are as following ARDL:
%
 def TrainTailMinLocation(k):
    if (not TrainLocalized(k)):
        TrainTailMinLocation.Block = 0
        TrainTailMinLocation.Abscissa = 0
        TrainTailOrientation = LOCREPORT_DIRECTION_UNKOWN
    elif (TrainRearLocation(k).Min.Ort is DOWN):
        TrainTailMinLocation.Block = TrainRearLocation(k).Min.Block
        TrainTailMinLocation.Abscissa = (round.floor(TrainRearLocation(k).Min.Abscissa
                                                              / ABSCISSA_TO_HALF_METER))
        TrainTailOrientation = LOCREPORT_DIRECTION_DOWN
    elif (TrainRearLocation(k).Min.Abscissa + ABSCISSA_TO_HALF_METER
          <= TrackMap.Block[TrainRearLocation(k).Min.Block].Length):
        TrainTailMinLocation.Block = TrainRearLocation(k).Min.Block
        TrainTailMinLocation.Abscissa = round.ceil(TrainRearLocation(k).Min.Abscissa
                                                            / ABSCISSA_TO_HALF_METER)
        TrainTailOrientation = LOCREPORT_DIRECTION_UP
    else:
        NextBlock = TrackMap.NextBlock(TrackMap.Blocks[TrainRearLocation(k).Min.Block], UP)
        if (NextBlock is None):
            TrainTailMinLocation.Block = TrainFrontLocation(k).Min.Block
            TrainTailMinLocation.Abscissa = round.ceil(TrainRearLocation(k).Min.Abscissa
                                                                / ABSCISSA_TO_HALF_METER)
            TrainTailOrientation = LOCREPORT_DIRECTION_UP
        elif (TrackMap.ExistThePole(TrainRearLocation(k).Min.Block, NextBlock.Id)):
            TrainTailMinLocation.Block = NextBlock.Id
            TrainTailMinLocation.Abscissa = round.floor(NextBlock.Length
                                                                / ABSCISSA_TO_HALF_METER)
            TrainTailOrientation = LOCREPORT_DIRECTION_DOWN
        else:
            TrainTailMinLocation.Block = NextBlock.Id
            TrainTailMinLocation.Abscissa = 0
            TrainTailOrientation = LOCREPORT_DIRECTION_UP
    return TrainTailMinLocation
#
@
TrainTailCoupledStatus，车尾连挂状态。
$
ATP shall send the coupled status of the inactive train cab to the ZC.
%
def TrainTailCoupledStatus(k):
    if (TrainFrontEnd(k) is END_1):
        return ((TrainCoupledType(k) is TRAIN_NOT_COUPLED)
                or (TrainCoupledType(k) is TRAIN_COUPLED_END1))
    else:
        return ((TrainCoupledType(k) is TRAIN_NOT_COUPLED)
                or (TrainCoupledType(k) is TRAIN_COUPLED_END2))
#
@
LocationError，最大最小定位误差. 根据[REF5]，在LocReport中的长度单位是0.5米，因此需进行转换，转换时应当导向安全侧。
$
ATP shall send the location error to the ZC. According to [REF5], the unit of the location error in Location Report is 0.5 meter, so the ATP needs to convert its internal unit to match that. The convertion shall be safety-oriented, which means the location error tend to be "overestimated".
%
def LocationError(k):
    if TrainLocalized(k):
        return round.ceil((TrainLocation(k).Uncertainty + ABSCISSA_TO_HALF_METER)
                              / ABSCISSA_TO_HALF_METER)
    else:
        return 0
#
@
RouteSetNotNeededSendable，是否可以发送RSNN信息。其状态来自于项目可配置的列车输入采集。
$
According to the status of RouteSetNotNeededSendable, ATP can judge whether it is necessary to send RSNN information.
%
def RouteSetNotNeededSendable(k):
    return Offline.GetRouteSetNotNeededSendable()
#
@
NonVitalRouteSetNotNeeded，RSNN状态
$
Whether the CCNV request route set note needed.
%
def NonVitalRouteSetNotNeeded(k):
    return (ATOcontrolTimeValid(k)
            and NonVitalRequest.RouteSetNotNeeded(k))
#
@
TrainRouteSetNotNeeded，是否发送RSNN信息。
$
ATP shall send the route set not needed information to ZC.
%
def TrainRouteSetNotNeeded(k):
    return (TrainFilteredStopped(k)
            and NonVitalRouteSetNotNeeded(k)
            and RouteSetNotNeededSendable(k))
#
@
TrainCorrectDocking，列车是否正确停靠车站。
$
ATP shall send the docking correction information to the ZC.
%
def TrainCorrectDocking(k):
    return (EnableDoorOpening_A(k) or EnableDoorOpening_B(k))
#
@
LocReportSpeed，列车最大速度，需转换为CC-ZC接口协议中的单位，并向上取整。
$
ATP shall send the maximum train speed to the ZC. According to [REF5], the unit of the speed in Location Report is KPH, so the ATP needs to convert its internal unit to match that. The convertion shall be safety-oriented, which means the speed tend to be "overestimated".
%
def LocReportSpeed(k):
    return round.ceil(TrainMaxSpeed(k) / KMPH_TO_MMPS)
#
@
TrainMonitoringMode，监控模式.
$
ATP shall send the current monitoring mode to the ZC.
%
def TrainMonitoringMode(k):
    if (MotionProtectionInhibition(k)
         and RMRselectedDrivingMode(k)):
        return RMR
    elif (MotionProtectionInhibition(k)):
        return RMF
    else:
        return OTHERS
#
@
SignalOverrideSendable，发给ZC的关信号机命令。
%
def SignalOverrideSendable(k):
    return Offline.GetSignalOverrideSendable(k)
#
@
SignalsOverride，是否CBTC下取消信号。
$
ATP shall send the signal override information to the ZC.
%
def SignalsOverride(k):
    return (SignalOverrideSendable(k)
            and not MotionProtectionInhibition(k)
            and (ATOcontrolTimeValid(k)
                 and NonVitalRequest.CancelSignal))
#
@
ATCcontrolledTrain，ATP未被切除。
%
def ATCcontrolledTrain(k):
    return Offline.GetATCcontrolledTrain(k)
#
@
DateSynchronizationReceived，收到时钟同步消息
%
def DateSynchronizationReceived(lcId, k):
    return Message.Received(DateSynchronizationReport(lcId), k)
#
@
DateSynchronisationReportAvailable用于判断当前周期收到的LC安全时间消息是否可用。当满足以下条件时，设置DateSynchronisationReportAvailable为True。否则，设置DateSynchronisationReportAvailable为False。本周期收到来自LC的DateSynchronizationReport消息，并且校核字正确；如果收到LC消息是LC应答本端CC发出的消息，且满足以下条件时:当前ATP时间应大于消息中所带的ccLoopHour;并且当前ATP时间与消息中所带的ccLoopHour的差值应当小于之前ATP使用的LC消息时间。如果该消息是LC应答远端CC发出的消息，则应满足以下条件:当前ATP维护的远端ATP最小时间应大于消息中所带的ccLoopHour;并且当前ATP维护的远端ATP最大时间时间与消息中所带的ccLoopHour的差值，应当小于之前ATP使用的LC消息时间。
$
DateSynchronisationReportAvailable used to judge whether the LC synchronization message could use or not. When the below condition fulfilled, DateSynchronisationReportAvailable shall set as True. Otherwise, it set as False. If ATP Receives the DateSynchronizationReport message from LC, and the checksum is correct. And If the received message is LC to respond the local CC, ATP shall qualify with below conditions:The current ATP time is more than ccLoopHour in the messageThe different value between the current ATP time and the ccLoopHour  is less than the LC message time in the previous ATP.Or else:, If the received message is LC to respond the remote CC, and it should be qualified with below conditions:The minimum time in remote ATP maintained by current ATP is more than the ccLoopHour.The different value between maximum time in remote ATP maintained by current ATP and the ccLoopHour is less than the LC message time in the previous ATP.
%
def DateSynchronisationReportAvailable(lcId, k):
    return Message.Available(DateSynchronizationReceived(lcId, k),
                             DateSynchronizationReport(lcId).CcLoopHour,
                             ATPsetting.LCloophourValidityTime,
                             LastSynchronisationReportAge(lcId, k-1),
                             k)
#
@
LastSynchronisationReportAge，记录从上次收到LC消息到现在的时间。用于在新收到LC消息时，比较该“新”消息是否的确比之前的消息“新”。即防止在网络传输中发生消息逆序的情况。
$
LastSynchronisationReportAge records the age from previous LC message to current cycle. It used to compare whether the new received message is more updating than last recorded one, to prevent the inverse transition in the network communication.  
%
def LastSynchronisationReportAge(lcId, k):
    return Message.LastAge(DateSynchronisationReportAvailable(lcId, k),
                            DateSynchronizationReport(lcId).CcLoopHour,
                            LastSynchronisationReportAge(lcId, k-1),
                            k)
#
@
LCsynchronisationLoopHourValid，每周期更新LC消息是否还在有效期内。
$
LCsynchronisationLoopHourValid will check whether the LC message is still valid. 
%
def LCsynchronisationLoopHourValid(lcId, k):
    return Message.Valid(DateSynchronizationReport(lcId).CcLoopHour,
                         ATPsetting.LCloophourValidityTime,
                         k)
#
@
对于线路上的LC，ATP需要维护其时间信息GroundTimeReference，时间信息更新规则如下：LC消息无效时，设为默认值；本周期收到新的可用的LC消息时，更新为消息中的时间；否则根据车载和轨旁周期的比值进行累加更新
$
ATP shall estimate a time called GroundTimeReference for trackside equipment (ZC /LC). From power-up, GroundTimeReference shall consider invalid. The rules for time information are as follows:When LC message invalid, it is set as default value. When ATP receives an available LC message, it updates as the time of message. Otherwise, it updates the value according to the on board and track side cycle.
%
if (Initialization
     or LCsynchronisationLoopHourValid(LcId, k) != True)
    GroundTimeReference[LcId].Time = INVALID_LC_DATE
    GroundTimeReference[LcId].Milliseconds = 0
elif (DateSynchronisationReportAvailable(LcId, k))
    GroundTimeReference[LcId].Time(k)= DateSynchronizationReport.Synchrodate
    GroundTimeReference[LcId].Milliseconds = 0
else:
    GroundTimeReference[LcId].Time(k)
      = GroundTimeReference[LcId].Time(k-1)
       + ((GroundTimeReference[LcId].Milliseconds(k-1)+ ATP_CYCLE_TIME_MS)
           / SYNCHRODATE_TIME_UNIT_MS)
    GroundTimeReference[LcId].Milliseconds(k)
      = ((GroundTimeReference[LcId].Milliseconds(k-1)+ ATP_CYCLE_TIME_MS)
          % SYNCHRODATE_TIME_UNIT_MS)
#
@
EnableSendLocReport，当所对应的LC消息在有效期内时，才允许给ZC发送位置报告。
$
Before received the first valid synchronization from a LC, the corresponding LC vital time shall consider not significant, and the ATP shall prevent to send Location Report message to the ZC(s) associated to the corresponding LC.
%
def EnableSendLocReport(LcId, k):
    return LCsynchronisationLoopHourValid(LcId, k)
#
@
TimeElapseBetweenTwoLocReport，计算发送LocReport的时间控制：
$
ATP shall calculate when to send the Location Report as the following ARDL:
%
def TimeElapseBetweenTwoLocReport(k):
    if (Initialization
         or (TimeElapseBetweenTwoLocReport(k-1) == 1)):
        return round.floor(ATPsetting.LocReportEmissionPeriod)
    else:
        return TimeElapseBetweenTwoLocReport(k-1) - 1 
#
@
ZCidUnderTrainTail，车尾定位所在的ZC标识.
$
ATP shall record the ZC area id where the train tail located. If the train is not localized, ATP shall use the current receiving beacon where located, or the last known ZC area id.
%
def ZCidUnderTrainTail(k):
    if (Initialization):
        return 0
    elif (TrainLocalized(k)):
        return TrackMap.ZCId(TrainTailMinLocation(k).Block)
    elif (MemorizedLocationAvailable(k)):
        if (TrainFrontEnd(k) is END_1):
            return TrackMap.ZCId(MemLocation.Ext2.Block)
        else:
            return TrackMap.ZCId(MemLocation.Ext1.Block)
    elif (NewBeaconObtained(k)):
        return TrackMap.ZCId(BeaconLastObtained.Block)
    else:
        return ZCidUnderTrainTail(k-1)
#
@
ZCidUnderTrainHead，车头定位的ZC标识
$
ATP shall record the ZC area id where the train head located. If the train is not localized, ATP shall use the current receiving beacon where located, or the last known ZC area id.
%
def ZCidUnderTrainHead(k):
    if (Initialization)
        return 0
    elif (TrainLocalized(k)):
        return TrackMap.ZCId(TrainHeadMinLocation(k).Block)
    elif (MemorizedLocationAvailable(k)):
        if (TrainFrontEnd(k) is END_1):
            return TrackMap.ZCId(MemLocation.Ext1.Block)
        else:
            return TrackMap.ZCId(MemLocation.Ext2.Block)
    elif (NewBeaconObtained(k)):
        return TrackMap.ZCId(BeaconLastObtained.Block)
    else:
        return ZCidUnderTrainHead(k-1)
#
@
SendLocReportOnZCunderTrainTail，当距离上次发送LocReport到达既定时间，且车头和车尾不是同一个ZC时，要给车尾所在的ZC发送消息
$
When the time elapsed from last report is equal to the Location Report sending cycle, and the train tail located ZC is valid and not as same as the train head ZC, and the ZC train tail located authorized by the LC, ATP shall send the Location Report to this ZC where train tail located.
%
def SendLocReportOnZCunderTrainTail(k):
    return (((TimeElapseBetweenTwoLocReport(k) == 1)
             or (not MasterCCcore(k-1) and MasterCCcore(k)))
            and (ZCidUnderTrainTail(k) is not None)
            and (ZCidUnderTrainTail(k) != ZCidUnderTrainHead(k))
            and EnableSendLocReport(TrackMap.ZC[ZCidUnderTrainTail(k)].LcId, k)
            and (VersionAuthorizedByLC(ZCidUnderTrainTail(k), k)))
#
@
SendLocReportOnZCunderTrainHead，是否给车头的ZC区发LocReport。
$
When the time elapsed from last report is equal to the Location Report sending cycle, and the train head located ZC is valid, and the ZC train head located authorized by the LC, ATP shall send the Location Report to this ZC where train head located.
%
def SendLocReportOnZCunderTrainHead(k):
    return (((TimeElapseBetweenTwoLocReport(k) == 1)
             or (not MasterCCcore(k-1) and MasterCCcore(k)))
            and (ZCidUnderTrainHead(k) is not None)
            and EnableSendLocReport(TrackMap.ZC[ZCidUnderTrainHead(k)].LcId, k)
            and (VersionAuthorizedByLC(ZCidUnderTrainHead(k), k)))
#
@
CCvariantRequestMsgReceived，收到来自CI的CC变量请求并校核字正确。
%
def CCvariantRequestMsgReceived(cbiId, k):
    if (Initialization):
        return False
    elif (Message.Received(CCvariantRequest, k)):
        return True
    else:
        return CCvariantRequestMsgReceived(Cbi, k-1)
#
@
ReceivedCBIloopHour，记录CBI请求中的联锁的loop hour。
%
def ReceivedCBIloopHour(cbi, k):
    if (Initialization):
        return INVALID_LOOP_HOUR
    elif (CCvariantRequestMsgReceived(Cbi, k)):
        return CCvariantRequest(Cbi, k).CbiLoopHour
    else:
        return ReceivedCBIloopHour(Cbi, k-1)
#
@
CCvariants，ATP发送给联锁的Overlap解锁信息。
$
ATP shall check the following conditions when sending overlap release to CBI:
Train front location is in overlap release zone,and the other ATP's overlap timer has expired,and ATP received variant request from CBI in this zone.
%
def CCvariants(CbiId, k):
    Orz = TrackMap.ExistZoneLocationIncluded(SGL_OVERLAP_RELEASE_ZONE,
                                                     TrainFrontLocation(k).Max):
    if (OverlapReleasable(k)
        and OtherATP(k).OverlapExpired
        and CCvariantRequestMsgReceived(CbiId, k)
        and Orz is not None
        and Orz.CbiId == CbiId
        and CbiId == NonVitalRequest(k).VariantRequestCbiId):

        for Index in range(0, MAX_CC_VARIANTS_NB):
            if (Orz.RadioBlockModeVariantIndex == Index):
                CCvariants[CbiId].Variant[Index] = True
            else:
                CCvariants[CbiId].Variant[Index] = False
    else:
        CCvariants[CbiId] = None
    return CCvariants
#
@
定时中断被激活后，在每次中断中对ImmediateNb，CycleSynchronized，Trace，Dt和CycleBiasNb进行更新：如果当前是上电后第一个中断：ATP需设置ImmediateNb为0，并根据所在的CPU初始化Trace，VCP的时间标签Dt，以及中间变量m：否则，如果ImmediateNb = 0，而VitalTime与上个中断相比仍然未发生变化，则将CycleBiasNb加1。如果CycleBiasNb > 1，设置CycleSynchronized为False；否则，如果ImmediateNb = 0，而VitalTime与上个中断相比发生了变化，则令ImmediateNb = 1；令Trace = PDoperationDt(Trace，Bi[ImmediateNb], Dt),设置CycleBiasNb = 0，而且CycleSynchronized为True.使用LockedImmediateCounter锁存此时的ImmediateCounter值，作为新周期初始的中断号。否则，将ImmediateNb的值加1；令Trace = PDoperationDt(Trace, Bi[ImmediateNb], Dt)；如果ImmediateNb > (ATP_INTERRUPT_NB-1)，则设置ImmediateNb = 0；并令Trace = PDoperation(Trace，m)，令Dt = PDoperation(Dt, 0)
$
When the fixed-time interrupt triggered, ATP shall update the ImmediateNb，CycleSynchronized, Trace, Dt and CycleBiasNb. If it is the first interrupt after powered up, ATP shall set ImmediateNb as zero，and initialize the Trace, Dt (the dynamic time of VCP), and the middle variables m based on CPU. Or else:, If the ImmediateNb is zero, but the VitalTime has not changed comparing to the previous interrupt, then: Or else, If ImmediateNb is zero, and the VitalTime has changed comparing to the previous interrupt, then: Otherwise, set: and if the ImmediateNb is greater than (ATP_INTERRUPT_NB-1), then:
%
if (DataPlugContent.VLECpuId == CPU1)
    Dt = CPU1_DT_INIT
    Trace = CPU1_TRACE_0 ^ Dt
    m = InversePDoperation(CPU1_TRACE_0, CPU1_TRACE_N)
else:
    Dt = CPU2_DT_INIT
    Trace = CPU2_TRACE_0 ^ Dt
m = InversePDoperation(CPU2_TRACE_0, CPU2_TRACE_N)
if (DataPlugContent.VLECpuId == CPU1)
    Dt = CPU1_DT_INIT
    Trace = CPU1_TRACE_0 ^ Dt
    m = InversePDoperation(CPU1_TRACE_0, CPU1_TRACE_N)
else:
    Dt = CPU2_DT_INIT
    Trace = CPU2_TRACE_0 ^ Dt
    m = InversePDoperation(CPU2_TRACE_0, CPU2_TRACE_N)
CycleBiasNb = CycleBiasNb + 1
if (CycleBiasNb > 1)
    CycleSynchronized = False
ImmediateNb = 1
Trace = PDoperationDt(Trace，Bi[ImmediateNb], Dt)
CycleBiasNb = 0
CycleSynchronized = True
LockedImmediateCounter = ImmediateCounter
ImmediateNb = ImmediateNb + 1
Trace = PDoperationDt(Trace, Bi[ImmediateNb], Dt)
ImmediateNb = 0
Trace = PDoperation(Trace，m)
Dt = PDoperation(Dt, 0)
#
@
VitalTime，ATP主任务维护的当前周期序号。上电后从0开始，每周期递增加1。当主任务在执行完成本周期的所有工作后，监控中断任务是否执行完成，即ImmediateCounter和LockedImmediateCounter的差值是否大于等于（ATP_INTERRUPT_NB -1）：若是，则表明主周期执行完成：将VitalTime送给另一个CPU模块；将Trace(k)和Dt(k)作为校核字送给VIOM进行校验。在本周期最后，设置, 否则，继续等待。
$
The VitalTime stand for the current cycle of ATP deferred task. After power up, it starts from zero and increase one each cycle. When all the work is executed in the main task, ATP detects whether the interrupt task is over, i.e. the difference between ImmediateCounter and LockedImmediateCounter is equal to or larger than (ATP_INTERRUPT_NB -1). If it is so, it shows that the main task in this cycle finishes. Then ATP shall:send the VitalTime to the other CPU,and send Trace and Dt to VIOM to check,and at the end of this cycle, set. Otherwise, keep waiting.
%
VitalTime = VitalTime(k-1) + 1
#
@
RTCtime，ATP维护的非安全时钟：ATP软件在初始化时从VLE-2后板上获取RTC时钟信息；之后，ATP软件每秒钟将该RTC时钟加1；但如果RTC时钟与来自CCNV的NTP时间差超过MAX_NTP_TIME_ERROR，则使用NTP时间更新RTC时间。其中Time.Update()意为ATP软件每秒钟将RTC时间加1。
$
ATP software shall maintain the RTC time for non-vital functions.In initialization, ATP software get RTC time from VLE-2 board;And then, ATP software updates the RTC time every second;And if the difference between RTC time ATP used and the NTP time CCNV sent is greater than MAX_NTP_TIME_ERROR, ATP shall reset the RTC time as NTP time. The Time.Update() means ATP software shall update the RTC time every second.
%
if (Initialization)
    RTCtime = VLE_RTCtime
elif ((ATOcontrolTimeValid(k) == True)
        and (NonVitalRequest.NtpTime != None)
        and (|NonVitalRequest.NtpTime - RTCtime(k-1)| > MAX_NTP_TIME_ERROR))
    RTCtime = NonVitalRequest.NtpTime
else:
    RTCtime = Time.Update()
#
@
Message. ReplyLocalCC，判断该消息中的MessageLoopHour是否与本CC一致
%
def ReplyLocalCC(MessageLoopHour):
    if ((MessageLoopHour >= CC1_INIT_TIME
         and MessageLoopHour <= CC1_MAX_TIME
         and CoreId is END_1)
        or (MessageLoopHour >= CC2_INIT_TIME
            and MessageLoopHour <= CC2_MAX_TIME
            and CoreId is END_2)):
        return True
    else:
        return False
#
@
Message. ReplyDistantCC，判断该消息中的MessageLoopHour是否与远端CC一致
%
def ReplyDistantCC(MessageLoopHour):
    if ((MessageLoopHour >= CC1_INIT_TIME
         and MessageLoopHour <= CC1_MAX_TIME
         and OtherCoreId is END_1)
        or (MessageLoopHour >= CC2_INIT_TIME
            and MessageLoopHour <= CC2_MAX_TIME
            and OtherCoreId is END_2)):
        return True
    else:
        return False
#
@
Message. ModularSub，loop hour之间的模减,考虑到判断消息可用的算法，此处只需强制为严格大于才返回True因为在计算LastAge时是要+1的，若之前取等号,则加1后可能该消息已无效
%
def ModularSub(lh_1, lh_2):
    if ((ReplyLocalCC(lh_1) and ReplyLocalCC(lh_2))
        or (ReplyDistantCC(lh_1) and ReplyDistantCC(lh_2))):
        if (lh_1 - lh_2 < 0):
            return ((lh_1 - lh_2) + MAX_ATP_LOOP_HOUR)
        else:
            return (lh_1 - lh_2)
    else:
        raise LoopHourException
#
@
Message.IsMoreRecent，若两端都对应CC1或CC2，且lh_1 > lh_2，则返回True；否则返回False
%
def IsMoreRecent(lh_1, lh_2):    
    if ((ReplyLocalCC(lh_1) and ReplyLocalCC(lh_2))
        or ReplyDistantCC(lh_1) and ReplyDistantCC(lh_2)):
        return (ModularSub(lh_1, lh_2) > 0
                and ModularSub(lh_1, lh_2) < ATP_MESSAGE_MAX_DELAY)
    else:
        raise LoopHourException
#
@
Message.Received，收到消息并且校验正确
%
def Received(MessageContent, k):
    return (Exists(MessageContent, k)
            and VitalChecksumValid(MessageContent))
#
@
Message.Available，判断消息是否可用，即收到消息校验正确，且在有效期内，且比之前收到的更新;当收到一条ATPtime-MessageLoopHour恰好等于MessageValidityTime的消息不应认为有效;否则计算本周期LastAge就将大于消息有效期
%
def Available(MessageReceived, MessageLoopHour, MessageValidityTime, LastMessageAge, k):
    if (MessageReceived
        and ((ReplyLocalCC(MessageLoopHour)
              and IsMoreRecent(ATPtime(k), MessageLoopHour)
              and IsMoreRecent(MessageLoopHour + MessageValidityTime, ATPtime(k))
              and (ModularSub(ATPtime(k) - MessageLoopHour) < LastMessageAge))
             or (ReplyDistantCC(MessageLoopHour)
                 and IsMoreRecent(OtherATPminTime(k), MessageLoopHour)
                 and IsMoreRecent(MessageLoopHour + MessageValidityTime, OtherATPmaxTime(k))
                 and (ModularSub(OtherATPmaxTime(k) - MessageLoopHour) < LastMessageAge)))):
        return True
    else:
        return False
#
@
Message.LastAge，当前消息已存活的时间。Age的最大值为REPORT_AGE_MAX。
%
def LastAge(MessageAvailable, MessageLoopHour, PreviousLastAge, k):
    if (Initialization
         or PreviousLastAge >= REPORT_AGE_MAX):
        return REPORT_AGE_MAX
    elif (MessageAvailable,
          and ReplyLocalCC(MessageLoopHour)):
        return (1 + ModularSub(ATPtime(k), MessageLoopHour))
    elif (MessageAvailable,
          and ReplyDistantCC(MessageLoopHour)):
        return (1 + ModularSub(OtherATPminTime(k), MessageLoopHour))
    else:
        return (1 + PreviousLastAge)
#
@
Message. Valid，当前消息是否依然有效
%
def Valid(MessageLoopHour, MessageValidityTime, k):
    if (ReplyLocalCC(MessageLoopHour)):
        return ((ATPtime(k) - MessageLoopHour) <= MessageValidityTime)
    elif (ReplyDistantCC(MessageLoopHour)):
        return ((OtherATPmaxTime(k) - MessageLoopHour) <= MessageValidityTime)
    else:
        return False
#

EOF