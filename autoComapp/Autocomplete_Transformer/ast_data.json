[{"cn": "\u521d\u59cb\u5316\u65f6\uff0cATP\u8bfb\u53d6\u6765\u81eaCC data plug\u7684DataPlugContent.CCTrainType\u4fe1\u606f\uff0c\u751f\u6210TrainType\u3002", "en": "On initialization, ATP generates TrainType according to DataPlugContent.CCTrainType from the CC data plug.", "code": "def TrainType(k):    return DataPlugContent.CCTrainType"}, {"cn": "\u521d\u59cb\u5316\u65f6\uff0cATP\u8bfb\u53d6\u6765\u81eaCC data plug\u7684DataPlugContent.CCCoreId\u4fe1\u606f\uff0c\u751f\u6210CoreId\u3002", "en": "On initialization, ATP generates CoreId according to DataPlugContent.CCCoreId read from the CC data plug.", "code": "def CoreId(k):    return DataPlugContent.CCCoreId"}, {"cn": "OtherCoreId\uff0c\u8fdc\u7aef\u8f66\u5934\u53f7", "en": "Core id for CC on the distant cab.", "code": "def OtherCoreId(k):    if (CoreId(k) is END_1):        return END_2    elif (CoreId(k) is END_2):        return END_1    else:        return None"}, {"cn": "\u521d\u59cb\u5316\u65f6\uff0cATP\u8bfb\u53d6\u6765\u81eaCC data plug\u7684DataPlugContent.CC_SSID\u4fe1\u606f\uff0c\u751f\u6210SubSystemId\u3002", "en": "On initialization, ATP generates SubSystemId according to DataPlugContent.CC_SSID from the CC data plug.", "code": "def SubSystemId(k):    return DataPlugContent.CC_SSID"}, {"cn": "\u4e0a\u8ff0\u4fe1\u606f\u5747\u83b7\u53d6\u6b63\u786e\u5e76\u4e14\u76f8\u4e00\u81f4\u540e\uff0c\u751f\u6210TrainKnown\u4fe1\u606f\u3002\u5982\u679cTrainKnown\u4e3aFalse\uff0c\u5219VIOM\u5c06\u8f93\u51fa\u5168\u9650\u5236\u72b6\u6001\u3002", "en": "After all above-mentioned information has corrected, and correspondingly, ATP will generate TrainKnown information. If TrainKnown considered as False, ATP shall set all output ports as restricted.", "code": "def TrainKnown(k):    return ((TrainType(k) == ATPsetting.TrainTypeId)            and (CoreId(k) is END_1                 or CoreId(k) is END_2)            and IdenticalVersionOfDualCPU(k))"}, {"cn": "NonVitalRequestReady\uff0c\u901a\u8fc7\u4e0eCCNV\u7684\u901a\u4fe1\u63a5\u53e3\uff0c\u5224\u65ad\u662f\u5426\u6536\u5230CCNV\u7684\u6d88\u606fNonVitalRequest", "en": "Through the communication with CCNV, ATP judges NonVitalRequestreceived from CCNV and generates NonVitalRequestReady If received a new message.", "code": "def NonVitalRequestReady(k):    return Message.Exists(NonVitalRequest)"}, {"cn": "ATOcontrolTimeValid\uff0cCCNV\u6d88\u606f\u6709\u6548\u6807\u5fd7\uff0c\u5982\u679c\u8d85\u8fc7CCNV_VALIDITY_CYCLES\u4e2a\u5468\u671f\u4ecd\u672a\u6536\u5230\u65b0\u7684CCNV\u6d88\u606f\uff0c\u5219\u8bbe\u7f6e\u4e3aFalse\u3002", "en": "ATOcontrolTimeValid stands for the effectiveness of CCNV message. If there is no updating CCNV message past the CCNV_VALIDITY_CYCLES, ATOcontrolTimeValid is set as False.", "code": "def ATOcontrolTimeValid(k):    if (NonVitalRequestReady(k)):        ATOcontrolTimeValid = True        ATOcontrolTimer = 0    elif (ATOcontrolTimer(k-1) < CCNV_VALIDITY_CYCLES):        ATOcontrolTimer = ATOcontrolTimer(k-1) + 1    else:        ATOcontrolTimeValid = False    return ATOcontrolTimeValid"}, {"cn": "VIOM1VitalInputsReceived\uff0cATP\u5224\u65ad\u662f\u5426\u6536\u5230\u4e86\u6765\u81eaVIOM1\u7684\u5b89\u5168\u8f93\u5165\u6d88\u606f\u3002\u5176\u4e2dviomId\u53d6\u503c\u4e3a0\u62161\uff0c\u8868\u793a\u4f4d\u4e8eEND_1\u8f66\u59342\u4e2aVIOM\u4e2d\u76841\u4e2a\u3002", "en": "ATP determines whether received a safety input message from VIOM1. During the calculation, the value viomId is either zero or one, which represents one of the two VIOM in the train END_1.", "code": "def VIOM1VitalInputsReceived(viomId, k):    return Message.Received(VIOM1VitalInput(viomId), k)"}, {"cn": "VIOM1VitalInputsAvailable\uff0c\u901a\u8fc7\u901a\u4fe1\u63a5\u53e3\uff0c\u83b7\u53d6\u6765\u81eaVIOM1\u7684\u5b89\u5168\u8f93\u5165\u6d88\u606f\uff0c\u5e76\u5224\u65ad\u6d88\u606f\u4f20\u8f93\u7684\u65f6\u95f4\u6709\u6548\u6027\u4ee5\u53ca\u987a\u5e8f\u7684\u6b63\u786e\u6027\u3002\u5176\u4e2dViomId\u53d6\u503c\u4e3a0\u62161\uff0c\u8868\u793a\u4f4d\u4e8eEND_1\u8f66\u59342\u4e2aVIOM\u4e2d\u76841\u4e2a\u3002", "en": "Through the communication, ATP gets the vital input message from VIOM1 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM1VitalInputsAvailable. During the calculation, the value ViomId is either zero or one, which represents one of the two VIOM in the train END_1.", "code": "def VIOM1VitalInputsAvailable(ViomId, k):    return Message.Available(VIOM1VitalInputsReceived(ViomId, k),                             VIOM1VitalInput(ViomId).AtpLoopHour,                             VIOM_VALIDITY_TIME,                             VIOM1VitalInputsLastAge(ViomId, k-1),                             k) "}, {"cn": "VIOM1VitalInputsLastAge\uff0c\u8bb0\u5f55\u6536\u5230\u6700\u65b0\u7684END_1\u7aefVIOM\u7684\u5b58\u6d3b\u65f6\u95f4\u4e3a\u591a\u5c11\u3002", "en": "Records the survival time of received vital inputs from VIOM1.", "code": "def VIOM1VitalInputsLastAge(ViomId, k):    return Message.LastAge(VIOM1VitalInputsAvailable(ViomId, k),                               VIOM1VitalInput(ViomId).AtpLoopHour,                               VIOM1VitalInputsLastAge(ViomId, k-1),                               k) "}, {"cn": "LatestVIOM1LoopHourVIOM\uff0c\u8bb0\u5f55\u5f53\u524d\u6536\u5230\u6700\u65b0\u7684END_1\u7aefVIOM\u7684\u5468\u671f\u65f6\u95f4\u4fe1\u606f\u3002\u521d\u59cb\u5316\u65f6LatestVIOM1LoopHourVIOM\u4e3aVIOM\u5468\u671f\u53f7\u7684\u6700\u5c0f\u503c0\uff1b\u5982\u679c\u6536\u5230\u53ef\u7528\u7684VIOM1\u4fe1\u606f\uff0c\u6216\u4e4b\u524d\u7684VIOM1\u6d88\u606f\u5df2\u65e0\u6548\u4f46\u53c8\u65b0\u6536\u5230\u4e00\u6761VIOM1\u6d88\u606f\uff0c\u5219\u5c06\u76f8\u5e94\u7684LatestVIOM1LoopHourVIOM\u8bbe\u7f6e\u4e3a\u65b0\u6536\u5230\u6d88\u606f\u4e2d\u7684viomLoopHour\u503c\uff1b\u5426\u5219\uff0cLatestVIOM1LoopHourVIOM\u4fdd\u6301\u4e0d\u53d8\u3002", "en": "ATP records the latest cycle time information of VIOM in END_1 by the term LatestVIOM1LoopHourVIOM.In initialization, set LatestVIOM1LoopHourVIOM as the zero; If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM1LoopHourVIOM as the viomLoopHour of the message. Otherwise, LatestVIOM1LoopHourVIOM keeps unchanged.", "code": "def LatestVIOM1LoopHourVIOM(ViomId, k):    if (VIOM1VitalInputsAvailable(k)        or (not VIOM1VitalInputsValid(k-1)            and VIOM1VitalInputsReceived(ViomId, k))):        return VIOM1VitalInput[ViomId].ViomLoopHour    else:        return LatestVIOM1LoopHourVIOM[ViomId](k-1)"}, {"cn": "VIOM2VitalInputsReceived\uff0c\u6536\u5230\u5e76\u6821\u9a8c\u6b63\u786e\u6765\u81eaVIOM2\u7684\u5b89\u5168\u8f93\u51fa\u6d88\u606f\u3002", "en": "ATP determines whether received a safety input message from VIOM2.", "code": "def VIOM2VitalInputsReceived(ViomId, k):    return Message.Received(VIOM2VitalInput(ViomId), k)"}, {"cn": "VIOM2VitalInputsAvailable\uff0c\u901a\u8fc7\u901a\u4fe1\u63a5\u53e3\uff0c\u83b7\u53d6\u6765\u81eaVIOM2\u7684\u5b89\u5168\u8f93\u5165\u6d88\u606f\uff0c\u5e76\u5224\u65ad\u6d88\u606f\u4f20\u8f93\u7684\u65f6\u95f4\u6709\u6548\u6027\u4ee5\u53ca\u987a\u5e8f\u7684\u6b63\u786e\u6027\u3002\u5176\u4e2dViomId\u53d6\u503c\u4e3a0\u62161\uff0c\u8868\u793a\u4f4d\u4e8eEND_2\u8f66\u59342\u4e2aVIOM\u4e2d\u76841\u4e2a\u3002", "en": "Through the communication, ATP gets the vital input message from VIOM2 and decides the time effectiveness and the correctness of the sequence of the message, which defined as VIOM2VitalInputsAvailable. During the calculation, the value i is either zero or one, which represents one of the two VIOM in the train END_2.", "code": "def VIOM2VitalInputsAvailable(ViomId, k):    return Message.Available(VIOM2VitalInputsReceived(ViomId, k),                                  VIOM2VitalInput(ViomId).AtpLoopHour,                                  VIOM_VALIDITY_TIME,                                  VIOM2VitalInputsLastAge(ViomId, k-1),                                  k) "}, {"cn": "VIOM2VitalInputsLastAge\uff0c\u8bb0\u5f55\u5f53\u524d\u6536\u5230\u6700\u65b0\u7684END_2\u7aefVIOM\u7684\u5468\u671f\u65f6\u95f4\u4fe1\u606f\u3002", "en": "Records the survival time of received vital inputs from VIOM2.", "code": "def VIOM2VitalInputsLastAge(viomId, k):    return Message.LastAge(VIOM2VitalInputsAvailable(viomId, k),                               VIOM2VitalInput(viomId).AtpLoopHour,                               VIOM2VitalInputsLastAge(viomId, k-1),                               k) "}, {"cn": "LatestVIOM2LoopHourVIOM\uff0c\u8bb0\u5f55\u5f53\u524d\u6536\u5230\u6700\u65b0\u7684END_2\u7aefVIOM\u7684\u5468\u671f\u65f6\u95f4\u4fe1\u606f\u3002\u521d\u59cb\u5316\u65f6LatestVIOM2LoopHourVIOM\u4e3aVIOM\u5468\u671f\u53f7\u7684\u6700\u5c0f\u503c0\uff1b\u5982\u679c\u6536\u5230\u53ef\u7528\u7684VIOM2\u4fe1\u606f\uff0c\u6216\u4e4b\u524d\u7684VIOM2\u6d88\u606f\u5df2\u65e0\u6548\u4f46\u53c8\u65b0\u6536\u5230\u4e00\u6761VIOM2\u6d88\u606f\uff0c\u5219\u5c06\u76f8\u5e94\u7684LatestVIOM2LoopHourVIOM\u8bbe\u7f6e\u4e3a\u65b0\u6536\u5230\u6d88\u606f\u4e2d\u7684ViomLoopHour\u503c\uff1b\u5426\u5219\uff0cLatestVIOM2LoopHourVIOM\u4fdd\u6301\u4e0d\u53d8\u3002", "en": "ATP records the latest cycle time information of VIOM in END_2by the term LatestVIOM2LoopHourVIOM.In initialization, set LatestVIOM2LoopHourVIOM as the zero; If receiving an available VIOM1 message, or a new message and the previous one has invalid, ATP will set the related value of LatestVIOM2LoopHourVIOM as the viomLoopHour of the message.Otherwise, LatestVIOM2LoopHourVIOM keeps unchanged.", "code": "def LatestVIOM2LoopHourVIOM(ViomId, k):    if (VIOM2VitalInputsAvailable(k)        or (not VIOM2VitalInputsValid(k-1)            and VIOM2VitalInputsReceived(ViomId, k))):        return VIOM2VitalInput[ViomId].ViomLoopHour    else:        return LatestVIOM2LoopHourVIOM[ViomId](k-1)"}, {"cn": "VIOM1VitalInputsValid\uff0c\u5224\u65ad\u6765\u81eaEND_1\u7684VIOM\u5b89\u5168\u8f93\u5165\u4fe1\u606f\u662f\u5426\u5728\u6709\u6548\u65f6\u95f4\u5185\u3002", "en": "ATP determines whether the vital inputs message from VIOM1 valid.", "code": "def VIOM1VitalInputsValid(k):    return (Message.Valid(VIOM1VitalInput(1).AtpLoopHour, VIOM_VALIDITY_TIME)            or Message.Valid(VIOM1VitalInput(2).AtpLoopHour, VIOM_VALIDITY_TIME))"}, {"cn": "VIOM2VitalInputsValid\uff0c\u5224\u65ad\u6765\u81eaEND_2\u7684VIOM\u5b89\u5168\u8f93\u5165\u4fe1\u606f\u662f\u5426\u5728\u6709\u6548\u65f6\u95f4\u5185\u3002", "en": "ATP determines whether the vital inputs message from VIOM2 valid.", "code": "def VIOM2VitalInputsValid(k):    return (Message.Valid(VIOM2VitalInput(1).AtpLoopHour, VIOM_VALIDITY_TIME)            or Message.Valid(VIOM2VitalInput(2).AtpLoopHour, VIOM_VALIDITY_TIME))"}, {"cn": "CoupledByEnd1\u6216CoupledByEnd2\uff0c\u5217\u8f66\u4e24\u7aef\u8fde\u6302\u5176\u4ed6\u8f66\u8f86\u3002\u5982\u679c\u8be5\u9879\u76ee\u672a\u914d\u7f6e\u8fde\u6302\u8f93\u5165\u7684\u91c7\u96c6\uff0c\u5219\u8ba4\u4e3a\u5217\u8f66\u672a\u4e0e\u5176\u4ed6\u8f66\u8fde\u6302\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "CoupledByEnd1 or CoupledByEnd2 shows that both ends of train connect with other trains. If the project is not configured with the capture of coupling input, it is certain that the train does not connect with other trains.", "code": "def CoupledByEnd1(k):    return Offline.GetCoupledByEnd1(k)def CoupledByEnd2(k):    return Offline.GetCoupledByEnd2(k)"}, {"cn": "TrainNotCoupled\uff0c\u5217\u8f66\u672a\u4e0e\u5176\u4ed6\u8f66\u8f86\u8fde\u6302\u3002%def TrainNotCoupled(k):return Offline.GetTrainNotCoupled(k)#@TrainCoupledType\uff0c\u6839\u636e\u9879\u76ee\u914d\u7f6e\uff0c\u83b7\u53d6\u5f53\u524d\u5217\u8f66\u7684\u8fde\u6302\u7c7b\u578b\u3002\u652f\u6301\u4ee5\u4e0b\u56db\u79cd\u8fde\u6302\u7c7b\u578b\uff1aTRAIN_COUPLED_UNKNOWN\uff0c\u5f53\u524d\u8fde\u6302\u72b6\u6001\u65e0\u6548\uff1bTRAIN_NO_COUPLED\uff0c\u5217\u8f66\u672a\u8fde\u6302\uff1bTRAIN_COUPLED_END1\uff0c\u5217\u8f66END_1\u7aef\u8fde\u6302\uff1bTRAIN_COUPLED_END2\uff0c\u5217\u8f66END_2\u7aef\u8fde\u6302\u3002\u89c4\u5219\u5982\u4e0b\uff1a%def TrainCoupledType(k):if (TrainNotCoupled(k)and not TrainCoupledByEnd1(k)and not TrainCoupledByEnd2(k)):return TRAIN_NO_COUPLEDelif (not TrainNotCoupled(k)and TrainCoupledByEnd1(k)and not TrainCoupledByEnd2(k)):return TRAIN_COUPLED_END1elif (not TrainNotCoupled(k)and not TrainCoupledByEnd1(k)and TrainCoupledByEnd2(k)):return TRAIN_COUPLED_END2else:return TRAIN_COUPLED_UNKNOWN#@ATPtime\uff0c\u7ef4\u62a4\u672c\u7aefATP\u7684loop hour\u65f6\u95f4\u3002\u6839\u636e\u672c\u7aefCoreId\uff0c\u521d\u59cb\u5316\u4e3aEND_1\u6216 END_2\u7684\u521d\u59cb\u503c\uff1b\u5982\u679c\u8d85\u8fc7\u4e86\u76f8\u5e94\u7684\u6700\u5927\u503c\uff0c\u5219\u91cd\u65b0\u7b49\u4e8e\u521d\u59cb\u5316\u7684\u503c\u3002\u5426\u5219\u6bcf\u5468\u671f\u52a01", "en": "ATPtime stands for the ATP loop hour of this train END. Based on CoreId, ATP initialize ATPtime as the initiative value of END_1 or END_2; If the value exceeds the maximum loop hour, ATP shall set it as the initiative value; Otherwise, add one for each cycle.", "code": "def ATPtime(k):    if (CoreId(k) is END_1):        if (Initialization):            return CC1_INIT_TIME        elif (ATPtime(k-1) >= CC1_MAX_TIME):            return CC1_INIT_TIME        else:            return ATPtime(k-1) + 1    else:        if (Initialization):            return CC2_INIT_TIME        elif (ATPtime(k-1) >= CC2_MAX_TIME):            return CC2_INIT_TIME        else:            return ATPtime(k-1) + 1"}, {"cn": "OtherATPmessageReceived\uff0c\u672c\u5468\u671f\u6536\u5230\u5197\u4f59ATP\u6d88\u606f\u5e76\u6821\u9a8c\u6b63\u786e\u3002", "en": "The message transmitted from the distant ATP in the other END shall be protected by check words. And before using the information, ATP shall verify the check words.", "code": "def OtherATPmessageReceived(k):    return Message.Received(OtherCCsynchroReport,k)"}, {"cn": "OtherATPmessageAvailable\uff0c\u5224\u65ad\u6765\u81ea\u5197\u4f59ATP\u6d88\u606f\u7684\u6709\u6548\u6027\uff1a", "en": "OtherATPmessageAvailable, ATP shall judge the effectiveness of message from the redundant ATP, shown as following pseudo-codes:", "code": "def OtherATPmessageAvailable(k):    return Message.Available(OtherATPmessageReceived(k),                            OtherCCsynchroReport.LatestTimeOtherCore,                            OTHER_ATP_VALIDITY_TIME,                            LastOtherATPmessageAge(k-1),                            k)"}, {"cn": "LastOtherATPmessageAge\uff0c\u83b7\u53d6\u5230\u7684\u8fdc\u7aefATP\u6d88\u606f\u7684\u5b58\u6d3b\u65f6\u95f4\u3002%def LastOtherATPmessageAge(k):return Message.LastAge(OtherATPmessageAvailable(k),OtherCCsynchroReport.LatestTimeOtherCore,LastOtherATPmessageAge(k-1),k)#@OtherATPmessageValid\uff0c\u63a5\u6536\u5230\u7684\u5197\u4f59ATP\u6d88\u606f\u662f\u5426\u5728\u6709\u6548\u671f\u5185\u3002\u5982\u679c\u8be5\u6d88\u606f\u5df2\u5931\u6548\uff0c\u5219\u8bbe\u7f6eOtherATPmessageValid\u4e3aFalse\uff1b\u5426\u5219\u4e3aTrue\u3002", "en": "OtherATPmessageValid represents the effectiveness of the messages from redundant ATP. If this message is invalid, ATP will set OtherATPmessageValid as False; otherwise, it is set as True.", "code": "def OtherATPmessageValid(k):    return Message.Valid(OtherCCsynchroReport.LatestTimeOtherCore,                         OTHER_ATP_VALIDITY_TIME,                         k)"}, {"cn": "OtherATPminTime\uff0c\u672c\u7aefATP\u7ef4\u62a4\u7684\u5197\u4f59ATP\u7684\u6700\u5c0f\u65f6\u95f4\u3002\u8bbe\u7f6e\u89c4\u5219\u5982\u4e0b\uff1a\u521d\u59cb\u5316\u65f6\u6839\u636e\u6240\u5728\u8f66\u5934\u8bbe\u7f6eOtherATPminTime\u4e3a\u9ed8\u8ba4\u503c\uff1b\u5426\u5219\uff0c\u5982\u679c\u672c\u5468\u671f\u6536\u65b0\u7684\u5197\u4f59ATP\u6d88\u606f\u53ef\u7528\uff0c\u5219\u66f4\u65b0OtherATPminTime\u4e3a\u6d88\u606f\u4e2d\u7684currentTime\uff1b\u5426\u5219\uff0c\u5982\u679c\u5197\u4f59ATP\u6d88\u606f\u4ecd\u7136\u5728\u6709\u6548\u671f\u5185\uff0c\u5219\u5bf9OtherATPminTime\u6bcf\u5468\u671f\u52a01\uff0c\u82e5\u8d8a\u754c\u5219\u91cd\u65b0\u7b49\u4e8e\u521d\u59cb\u5316\u503c\uff1b\u5426\u5219\uff0c\u5982\u679c\u5f53\u524d\u6536\u5230\u7684\u65b0\u7684\u5197\u4f59ATP\u6d88\u606f\uff08\u4f46\u4e0d\u53ef\u7528\uff09\uff0c\u5219\u5c06OtherATPminTime\u66f4\u65b0\u4e3a\u6d88\u606f\u4e2d\u7684\u65f6\u95f4\uff1b\u5176\u4ed6\u60c5\u51b5\uff0cOtherATPminTime\u7d2f\u52a01\uff0c\u82e5\u8d8a\u754c\u5219\u91cd\u65b0\u7b49\u4e8e\u521d\u59cb\u5316\u503c\u3002", "en": "The OtherATPminTime stands for the local ATP maintained minimum time ofthe redundant ATP. The setting rule is as following: In initialization, ATP setthe OtherATPminTime as default value based on the CoreId of the redundantATP. Or else:, if the updating message from the new redundant ATP in thiscycle is available, ATP will update OtherATPminTime as the current time inthe message. Or else:, if the redundant ATP message is still effective, ATPwill add 1 in the OtherATPminTime until it is out of bound, and set is asinitialization value. Or else:, If the received a new redundant ATP message,but it was not available, ATP shall update OtherATPminTime as in themessage. Otherwise, accumulate OtherATPminTime.", "code": "if (CoreId == END_1)    if (Initialization)        OtherATPminTime = CC2_INIT_TIME    elif ((OtherATPmessageAvailable(k) == True)            or ((OtherATPmessageValid(k) == False)                  and Exists(OtherCCsynchroReport)))        OtherATPminTime = OtherCCsynchroReport.CurrentTime    else:        if (OtherATPminTime(k-1) >= CC2_MAX_TIME)             OtherATPminTime = CC2_INIT_TIME        else:             OtherATPminTime = OtherATPminTime(k-1) + 1else:    if (Initialization)        OtherATPminTime = CC1_INIT_TIME    elif ((OtherATPmessageAvailable(k) == True)            or ((OtherATPmessageValid(k) == False)                  and Exists(OtherCCsynchroReport)))        OtherATPminTime = OtherCCsynchroReport.CurrentTime    else:        if (OtherATPminTime(k-1) >= CC1_MAX_TIME)             OtherATPminTime = CC1_INIT_TIME        else:             OtherATPminTime = OtherATPminTime(k-1) + 1"}, {"cn": "OtherATPmaxTime\uff0c\u7ef4\u62a4\u5197\u4f59ATP\u7684\u6700\u5927\u65f6\u95f4\u3002", "en": "The OtherATPmaxTime stands for the local ATP maintained maximum time of the redundant ATP. The rules to update OtherATPmaxTime are similar with OtherATPminTime except that when received a new message from the redundant ATP, the OtherATPmaxTime shall add the maximum transmission delay in network.", "code": "if (CoreId == END_1)    if (Initialization)        OtherATPmaxTime = CC2_INIT_TIME    elif ((OtherATPmessageAvailable(k) == True)            or ((OtherATPmessageValid(k) == False)                  and Exists(OtherCCsynchroReport)))        OtherATPmaxTime = OtherCCsynchroReport.CurrentTime                                  + LoopHourModularSub(ATPtime(k),                                        OtherCCsynchroReport.LatestTimeOtherCore)    else:        if (OtherATPmaxTime(k-1) >= CC2_MAX_TIME)             OtherATPmaxTime = CC2_INIT_TIME        else:             OtherATPmaxTime = OtherATPmaxTime(k-1) + 1else:    if (Initialization)        OtherATPmaxTime = CC1_INIT_TIME    elif ((OtherATPmessageAvailable(k) == True)            or ((OtherATPmessageValid(k) == False)                  and Exists(OtherCCsynchroReport)))        OtherATPmaxTime = OtherCCsynchroReport.CurrentTime                                  + LoopHourModularSub(ATPtime(k),                                        OtherCCsynchroReport.LatestTimeOtherCore)    else:        if (OtherATPmaxTime(k-1) >= CC1_MAX_TIME)             OtherATPmaxTime = CC1_INIT_TIME        else:             OtherATPmaxTime = OtherATPmaxTime(k-1) + 1"}, {"cn": "OtherATP\uff0c\u89e3\u6790\u5e76\u5b58\u50a8\u8fdc\u7aefATP\u7684\u6d88\u606f\u3002\u521d\u59cb\u5316\u6216\u8005\u8fdc\u7aef\u6d88\u606f\u8fc7\u671f\u65f6\uff0c\u8bbe\u7f6e\u76f8\u5e94\u7684\u503c\u4e3a\u9ed8\u8ba4\u72b6\u6001\uff1b\u5f53\u672c\u5468\u671f\u6536\u5230\u65b0\u7684\u8fdc\u7aef\u6d88\u606f\u65f6\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a\u65b0\u6536\u5230\u6d88\u606f\u7684\u503c\uff1b\u5426\u5219\uff0c\u4fdd\u6301\u4e0d\u53d8\u3002", "en": "OtherATP, parse and store messages from the distant ATP.In initialization or the message has expired, set all variables as default value; when new message available, set the corresponding value from the new message; otherwise, remain unchanged.", "code": "def OtherATP(k):    if (Initialization        or (not OtherATPmessageValid(k))):        OtherATP.LatestTimeOtherCore = INVALID_LOOP_HOUR        OtherATP.CoreId = None        OtherATP.BeaconId = None        OtherATP.EnableDoorOpening_A = False        OtherATP.EnableDoorOpening_B = False        OtherATP.PsdManagerOpeningOrder = False        OtherATP.PsdIdSide_A = None        OtherATP.PsdValiditySide_A = None        OtherATP.PsdClosedSide_A = False        OtherATP.PsdIdSide_B = None        OtherATP.PsdValiditySide_B = None        OtherATP.PsdClosedSide_B = False        OtherATP.ZcVersion = None        OtherATP.LocatedOnKnownPath = False        OtherATP.LocatedWithMemLocation = False        OtherATP.Location.Ext2 = None        OtherATP.Location.Uncertainty = None        OtherATP.Location.Ext1 = None        OtherATP.SleepZoneId = None        OtherATP.SleepZoneVersion = None        OtherATP.MotionSinceLastReloc = None        OtherATP.MotionSinceMemLoc = None        OtherATP.TrainFilteredStopped = False        OtherATP.SafetyParameterVersion = None        OtherATP.SafetyApplicationVersion = None        OtherATP.CC_SSID = None        OtherATP.OverlapExpired = False    elif (OtherATPmessageAvailable(k)):        OtherATP.LatestTimeOtherCore = OtherCCsynchroReport.LatestTimeOtherCore(k)        OtherATP.CoreId = OtherCCsynchroReport.CoreId        OtherATP.BeaconId = OtherCCsynchroReport.BeaconId        OtherATP.EnableDoorOpening_A = OtherCCsynchroReport.EnableDoorOpening_A        OtherATP.EnableDoorOpening_B = OtherCCsynchroReport.EnableDoorOpening_B        OtherATP.PsdManagerOpeningOrder = OtherCCsynchroReport.PsdManagerOpeningOrder        OtherATP.PsdIdSide_A = OtherCCsynchroReport.PsdIdSide_A        OtherATP.PsdValiditySide_A = OtherCCsynchroReport.PsdValiditySide_A        OtherATP.PsdClosedSide_A = OtherCCsynchroReport.PsdClosedSide_A        OtherATP.PsdIdSide_B = OtherCCsynchroReport.PsdIdSide_B        OtherATP.PsdValiditySide_B = OtherCCsynchroReport.PsdValiditySide_B        OtherATP.PsdClosedSide_B = OtherCCsynchroReport.PsdClosedSide_B        OtherATP.ZcVersion = OtherCCsynchroReport.ZcVersion        OtherATP.LocatedOnKnownPath = OtherCCsynchroReport.LocatedOnKnownPath        OtherATP.LocatedWithMemLocation = OtherCCsynchroReport.LocatedWithMemLocation        OtherATP.Location.Ext2 = OtherCCsynchroReport.Location.Ext2        OtherATP.Location.Uncertainty = OtherCCsynchroReport.Location.Uncertainty        OtherATP.Location.Ext1 = OtherCCsynchroReport.Location.Ext1        OtherATP.SleepZoneId = OtherCCsynchroReport.SleepZoneId        OtherATP.SleepZoneVersion = OtherCCsynchroReport.SleepZoneVersion        OtherATP.MotionSinceLastReloc = OtherCCsynchroReport.MotionSinceLastReloc        OtherATP.MotionSinceMemLoc = OtherCCsynchroReport.MotionSinceMemLoc        OtherATP.TrainFilteredStopped = OtherCCsynchroReport.TrainFilteredStopped        OtherATP.SafetyParameterVersion = OtherCCsynchroReport.SafetyParameterVersion        OtherATP.SafetyApplicationVersion = OtherCCsynchroReport.SafetyApplicationVersion        OtherATP.CC_SSID = OtherCCsynchroReport.CC_SSID        OtherATP.OverlapExpired = OtherCCsynchroReport.OverlapExpired    else:        pass    return OtherATP"}, {"cn": "BlockModeUsed\uff0c\u5f53\u524d\u662f\u5426\u73b0\u5728\u9009\u62e9BM\u6a21\u5f0f\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "BlockModeUsed represents that either of train end chooses BM mode.", "code": "def BlockModeUsed(k):    return Offline.GetBlockModeUsed(k)"}, {"cn": "BMvariantValidWhileTemporallyValid\uff0c\u5f53\u524d\u662f\u5426\u4f7f\u7528BM\u53d8\u91cf\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "The status of BMvariantValidWhileTemporallyValid shows whether it is in the BM mode.", "code": "def BMvariantValidWhileTemporallyValid(k):    return Offline.GetBMvariantValidWhileTemporallyValid(k)"}, {"cn": "BeaconVariantsUpdating\uff0c\u5224\u65ad\u662f\u5426\u8981\u66f4\u65b0BM\u53d8\u91cf\u3002\u82e5\u672c\u5468\u671f\u6ee1\u8db3\u4ee5\u4e0b\u6240\u6709\u6761\u4ef6\u65f6\uff0c\u5219\u8ba4\u4e3a\u9700\u8981\u66f4\u65b0BM\u53d8\u91cf\uff0c\u8bbe\u7f6eBeaconVariantsUpdating\u4e3aTrue\u3002\u5f53\u524d\u4f7f\u7528BM\u53d8\u91cf\uff08BMvariantValidWhileTemporallyValid\uff09\uff1b\u672c\u5468\u671f\u672a\u505c\u8f66\u4e14\u6536\u5230\u4fe1\u6807\u6d88\u606f\u4e14\u5224\u65ad\u8be5\u4fe1\u6807\u5e26\u6709BM\u53d8\u91cf\uff1b\u4e0a\u5468\u671f\u5217\u8f66\u672a\u5b9a\u4f4d\uff0c\u6216\u8be5BM\u4fe1\u6807\u65b9\u5411\u4e0e\u5217\u8f66\u8fd0\u8425\u65b9\u5411\u4e00\u81f4\u3002\u5426\u5219\uff0c\u8bbe\u7f6eBeaconVariantsUpdating\u4e3aFalse\u3002", "en": "BeaconVariantsUpdating used to determine ATP whether to update the BM variants in this cycle. If all the following conditions are fulfilled, ATP shall set BeaconVariantsUpdating as True:The current operational mode is BLOCK MODE;And train moved and ATP received a BM beacon in this cycle; And the train is either not localized, or the direction of the BM variants is as same as the orientation of the train front end. Otherwise, ATP shall set BeaconVariantsUpdating as False.", "code": "def BeaconVariantsUpdating(k):    return (BMvariantValidWhileTemporallyValid(k)            and BeaconMessageReceive(k)            and TrackMap.IsBmBeacon(BeaconMessage.ID)            and not TrainFilteredStopped(k)            and (not TrainLocalized(k-1)                 or (TrackMap.BmBeaconDirection(BeaconMessage.ID)== TrainFrontOrientation(k-1))))"}, {"cn": "BMbeaconReadAge\uff0c\u8bb0\u5f55\u8bfb\u53d6BM\u4fe1\u6807\u5230\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u9ed8\u8ba4\u503c\u4e3aREPORT_AGE_MAX\u3002\u5982\u679cBM\u4fe1\u6807\u53d8\u91cf\u65e0\u6548\uff0c\u8be5\u503c\u5e94\u88ab\u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u503c\uff0cBM\u4fe1\u6807\u53d8\u91cf\u65e0\u6548\u7684\u6761\u4ef6\u5982\u4e0b\uff1a\u521d\u59cb\u5316\uff1b\u6216\u5f53\u524d\u4e0d\u5728BM\u6a21\u5f0f(not BMvariantValidWhileTemporallyValid)\uff1b\u6216BMbeaconReadAge\u5df2\u5927\u4e8eATPsetting.VariantsBMfullValidityTime\uff1b\u6216\u672c\u5468\u671f\u6536\u5230\u7684BM\u4fe1\u6807\uff08BeaconVariantsUpdating\u4e3aTrue\uff09\u4e2dDefaultMessage\u4e3aTrue\u6216BlockModeVariantAvailable\u4e3aFalse\uff1b\u6216\u672c\u5468\u671f\u5217\u8f66\u7531\u5b9a\u4f4d\u8f6c\u4e3a\u5931\u4f4d\u72b6\u6001\uff1b\u6216\u5f53\u524d\u4f7f\u7528\u7684BM\u4fe1\u6807\u65b9\u5411\u4e0e\u5df2\u5b9a\u4f4d\u7684\u5217\u8f66\u8fd0\u8425\u65b9\u5411TrainFrontOrientation\u4e0d\u540c\u3002\u5426\u5219\uff0c\u5982\u679c\u672c\u5468\u671f\u66f4\u65b0BM\u4fe1\u6807\uff0c\u5219\u5c06\u8be5\u53d8\u91cf\u7684\u521d\u59cb\u503c\u8bbe\u7f6e\u4e3a1\uff08\u56e0\u4e3aATP\u4f7f\u7528\u7684\u662f\u4e0a\u4e2a\u5468\u671f\u8bfb\u5230\u7684\u4fe1\u6807\u4fe1\u606f\uff09\u3002\u5176\u4ed6\u60c5\u51b5\uff0c\u7d2f\u52a0\u8be5\u53d8\u91cf\u3002%def BMbeaconReadAge(k):if (Initializationor not BMvariantValidWhileTemporallyValid(k)or BMbeaconReadAge(k-1) > (ATPsetting.VariantsBMfullValidityTime - 1)or (BeaconVariantsUpdating(k)and (DefaultMessage(k) or not BlockModeVariantAvailable(k)))or (TrainLocalized(k-1)and (not TrainLocalized(k)or TrackMap.BmBeaconDirection(UsedBMbeaconId(k-1))is not TrainFrontOrientation(k-1)))):return REPORT_AGE_MAXelif (BeaconVariantsUpdating(k)):return 1else:return BMbeaconReadAge(k-1) + 1#@BMbeaconVariantValue\uff0c\u83b7\u53d6\u6765\u81eaBM\u4fe1\u6807\u4e2d\u8be5\u53d8\u91cf\u7684\u503c\uff0c\u8f93\u5165\u7d22\u5f15\u548c\u5468\u671f\uff0c\u82e5\u8fc7\u671f\u4e3a\u5047\u503c.%def BMbeaconVariantValue(lineSection, VarIndex, k):if (BMbeaconReadAge(k) > ATPsetting.VariantsBMfullValidityTime):return Falseelse:for Var in range(0, MAX_BM_VARIANT_NB):if (BMbeaconVariants[Var].LineSection == LineSectionand BMbeaconVariants[Var].Index == VarIndex):return BMbeaconVariants[Var].Valueelse:continueelse:return False#@UsedBMbeaconId\u7528\u4e8e\u8bb0\u5f55\u5f53\u524d\u6240\u4f7f\u7528\u7684BM\u53d8\u91cf\u6765\u81ea\u54ea\u4e2aBM\u4fe1\u6807\uff0c\u5224\u65ad\u6761\u4ef6\u5982\u4e0b\uff1a\u5f53\u521d\u59cb\u5316\uff0c\u975e\u4f7f\u7528BM\u53d8\u91cf\uff08not BMvariantValidWhileTemporallyValid\uff09\uff0c\u8be5\u4fe1\u6807\u65b9\u5411\u4e0e\u5f53\u524d\u8f66\u5934\u65b9\u5411\u4e0d\u7b26\uff0c\u6216\u5217\u8f66\u5931\u4f4d\u65f6\uff0c\u6e05\u9664UsedBMbeaconId\uff1b\u5426\u5219\uff0c\u5982\u679c\u6536\u5230\u6709\u6548\u7684BM\u4fe1\u6807\uff0c\u8bb0\u5f55\u8be5\u4fe1\u6807id\u5230UsedBMbeaconId\uff1b\u5426\u5219\uff0c\u4fdd\u6301UsedBMbeaconId\u4e0d\u53d8\u3002", "en": "UsedBMbeaconId records the used BM variants came from which BM beacon: When one of the following conditions fulfilled, ATP clear the UsedBMbeaconId: initialization,the BLOCK MODE variant is not temporally valid, the direction of the used BM beacon is not as same as train front orientation, the train is not localized. Or else:, when received a valid BM beacon, ATP update UsedBMbeaconId; Otherwise, keep this value unchanged.", "code": "def UsedBMbeaconId(k):    if (BeaconVariantsUpdating(k)):        return BeaconMessage.Id    elif (Initialization           or not BMvariantValidWhileTemporallyValid(k)           or (TrainLocalized(k-1)               and (TrackMap.BmBeaconDirection(UsedBMbeaconId(k-1))                    is not TrainFrontOrientation(k-1)))           or (TrainLocalized(k-1) and not TrainLocalized(k))):        return None    else:        return UsedBMbeaconId(k-1)"}, {"cn": "BMvariantValidLastRisingAge, \u8bb0\u5f55\u4ece\u9009\u62e9BM\u6a21\u5f0f\u5230\u5f53\u524d\u7ecf\u8fc7\u7684\u65f6\u95f4%def BMvariantValidLastRisingAge(k):if (not BMvariantValidWhileTemporallyValid(k)):BMvariantValidLastRisingAge = 0else:BMvariantValidLastRisingAge = BMvariantValidLastRisingAge(k-1) + 1#@CBIvariantReportReceived\uff0cATP\u8f6f\u4ef6\u6536\u5230CCNV\u8f6c\u53d1\u7684\u201cCBI variant report\u201d\u6d88\u606f\uff0c\u5e76\u5b89\u5168\u6821\u6838\u5b57\u6821\u9a8c\u6b63\u786e\u3002%def CBIvariantReportReceived(cbi, k):return Message.Received(CBIvariantReport(cbi), k)#@CBIvariantReportAvailable\uff0c\u8054\u9501\u6d88\u606f\u53ef\u7528%def CBIvariantReportAvailable(cbi, k):return Message.Available(CBIvariantReportReceived(cbi, k),CBIvariantReport(cbi).CcLoopHour,ATPsetting.VariantsBMlowValidityTime,min(CBIvariantReportLastAge(cbi, k-1),CBIminProductionAge(cbi, k-1),BMvariantValidLastRisingAge(k)),k)#@CBIvariantReportLastAge\uff0c\u8bb0\u5f55\u6700\u65b0\u6536\u5230\u7684\u8054\u9501\u6d88\u606f\u5df2\u5b58\u6d3b\u7684\u65f6\u95f4\u3002%def CBIvariantReportLastAge(cbi, k):return Message.LastAge(CBIvariantReportAvailable(cbi, k),CBIvariantReport(cbi).CcLoopHour,CBIvariantReportLastAge(cbi, k-1),k)#@BMcbiVariants, \u5f53\u6765\u81eaCBI\u7684\u53d8\u91cf\u53ef\u7528\u65f6\uff0c\u5b58\u50a8CBI\u53d8\u91cf\uff1b\u5176\u4ed6\u65f6\u5019\u4fdd\u6301\u4e0d\u53d8\u3002%def BMcbiVariants(cbi, k):if (CBIvariantReportAvailable(cbi, k)):for idx in range(0, CBIvariantReport.NumberOrVariants):BMcbiVariants[cbi].Variants[idx] = CBIvariantReport.Variant[idx]else:passreturn BMcbiVariants#@CBIvariantAge\uff0cCBI\u53d8\u91cf\u7684\u6709\u6548\u5b58\u6d3b\u65f6\u95f4\uff0c\u6700\u5927\u503c\u4e3aREPORT_AGE_MAX\u3002\u8be5\u503c\u4e0eCBIvariantReportLastAge\u7684\u533a\u522b\u662f\u5728\u5224\u65ad\u56de\u590d\u8fdc\u7aefATP\u6d88\u606f\u65f6\uff0c\u4f7f\u7528OtherATPmaxTime\u8fdb\u884c\u8ba1\u7b97\uff0c\u5728\u5224\u65ad\u6709\u6548\u671f\u65f6\u5bfc\u5411\u5b89\u5168\u4fa7\u3002%def CBIvariantAge(cbi, k):if (Initializationor CBIvariantAge(k-1) >= REPORT_AGE_MAX):return REPORT_AGE_MAXelif (CBIvariantReportAvailable(cbi, k)and Message.ReplyLocalCC(CBIvariantReport(cbi).CcLoopHour)):return (1 + Message.ModularSub(ATPtime(k), CBIvariantReport(cbi).CcLoopHour))elif (CBIvariantReportAvailable(cbi, k)and Message.ReplyDistantCC(CBIvariantReport(cbi).CcLoopHour)):return (1 + Message.ModularSub(OtherATPmaxTime(k), CBIvariantReport(cbi).CcLoopHour))else:return (1 + CBIvariantAge(cbi, k-1))#@CBIvariantLowValidity\uff0c\u5224\u65ad\u662f\u5426\u5728CBI\u65e0\u7ebf\u7684\u77ed\u6709\u6548\u671f\u5185\uff0c\u7528\u4e8ePZ\u7684\u76d1\u63a7\u3002 \u5728CBTC\u6216\u8005\u4f7f\u7528\u6765\u81eaBM\u4fe1\u6807\u53d8\u91cf\u7684\u60c5\u51b5\u4e0b\uff0c\u8be5\u503c\u4e3a\u771f\u3002%def CBIvariantLowValidity(cbi, k):if (not BlockModeUsed(k)or not CBIvariantMoreAvailableThanBeacon(cbi, k)or CBIvariantAge(cbi, k) <= ATPsetting.VariantsBMlowValidityTime):return Trueelse:return False#@BMcbiVariantValue\uff0c\u6839\u636e\u8054\u9501\u53d8\u91cf\u7d22\u5f15\uff0c\u83b7\u5f97CBI\u7684\u53d8\u91cf\u3002%def BMcbiVariantValue(CbiId, VarIndex, k):if (CBIvariantAge(CbiId, k) > ATPsetting.VariantsBMfullValidityTime):return Falseelse:return BMcbiVariants[CbiId].Variants[VarIndex]#@AppliedCBIvariantLoopHour\uff0c\u8bb0\u5f55\u5f53\u524d\u4f7f\u7528\u7684CBI\u7684\u53d8\u91cf\u7684CC\u65f6\u95f4\uff0c\u4f9bCCNV\u4f7f\u7528\u3002%def AppliedCBIvariantLoopHour(cbiId, k):if (CBIvariantReportAvailable(cbiId, k)):return CBIvariantReport(cbiId).CcLoopHourelse:return AppliedCBIvariantLoopHour(cbiId, k-1)#@CBIvariantMoreAvailableThanBeacon\uff0c\u901a\u8fc7\u6bd4\u8f83\u6700\u540e\u4e00\u6b21\u6536\u5230\u7684BM\u4fe1\u6807\u7684\u6709\u6548\u671f\uff0c\u548c\u5bf9\u5e94\u53d8\u91cf\u6240\u5728\u8be5\u8054\u9501\u533a\u7684\u65e0\u7ebf\u53d8\u91cf\uff0c\u5224\u65ad\u5bf9\u4e8e\u8be5\u53d8\u91cf\uff0c\u662f\u4f7f\u7528\u6765\u81eaCI\u65e0\u7ebf\u7684\u53d8\u91cf\u800c\u975e\u6765\u81ea\u4fe1\u6807\u7684\u53d8\u91cf\u3002", "en": "ATP shall use the more recent message from beacons and CBI radio.", "code": "def CBIvariantMoreAvailableThanBeacon(CbiId, k):    if (Initialization        or not TrainLocatedOnKnownPath(k-1)        or not ATPsetting.BlockModeThroughRadio(k)):        return False    else:        return (UsedBMbeaconId(k) is None                or (CBIvariantAge(CbiId, k) <= ATPsetting.VariantsBMfullValidityTime                     and (CBIvariantReportLastAge(CbiId, k)                          <= BMbeaconReadAge(k) + ATPsetting.VariantsBMradioPriorityDelay)                     and (CBIvariantReportLastAge(CbiId, k) <= CBIminProductionAge(CbiId, k))))"}, {"cn": "BMvariantValue\uff0c\u7edf\u4e00\u6765\u81eaBM\u4fe1\u6807\u548cCBI\u65e0\u7ebf\u7684BM\u53d8\u91cf%def BMvariantValue(Variant, k):if (CBIvariantMoreAvailableThanBeacon(Variant.Cbi.Id, k)):return BMcbivariantValue(Variant.Cbi.Id, Variant.Cbi.Index, k)else:return BMbeaconVariantValue(Variant.LineSec.Id, Variant.LineSec.Index, k)#@BMvariantRemainingTime\uff0cBM\u53d8\u91cf\u7684\u5269\u4f59\u6709\u6548\u671f%def BMvariantRemainingTime(cbi, k):if (not BMvariantValidWhileTemporallyValid(k)):return 0elif (CBIvariantMoreAvailableThanBeacon(cbi, k)):return max(0, ATPsetting.VariantsBMfullValidityTime - CBIvariantAge(cbi, k))else:return max(0, ATPsetting.VariantsBMfullValidityTime - BMbeaconReadAge(k))#@VersionAuthorizationReceived\uff0c\u6536\u5230\u7248\u672c\u6388\u6743%def VersionAuthorizationReceived(lcId, k):return Message.Received(VersionAuthorization(lcId), k)#@VersionAuthorizationAvailable\uff0cLC\u7248\u672c\u6388\u6743\u6d88\u606f\u53ef\u7528%def VersionAuthorizationAvailable(lcId, k):return Message.Available(VersionAuthorizationReceived(lcId, k),VersionAuthorization(lcId).CcLoopHour,ATPsetting.VersionsValidityTime,LastVersionReportAge(lcId, k-1),k)#@LastVersionReportAge\uff0c\u8bb0\u5f55\u4ece\u4e0a\u6b21\u6536\u5230LC\u7684\u7248\u672c\u4fe1\u606f\u5230\u73b0\u5728\u7684\u65f6\u95f4\u3002%def LastVersionReportAge(lcId, k):return Message.LastAge(VersionAuthorizationAvailable(lcId, k),VersionAuthorization(lcId).CcLoopHour,LastVersionReportAge(lcId, k-1),k)#@ReceivedVersionMessages\uff0c\u7528\u4e8e\u5b58\u50a8\u4eceLC\u6536\u5230\u7684MAX_ZC_NB\u4e2aZC\u533a\u7684\u6388\u6743\u4fe1\u606f\u3002\u7531\u4e8e\u6bcf\u4e2aZC\u5206\u5c5e\u4e0d\u540c\u7684LC\u7ba1\u7406\uff0c\u56e0\u6b64\u6536\u5230\u7279\u5b9a\u7684LC\u6d88\u606f\u65f6\u5e94\u4ec5\u66f4\u65b0\u5176\u6240\u5bf9\u5e94ZC\u7684\u7248\u672c\u6388\u6743\u72b6\u6001\u3002%def ReceivedVersionMessages(LcId, k):if (Initialization):ReceivedVersionMessages = Noneelif (VersionAuthorizationAvailable(LcId, k)):if (Message.ReplyLocalCC(VersionAuthorization(LcId).CcLoopHour)):NewValidity = (VersionAuthorization(LcId).CcLoopHour+ ATPsetting.VersionsValidityTime)else:NewValidity= (ATPtime(k) + ATPsetting.VersionsValidityTime- (OtherATPmaxTime(k) - VersionAuthorization(LcId).CcLoopHour))for ZcId in range(0, MAX_ZC_NB):if  (TrackMap.Zc[ZcId].LcId == LcId):ReceivedVersionMessages[ZcId].VitalAuthorization= VersionAuthorization(LcId).VitalAuthorization[ZcId]ReceivedVersionMessages[ZcId].ValidityTime = NewValidityelse:passelse:ReceivedVersionMessages = ReceivedVersionMessages(k-1)return ReceivedVersionMessages#@VersionAuthorizedByLC\uff0c\u83b7\u53d6ZC\u7684\u7248\u672c\u6388\u6743\u72b6\u6001%def VersionAuthorizedByLC(ZcId, k):if (Message.IsMoreRecent(ReceivedVersionMessages(TrackMap.Zc[ZcId].LcId ,k)[zcId].ValidityTime,ATPtime(k))):return ReceivedVersionMessages(TrackMap.Zc[ZcId].LcId, k)[zcId].VitalAuthorizationelse:return False#@SameVersionWithDistantCore\uff0c\u6bd4\u8f83\u6765\u81ea\u8fdc\u7aefATP\u7684\u5b89\u5168\u8f6f\u4ef6\uff0c\u9879\u76ee\u914d\u7f6e\u6570\u636e\uff0c\u4ee5\u53ca\u7ebf\u8def\u5730\u56fe\u7248\u672c\u53f7\u4e0e\u672c\u7aef\u662f\u5426\u4e00\u81f4", "en": "The local ATP shall compare the information from the redundant ATP to ensure the consistency, which includes versions of vital software, project configuration data and the track map.", "code": "def SameVersionWithDistantCore(k):    if (OtherATPmessageValid(k)        and (OtherATP.SafetyParameterVersion == ATPsetting.SafetyParameterVersion)        and (OtherATP.SafetyApplicationVersion == SafeApplicationVersion)):        for ZcId in range(0, MAX_ZC_NB):            if (OtherATP.ZcVersion[ZcId] != TrackMap.ZC[ZcId].Version):                return False            else:                continue        else:            return True    else:        return False"}, {"cn": "EOAReportReceived\uff0c\u6536\u5230EOA\u6d88\u606f%def EOAReportReceived(k):return Message.Received(EOAReport, k)#@ZCmessageReady\uff0c\u8868\u793a\u672c\u5468\u671f\u6536\u5230\u4e86\u6709\u6548\u7684\u6765\u81eaZC\u7684EOA\u548c\u53d8\u91cf\u6d88\u606f\u3002\u5f53\u524d\u65f6\u95f4\u5927\u4e8e\u6d88\u606f\u4e2d\u7684ccLoopHour\uff1b\u6d88\u606f\u4e2d\u7684ccLoopHour+EOA\u6709\u6548\u671f\uff0c\u5e94\u5927\u4e8e\u5f53\u524d\u65f6\u95f4\u3002", "en": "ZCmessageReady represents that an available EOA and variants message from ZC received in this cycle.", "code": "def ZCmessageReady(k):    return (Message.Available(EOAReportReceived(k),                                   EOA_Report.CcLoopHour,                                   ATPsetting.EOAvalidityTime,\t                                   LastEOAReportAge(k-1),                                   k)            and (VersionAuthorizedByLC(SSIDofZC, k))            and (Message.ReplyLocalCC(EOA_Report.CcLoopHour)                 or SameVersionWithDistantCore(k)))"}, {"cn": "LastEOAReportAge\uff0c\u6570\u503c\u578b\uff0c\u4e0a\u6b21\u53d1\u51faloc-report\u7684\u5468\u671f\u6570\u51cf\u53bbEOA\u5728ZC\u7aef\u6d88\u8017\u7684\u65f6\u95f4\uff08CC\u5468\u671f\u6570\uff09\u3002", "en": "LastEOAReportAge represents the value calculated by current ATP time minus the previous loc-report number and the EOA consuming time in ZC.", "code": "def LastEOAReportAge(k):    return Message.LastAge(ZCmessageReady(k),                            EOA_Report.CcLoopHour,                            LastEOAReportAge(k-1),                            k)"}, {"cn": "EOAgroundAge\uff0c\u6570\u503c\u578b\uff0c\u5728\u6536\u5230EOA\u6d88\u606f\u65f6\uff0c\u5176\u65f6\u95f4\u5df2\u7ecf\u6d88\u8017\u4e86\u51e0\u4e2aCC\u7684\u5468\u671f\u3002\u9700\u540c\u65f6\u7ef4\u62a4WithoutSpaceEoa\u548c\u666e\u901aEOA\u3002", "en": "EOAgroundAge stands for the number of CC cycle when receiving the EOA information.", "code": "def EOAgroundAge(k):    if (Initialization):        EOAgroundAge.WithoutSpacing = REPORT_AGE_MAX        EOAgroundAge.Classic = REPORT_AGE_MAX    elif (ZCmessageReady(k)):        EOAgroundAge.WithoutSpacing = (round.ceil                                       ((EOA_Report.MessageContainerCreationTime                                         - EOA_Report.WithoutSpacingEoaCreationTime)                                        * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS))        EOAgroundAge.Classic = round.ceil((EOA_Report.MessageContainerCreationTime                                           - EOA_Report.EoaCreationTime)                                          * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS)    else:        EOAgroundAge = EOAgroundAge(k-1)    return EOAgroundAge"}, {"cn": "ReceivedEOAreport\uff0c\u5224\u65ad\u5f53\u65b0\u6536\u5230EOA\u6d88\u606f\u7684\u6709\u6548\u671f\u5927\u4e8e\u4e4b\u524d\u5b58\u50a8EOA\u6d88\u606f\u6709\u6548\u671f\u65f6\uff0c\u66f4\u65b0EOA\u3002\u9700\u540c\u65f6\u7ef4\u62a4WithoutSpaceEoa\u548c\u666e\u901aEOA\u3002\u5f53\u5b58\u50a8\u7684EOA\u6d88\u606f\u8fc7\u671f\u540e\uff0c\u6e05\u9664\u8be5\u6d88\u606f\u3002%def ReceivedEOAreport(k):if (Initialization):ReceivedEOAreport = Noneelif (ZCmessageReady(k)):ReceivedEOAreport.TrainFrontEnd = EOA_Report.TrainFrontEndReceivedEOAreport.Classic = UpdateReceivedEoa(EOA_Report.CcLoopHour,EOAgroundAge(k).Classic,EOA_Report.Classic,ReceivedEOAreport(k-1).Classic)ReceivedEOAreport.WithoutSpacing = (UpdateReceivedEoa(EOA_Report.CcLoopHour,EOAgroundAge(k).WithoutSpacing,EOA_Report.WithoutSpacing,ReceivedEOAreport(k-1).WithoutSpacing))ReceivedEOAreport.CcLoopHour = EOA_Report.CcLoopHourelse:ReceivedEOAreport = ReceivedEOAreport(k-1)if (Message.IsMoreRecent(ATPtime(k), ReceivedEOAreport.Classic.ValidityTime)):clean_reseived_eoa_classicif (Message.IsMoreRecent(ATPtime(k), ReceivedEOAreport.WithoutSpacing.ValidityTime)):clean_reseived_eoa_without_spacereturn ReceivedEOAreportdef UpdateReceivedEoa(NewEoaLoopHour, EoaGroundAge, NewReceivedEoa, PreviousReceivedEoa):if (Message.ReplyLocalCc(NewEoaLoopHour)):NewValidity = (NewEoaLoopHour - EoaGroundAge + ATPsetting.EOAvalidityTime)else:NewValidity = (ATPtime(k) - EoaGroundAge + ATPsetting.EOAvalidityTime- (OtherATPmaxTime(k) - NewEoaLoopHour))if (Message.IsMoreRecent(NewValidity, ATPtime(k))and (Message.IsMoreRecent(NewValidity, PreviousReceivedEoa.ValidityTime))):return NewReceivedEoaelse:return PreviousReceivedEoa#@VariantGroundAge\uff0c\u5c06ZC\u7aef\u7684\u53d8\u91cf\u751f\u5b58\u65f6\u95f4\u8f6c\u6362\u4e3aCC\u5468\u671f\u6570", "en": "VariantGroundAge shows the survival time of the variants in ZC.", "code": "def VariantGroundAge(lineSec, k):    VariantGroundAge = round.ceil((EOA_Report.MessageContainerCreationTime                                         - VariantReport(lineSec).CreationTime)                                        * SYNCHRODATE_TIME_UNIT_MS / ATP_CYCLE_TIME_MS)    return VariantGroundAge"}, {"cn": "VariantReportReceived\uff0c\u6536\u5230ZC\u53d8\u91cf\u6d88\u606f%def VariantReportReceived(LineSec, k):return Message.Received(VariantReport(LineSec), k)#@ReceivedVariantReport\uff0c\u5b58\u50a8\u6765\u81eaZC\u7684\u53d8\u91cf\u6d88\u606f\uff0c\u5982ST_VARIANT_RCV\u6240\u793a\uff0c\u6309\u7167LineSection\u8fdb\u884c\u5b58\u50a8\uff1a%def ReceivedVariantReport(LineSec, k):if (ZCmessageReady(k)and VariantReportReceived(LineSec, k)):if (Message.ReplyLocalCc(ReceivedEOAreport(k).CcLoopHour)):NewValidity = (ReceivedEOAreport(k).CcLoopHour- VariantGroundAge(LineSec, k)+ ATPsetting.VariantsCBTCvalidityTime)else:NewValidity = (ATPtime(k) - VariantGroundAge(LineSec, k)+ ATPsetting.VariantsCBTCvalidityTime- (OtherATPmaxTime(k) - ReceivedEOAreport(k).CcLoopHour))if (Message.IsMoreRecent(NewValidity, ATPtime(k))and (Message.IsMoreRecent(NewValidity, ReceivedVariantReport[LineSec](k-1).ValidityTime))):ReceivedVariantReport[LineSec].ValidityTime = NewValidityReceivedVariantReport[LineSec].Variants = VariantReport(LineSec, Variants)else:ReceivedVariantReport[LineSec] = ReceivedVariantReport[LineSec](k-1)else:ReceivedVariantReport[LineSec] = ReceivedVariantReport[LineSec](k-1)return ReceivedVariantReport#@CBTCvariantValue\uff0c\u7ef4\u62a4CBTC\u4e0b\u53d8\u91cf\u7684\u503c\u3002\u5982\u679c\u53d8\u91cf\u6709\u6548\u671f\u5927\u4e8e\u5f53\u524d\u65f6\u95f4\uff0c\u5219\u4f7f\u7528\u8be5\u53d8\u91cf\uff1b\u5426\u5219\u4e3a\u9650\u5236\u72b6\u6001\u3002", "en": "ATP shall maintain the validation of CBTC variants message from ZC. if the validation timeout, ATP should set all CBTC variants to restrictive state.", "code": "def CBTCvariantValue(Variant, k):    if (ReceivedVariantReport(Variant.LineSec.Id, k).ValidityTime > ATPtime(k)):        return ReceivedVariantReport(Variant.LineSec.Id, k).Status(Variant.LineSec.Index)    else:        return False"}, {"cn": "VariantValue\uff0c\u7edf\u4e00CBTC\u548cBM\u4e0b\u7684\u53d8\u91cf%def VariantValue(Variant, k):if (BlockModeUsed(k)):return BMvariantValue(Variant, k)else:return CBTCvariantValue(Variant, k)#@BeaconCount\uff0cATP\u8bb0\u5f55\u4ece\u4e0a\u7535\u5f00\u59cb\uff0c\u5230\u5f53\u524d\u5468\u671f\u5171\u6536\u5230\u591a\u5c11\u6b21Top-loc\u4fe1\u53f7\u3002", "en": "BeaconCount represents the accumulated number of received Top-loc signal from power on to current cycle.", "code": "if (Initialization)    BeaconCount = 0else:     BeaconCount = LockedTopLocCounter(k) + BeaconCount(k-1)"}, {"cn": "\u5982\u679c\u672c\u5468\u671fBeaconMessageReceive\u4e3aTrue\uff0c\u5219\u4eceLockedBeaconMsgByte\u4e2d\u83b7\u53d6\u4fe1\u6807ID\uff0c\u8bbe\u7f6eBeaconMessage.ID\uff1b\u5176\u4ed6\u60c5\u51b5\u4fdd\u6301\u4e0d\u53d8\u3002", "en": "If the status of BeaconMessageReceive is True, the BeaconMessage.ID is obtained by LockedBeaconMsgByte; Otherwise, keep it unchanged.", "code": "if (Initialization)    BeaconMessage.ID = 0elif (BeaconMessageReceive(k))    BeaconMessage.ID = LockedBeaconMsgByte[BEACON_ID_BITS]else:    BeaconMessage.ID = BeaconMessage.ID(k-1)"}, {"cn": "\u5982\u679c\u672c\u5468\u671fBeaconMessageReceive\u4e3aTrue\uff0c\u5219\u4eceLockedBeaconMsgByte\u4e2d\u83b7\u53d6\u53d8\u91cf\u6570\u636e\uff0c\u8bbe\u7f6e\u6570\u7ec4BeaconMessage.Variants[MAX_BM_VARIANT_NB]\uff1b\u82e5\u672c\u5468\u671f\u672a\u8bfb\u5230\u65b0\u7684\u4fe1\u6807\u5219\u4fdd\u6301\u4e0d\u53d8\u3002\u5176\u4e2dBM_VARIANTS_BIT_0...BM_VARIANTS_BIT_15\u8868\u793a[REF4]\u4e2d\u5b9a\u4e49\u7684\u4fe1\u6807\u6d88\u606f\u4e2d\u8868\u793aBM\u4fe1\u6807\u53d8\u91cf\u7684\u4f4d\u6570\u3002", "en": "If the BeaconMessageReceive is True, the variants is come from LockedBeaconMsgByteand ATP set as BeaconMessage.Variants[MAX_BM_VARIANT_NB]; if there is no beacon read at the end of cycle, there is no changes. BM_VARIANTS_BIT_0...BM_VARIANTS_BIT_15 represents the index of BM beacon variants defined in [REF4].", "code": "if (Initialization)    BeaconMessage.Variants = {0,..,0}elif (BeaconMessageReceive(k))    BeaconMessage.Variants(k)        = {LockedBeaconMsgByte[BM_VARIANTS_BIT_0],            ...,            LockedBeaconMsgByte[BM_VARIANTS_BIT_15]}else:    BeaconMessage.Variants = BeaconMessage.Variants(k-1)"}, {"cn": "\u5982\u679c\u672c\u5468\u671fBeaconMessageReceive\u4e3aTrue\uff0c\u5219\u4eceLockedBeaconMsgByte\u4e2d\u5224\u65ad\u662f\u5426\u9ed8\u8ba4\u6d88\u606f\uff0c\u8bbe\u7f6eBeaconMessage.DefaultMessage\uff1b\u82e5\u672c\u5468\u671f\u672a\u8bfb\u5230\u65b0\u7684\u4fe1\u6807\u5219\u4fdd\u6301\u4e0d\u53d8\u3002\u5176\u4e2dDEFAULT_MESSAGE_BIT\u8868\u793a[REF4]\u4e2d\u5b9a\u4e49\u7684\u4fe1\u6807\u6d88\u606f\u4e2d\u8868\u793a\u4fe1\u6807\u662f\u5426\u4e3a\u9ed8\u8ba4\u6d88\u606f\u7684\u4f4d\u6570\u3002", "en": "If the BeaconMessageReceive is True, the default message is judged by LockedBeaconMsgByteand ATP set the BeaconMessage.DefaultMessage; if there is no new beacon read, it keeps unchanged. DEFAULT_MESSAGE_BIT represents the index of beacon that judges default message, which defined in the [REF4].", "code": "if (Initialization)    BeaconMessage.DefaultMessage = Falseelif (BeaconMessageReceive(k))    BeaconMessage.DefaultMessage(k)        = LockedBeaconMsgByte[DEFAULT_MESSAGE_BIT]else:    BeaconMessage.DefaultMessage = BeaconMessage.DefaultMessage(k-1)"}, {"cn": "\u5982\u679c\u672c\u5468\u671fBeaconMessageReceive\u4e3aTrue\uff0c\u5219\u4eceLockedBeaconMsgByte\u4e2d\u5224\u65ad\u53d8\u91cf\u662f\u5426\u53ef\u7528\u4fe1\u606f\uff0c\u8bbe\u7f6eBeaconMessage.BlockModeVariantAvailable\uff1b\u82e5\u672c\u5468\u671f\u672a\u8bfb\u5230\u65b0\u7684\u4fe1\u6807\u5219\u4fdd\u6301\u4e0d\u53d8\u3002\u5176\u4e2dBLOCK_MODE_VARIANT_AVAILABLE_BIT\u8868\u793a[REF4]\u4e2d\u5b9a\u4e49\u7684\u4fe1\u6807\u6d88\u606f\u4e2d\u8868\u793a\u4fe1\u6807\u6240\u5e26\u53d8\u91cf\u662f\u5426\u53ef\u7528\u7684\u4f4d\u6570\u3002", "en": "If the BeaconMessageReceive is True, it is feasible to judge whether the variants are available through LockedBeaconMsgByte and ATP set as BeaconMessage.BlockModeVariantAvailable; If there is no new beacon read, it keeps invariable. BLOCK_MODE_VARIANT_AVAILABLE_BIT stands for the index of the beacon variants in the beacon message defined in [REF4].", "code": "if (Initialization)    BeaconMessage.BlockModeVariantAvailable = Falseelif (BeaconMessageReceive(k))    BeaconMessage.BlockModeVariantAvailable(k)        = LockedBeaconMsgByte[BLOCK_MODE_VARIANT_AVAILABLE_BIT]else:    BeaconMessage.BlockModeVariantAvailable(k)        = BeaconMessage.BlockModeVariantAvailable(k-1)"}, {"cn": "TeethCounter\uff0cATP\u6839\u636eIdenticalLockedOdometer\u4e2d\u9501\u5b58\u7684\u6700\u540e\u4e00\u4e2a\u4e2d\u65ad\u7684CogCounter\u53d8\u5316\u503c\uff0c\u66f4\u65b0TeethCounter\uff0c\u4f5c\u4e3a\u4e3b\u4efb\u52a1\u4f7f\u7528\u7684\u91cc\u7a0b\u8ba1\u9f7f\u6570\u503c\u3002TeethCounter\u7684\u8ba1\u7b97\u5e94\u8003\u8651\u91cc\u7a0b\u8ba1\u5b89\u88c5\u65b9\u5411\u548cCogCounter\u7684\u5bc4\u5b58\u5668\u53d6\u503c\u8303\u56f4\u3002TeethCounter\u662f\u6709\u7b26\u53f7\u503c\u3002\u5982\u679cTeethCounter\u5927\u4e8e0\uff0c\u5219\u8868\u793a\u91cc\u7a0b\u8ba1\u76f8\u5bf9\u4e8e\u521d\u59cb\u4f4d\u7f6e\u5411\u5217\u8f66END_1\u65b9\u5411\u8f6c\u52a8\uff1b\u53cd\u4e4b\u5982\u679c\u5c0f\u4e8e0\uff0c\u5219\u8868\u793a\u91cc\u7a0b\u8ba1\u76f8\u5bf9\u4e8e\u521d\u59cb\u4f4d\u7f6e\u5411\u5217\u8f66END_2\u65b9\u5411\u8f6c\u52a8\u3002", "en": "TeethCounter used as the odometer cog value in one deferred task, which is the difference of the CogCounter in the last interrupt of adjacent cycle. The calculation of the TeethCounter shall consider the installation direction of the odometer and the register range of the CogCounter. TeethCounter is a signed value. If TeethCounter greater than 0, then means the odometer rotating toward to the train END_1 direction; other hand, if it less than 0, then means the odometer rotating toward to the END_2.", "code": "TeethCounter(k) = TeethCounter(k-1)    + (IdenticalLockedOdometer[ATP_INTERRUPT_NB - 1].CogCounter(k)         - IdenticalLockedOdometer[ATP_INTERRUPT_NB - 1].CogCounter(k-1))       * ATPsetting.CCcoreOdoCogIncreasing[CoreId]"}, {"cn": "CogPositionBeforeTopLoc\uff0cCogPositionAfterTopLoc\uff0c\u5982\u679c\u672c\u5468\u671f\u8bfb\u5230\u4fe1\u6807\uff0c\u5219\u901a\u8fc7IdenticalLockedOdometer\u8ba1\u7b97\u8bfb\u5230\u4fe1\u6807\u77ac\u95f4\u7684\u91cc\u7a0b\u8ba1\u9f7f\u6570\u4fe1\u606f\uff1a\u4f7f\u7528Top-loc\u53d1\u751f\u7684\u524d\u4e00\u4e2a\u4e2d\u65ad\u7684CogCounter\u6765\u66f4\u65b0\u3002CogPositionBeforeTopLoc\uff1b\u4f7f\u7528Top-loc\u53d1\u751f\u65f6\u4e2d\u65ad\u7684CogCounter\u6765\u66f4\u65b0CogPositionAfterTopLoc\uff1b\u5176\u4ed6\u60c5\u51b5\uff0cCogPositionBeforeTopLoc\u548cCogPositionAfterTopLoc\u4fdd\u6301\u4e0d\u53d8\u3002\u5176\u4e2di\u8868\u793a\u9501\u5b58\u6536\u5230Top-loc\u4fe1\u53f7\u7684\u90a3\u4e2a\u4e2d\u65ad\u3002\u5982\u679c\u4e0a\u4e0bCPU\u6536\u5230Top-loc\u76f8\u5dee1\u4e2a\u4e2d\u65ad\uff0c\u5219\u4f7f\u7528\u8f83\u65e9\u7684\u7684\u4e2d\u65ad\u4f5c\u4e3a\u8ba1\u7b97CogPositionBeforeTopLoc\u7684\u4f9d\u636e\uff0c\u800c\u8f83\u8fdf\u7684\u90a3\u4e2a\u4e2d\u65ad\u4f5c\u4e3a\u8ba1\u7b97CogPositionAfterTopLoc\u7684\u4f9d\u636e\u3002", "en": "If a beacon with top-loc received in this cycle, ATP shall record the cog position of the interrupt when and just before the top-loc happen:CogPositionBeforeTopLoc, the CogCounter in the interrupt just before the top-loc happen; CogPositionAfterTopLoc, the CogCounter in the interrupt when the top-loc happen. Which, i means the interrupt received top-loc signal.", "code": "CogPositionBeforeTopLoc(k) = TeethCounter(k-1)   + ((IdenticalLockedOdometer[i-1].CogCounter(k)       - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k-1))       * ATPsetting.CCcoreOdoCogIncreasing[CoreId]))CogPositionAfterTopLoc(k) = TeethCounter(k-1)   + ((IdenticalLockedOdometer[i].CogCounter(k)        - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k-1))      * ATPsetting.CCcoreOdoCogIncreasing[CoreId]))"}, {"cn": "WheelStopped\uff0c\u5982\u679c\u5f53\u524d\u5728\u8fdb\u884c\u4f20\u611f\u5668\u6d4b\u8bd5\uff0c\u4e14\u4efb\u4e00\u4e2d\u65ad\u4e2d\u672a\u53d1\u751f\u4e09\u8def\u5168\u901a\u6216\u5168\u5835\u9519\u8bef\uff0c\u4e14\u4e00\u4e2a\u5468\u671f\u6240\u6709\u4e2d\u65ad\u5185\u4e09\u8def\u4f20\u611f\u5668\u7684\u5bfc\u901a\u72b6\u6001\u90fd\u4e0e\u4e0a\u5468\u671f\u7684\u7ed3\u679c\u76f8\u540c\u65f6\uff0c\u8f93\u51faWheelStopped\u4e3aTrue\u3002\u5426\u5219\u4e3aFalse\u3002", "en": "Wheel shall consider safely stopped WheelStopped at cycle k if the following conditions are fulfilled: sensors test has been performed, and at least one sensor out of three sensors C1, C2, C3 has detected expected sequence,and at least one sensor out of three sensors C1, C2, C3 has not detected expected sequence, and sensors test result combination on three sensors C1, C2, C3 has not changed between cycle k-1 and k.", "code": "if (SensorTestPerformed(k) == True)    WheelStopped(k)     = ((UnconsistentSensorTest(k) == False)       and (SensorSequenceDetected_1 = SensorSequenceDetected_1(k-1))       and (SensorSequenceDetected_2 = SensorSequenceDetected_2(k-1))       and (SensorSequenceDetected_3 = SensorSequenceDetected_3(k-1)))else:    WheelStopped = False"}, {"cn": "WheelFilteredStopped\uff0c\u5224\u65ad\u672c\u5468\u671f\u8f66\u8f6e\u662f\u5426\u5904\u4e8e\u6ee4\u8fc7\u505c\u6b62\u72b6\u6001\uff0c\u89c4\u5219\u5982\u4e0b\uff1a\u5982\u679cWheelFilteredStopped\u4e0a\u5468\u671f\u4e3aFalse\uff0c\u800c\u672c\u5468\u671fWheelStopped\u7531False\u53d8\u4e3aTrue\uff0c\u5219\u8ba4\u4e3a\u672c\u5468\u671f\u4e3aTrue\u3002\u5728\u6b64\u6761\u4ef6\u4e0b\uff0c\u8bb0\u5f55\u505c\u8f66\u65f6\u7684\u9f7f\u6570LastStopCogPosition\u4e3a\u5f53\u524d\u9f7f\u6570\u3002WheelFilteredStopped\u7531True\u53d8\u4e3aFalse\u7684\u6761\u4ef6\uff1a\u9f7f\u6570\u79fb\u52a8\u8d85\u8fc71\u4e2a\u9f7f\u3002", "en": "At cycle k, WheelFilteredStopped shall change from False to True on raising edge of WheelStopped information, That is, if: WheelStopped information was False at cycle k-1,and WheelStopped information was True at cycle k. and then: LastStopCogPosition is assigned to TeethCounter\uff0c At cycle k, WheelFilteredStopped shall change from True to False, according following expression: the cog moved more than one cog;", "code": "def WheelFilteredStopped(k):    if (not WheelFilteredStopped(k-1)        and not WheelStopped(k-1)        and WheelStopped(k)):        LastStopCogPosition = TeethCounter(k)        return True    elif (WheelFilteredStopped(k-1)          and not UnconsistentSensorTest(k)          and abs(TeethCounter(k) - LastStopCogPosition) <= 1):        return True    else:        return False"}, {"cn": "MaxCountCogsRunInCycleExceeded\uff0c\u91cc\u7a0b\u8ba1\u8f6c\u8fc7\u9f7f\u6570\u4e0d\u80fd\u8d85\u8fc7\u5468\u671f\u6700\u5927\u503c\uff0c\u4e5f\u4e0d\u80fd\u8d85\u8fc7\u7684\u76f8\u90bb\u4e2d\u65ad\u7684\u6700\u5927\u503c\u3002", "en": "ATP shall detect whether the cog number counted in adjacent interrupt is greater than the default maximum cog number on cycle or on interrupt.", "code": "def MaxCountCogsRunInCycleExceeded(k):    if (abs(IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k)            - IdenticalLockedOdometer[ATP_INTERRUPT_NB-1].CogCounter(k-1))         > ATPsetting.OdoMaxCogOnCycle):        return True    else:        for i in range(ATP_INTERRUPT_NB-1):            if (abs(IdenticalLockedOdometer[i].CogCounter                     - IdenticalLockedOdometer[i+1].CogCounter)> ATPsetting.OdoMaxCogOnIntrrupt):                return True            else:                continue        return False"}, {"cn": "WheelKinematicsInvalidForCogCount\uff0c\u5982\u679cATP\u68c0\u6d4b\u5230\u67d0\u4e2a\u4e2d\u65ad\u7684\u9f7f\u6570\u8f6c\u8fc7\u6700\u5927\u503c\u65f6\uff0c\u8bbe\u7f6e\u9f7f\u6570\u8ba1\u7b97\u9519\u8bef\u3002", "en": "If the calculated movement exceeds the default one, ATP shall set the wheel kinematics invalid.", "code": "WheelKinematicsInvalidForCogCount = MaxCountCogsRunInCycleExceeded(k))"}, {"cn": "", "en": "If OdometerState is NOT_INITIALIZED at cycle k, and if wheel detected stopped at cycle k, then WheelMinimumMovement and WheelMaximumMovement shall be set to zero.", "code": "if (OdometerState(k) == NOT_INITIALIZED)    if (WheelFilteredStopped(k) == True))         WheelMinimumMovement = 0         WheelMaximumMovement = 0    else:         WheelMinimumMovement = \u2014ATPsetting.MaxMotionPerCycle         WheelMaximumMovement = ATPsetting.MaxMotionPerCycle"}, {"cn": "\u91cc\u7a0b\u8ba1\u72b6\u6001\u7531NOT_INITIALIZED\u53d8\u4e3aWAITING_COG_POSITION_CODE_READY\u7684\u6761\u4ef6\u662f:\u4e0a\u5468\u671f\u5728NOT_INITIALIZED\uff1b\u4e0a\u5468\u671f\u5728WheelFilteredStopped\uff1b\u672c\u5468\u671f\u672aWheelFilteredStopped\u800c\u4e14\u672a\u68c0\u6d4b\u5230\u4f20\u611f\u5668\u6d4b\u8bd5\u5931\u8d25\u3002", "en": "At cycle k, ATP shall consider that OdometerState changes from NOT_INITIALIZED to WAITING_COG_POSITION_CODE_READY if: a falling edge is detected on WheelFilteredStopped information, and sensors test is consistent at cycle k and was consistent at cycle k-1\u3002", "code": "if ((OdometerState(k-1) =  NOT_INITIALIZED)    and (not WheelFilteredStopped(k) and not UnconsistentSensorTest(k))    and (WheelFilteredStopped(k-1))    OdometerState =  WAITING_COG_POSITION_CODE_READY"}, {"cn": "\u82e5\u68c0\u6d4b\u5230\u4f20\u611f\u5668\u4e09\u8def\u5168\u901a\u6216\u5168\u5835\uff0c\u5219\u8fdb\u5165INVALID\u4f20\u611f\u5668\u65e0\u6548\u3002", "en": "At cycle k, ATP shall consider that OdometerState changes from NOT_INITIALIZED to INVALID\uff0cif sensors test is not consistent at cycle k.", "code": "if ((OdometerState(k-1) = NOT_INITIALIZED)    and UnconsistentSensorTest(k))    OdometerState = INVALID"}, {"cn": "InitializationTimer\uff0c\u5728WAITING_COG_POSITION_CODE_READY\u72b6\u6001\u4e0b\u7d2f\u52a0\u521d\u59cb\u5316\u65f6\u95f4.", "en": "ATP shall accumulate the time for waiting cog position ready state.", "code": "if (OdometerState(k-1) == WAITING_COG_POSITION_CODE_READY     and OdometerState(k) == WAITING_COG_POSITION_CODE_READY)    InitializationTimer =  InitializationTimer(k-1) + 1 elif (OdometerState(k-1) != WAITING_COG_POSITION_CODE_READY     and OdometerState(k) == WAITING_COG_POSITION_CODE_READY)    InitializationTimer = 1else:    InitializationTimer = 0"}, {"cn": "\u7531WAITING_COG_POSITION_CODE_READY\u8f6c\u56deNOT_INITIALIZED\u72b6\u6001\u7684\u6761\u4ef6\uff1a", "en": "At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to NOT_INITIALIZED if:wheel is detected stopped (WheelFilteredStopped),and cog position remainsunknown (not OdometerCogPositionReady), and there is no sensors testinconsistency, and time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is strictly less than ATPsetting.OdoInitTimeout", "code": "if (OdometerState(k-1) = WAITING_COG_POSITION_CODE_READY)    and WheelFilteredStopped(k)    and not OdometerCogPositionReady(k)    and not UnconsistentSensorTest(k)    and (InitializationTimer(k) < ATPsetting.OdoInitTimeout)   OdometerState =  NOT_INITIALIZED"}, {"cn": "\u7531WAITING_COG_POSITION_CODE_READY\u8f6c\u5165INITIALIZED\u72b6\u6001\u7684\u6761\u4ef6\uff1a", "en": "At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to INITIALIZEDIf: Cog position is safely known which means that wheel angular position is well-known;and there is no sensors test inconsistency; and time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is strictly less than ATPsetting.OdoInitTimeout.", "code": "if (OdometerState(k-1) == WAITING_COG_POSITION_CODE_READY    and OdometerCogPositionReady(k)    and not UnconsistentSensorTest(k)    and (InitializationTimer(k)< ATPsetting.OdoInitTimeout))    OdometerState = INITIALIZED"}, {"cn": "\u7531WAITING_COG_POSITION_CODE_READY\u8f6c\u5165INVALID\u7684\u6761\u4ef6\uff1a\uffe5At cycle k, ATP shall consider that OdometerState changes from WAITING_COG_POSITION_CODE_READY to INVALID if:sensors test inconsistency is detected, or time elapsed since last time OdometerState was NOT_INITIALIZED (InitializationTimer) is more than or equal to the ATPsetting.OdoInitTimeout\u3002%if (OdometerState(k-1) ==  WAITING_COG_POSITION_CODE_READY)and ((InitializationTimer(k)>= ATPsetting.OdoInitTimeout)or UnconsistentSensorTest(k))OdometerState = INVALID#@\u5728\u91cc\u7a0b\u8ba1\u521d\u59cb\u5316\u9636\u6bb5\uff0cATP\u9700\u6839\u636e\u5f53\u524d\u8f66\u5934\u6fc0\u6d3b\u65b9\u5411\u548c\u4e0a\u5468\u671f\u4f4d\u79fb\u7684\u7ed3\u679c\uff0c\u5bf9\u672c\u5468\u671f\u4f4d\u79fb\u8fdb\u884c\u8fc7\u4f30\u5904\u7406\u3002", "en": "When odometer is initializing, wheel movement shall be over and under estimated considering maximum acceleration per cycle according with the train front:", "code": "if (OdometerState(k) ==  WAITING_COG_POSITION_CODE_READY)    if ((TrainFrontEnd(k-1) == END_2) or (NoUndetectableDanger_2(k-1) == True))         WheelMinimumMovement(k) = WheelMinimumMovement(k-1) + ATPsetting.MaxMotionPerCycle         WheelMaximumMovement(k) = WheelMaximumMovement(k-1) - ATPsetting.MaxMotionPerCycle    else:         WheelMinimumMovement(k) = WheelMinimumMovement(k-1) \u2014 ATPsetting.MaxMotionPerCycle         WheelMaximumMovement(k) = WheelMaximumMovement(k-1) + ATPsetting.MaxMotionPerCycle"}, {"cn": "\u5f53\u4e0a\u5468\u671f\u91cc\u7a0b\u8ba1\u5df2\u5728INITIALIZED\u72b6\u6001\uff0c\u5e76\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\u4e4b\u4e00\u65f6\uff0c\u91cc\u7a0b\u8ba1\u72b6\u6001\u7531INITIALIZED\u53d8\u4e3aINVALID\uff1a\u4f20\u611f\u5668\u6d4b\u8bd5\u68c0\u6d4b\u51fa\u4e09\u8def\u5168\u901a\u5168\u5835\uff1b\u6216\u8005\uff0c\u975e\u505c\u8f66\u72b6\u6001\uff0c\u800c\u4e14\u9f7f\u6570\u9f7f\u53f7\u4e5f\u4e0d\u4e00\u81f4\u3002", "en": "At cycle k, ATP shall consider that OdometerState changes from INITIALIZED to INVALID if:OdometerState was evaluated Initialized at cycle k-1,And:Sensors test result is inconsistent;Or neither wheel filtered stopped nor cog position ready.", "code": "if (OdometerState(k-1) is INITIALIZED     and ((UnconsistentSensorTest(k) == True)           or (not WheelFilteredStopped(k)                and not OdometerCogPositionReady(k)))):    OdometerState = INVALID"}, {"cn": "\u5728INITIALIZED\u72b6\u6001\uff0c\u5982\u679c\u9f7f\u6570\u9f7f\u53f7\u5339\u914d\uff0c\u5219\u8ba1\u7b97\u8f66\u8f6e\u6700\u5927\u6700\u5c0f\u4f4d\u79fb\u4f9d\u636e\u4f2a\u4ee3\u7801\u4e2d\u7684\u516c\u5f0f\uff1a\u5bf9\u4e8e\u8f66\u8f7dATP\u8f6f\u4ef6\u7684\u4f4d\u79fb\uff0c\u5728\u9f7f\u6570\u9f7f\u53f7\u5339\u914d\u7684\u72b6\u6001\u4e0b\uff0c\u65e0\u8bbaATP\u4f4d\u4e8eEND_1\u8fd8\u662fEND_2\uff0c\u4e5f\u65e0\u8bba\u6fc0\u6d3b\u54ea\u6bb5\u8f66\u5934\uff0c\u59cb\u7ec8\u4ee5END_1\u65b9\u5411\u4e3a\u4f4d\u79fb\u7684\u6b63\u65b9\u5411\u3002\u5373\u5f53\u4f4d\u79fb\u5927\u4e8e0\u65f6\uff0c\u8868\u793a\u5217\u8f66\u5411END_1\u7aef\u65b9\u5411\u8fd0\u884c\uff0c\u53cd\u4e4b\u5219\u5411END_2\u7aef\u65b9\u5411\u8fd0\u884c\u3002", "en": "If motion and speed are available at cycle k, then wheel curvilinear movement calculates as follows: When odometer cog-counter-code matched, regardless of ATP in END_1 or END_2, and no matter the activation of train front, the direction towards END_1 is always be set as the positive direction. That is, when the movement is greater than 0, indicating the direction of the train is running to END_1, and vice versa to END_2.", "code": "if (OdometerState(k) is INITIALIZED):    WheelMinimumMovement(k) = MinCogCalibration(k-1) * (TeethCounter(k) \u2014 TeethCounter(k-1))    WheelMaximumMovement(k) = MaxCogCalibration(k-1) * (TeethCounter(k) \u2014 TeethCounter(k-1))"}, {"cn": "\u5728\u65e0\u6548\u72b6\u6001\u505c\u8f66\uff0c\u5e76\u672a\u68c0\u6d4b\u5230\u4f20\u611f\u5668\u9519\u8bef\uff0c\u5219\u80fd\u56de\u5230\u975e\u521d\u59cb\u5316\u72b6\u6001\u3002", "en": "At cycle k, ATP shall consider that OdometerState changes from INVALID to NOT_INITIALIZED if:OdometerState was evaluated Invalid at cycle k-1,and wheel is detected stopped (WheelFilteredStopped),and there is no sensors test inconsistency.", "code": "if (OdometerState(k-1) == INVALID     and WheelFilteredStopped(k)     and not UnconsistentSensorTest(k))    OdometerState = NOT_INITIALIZED"}, {"cn": "\u5728\u91cc\u7a0b\u8ba1\u65e0\u6548\u72b6\u6001\u4e0b\uff0cATP\u76f4\u63a5\u4f7f\u7528\u6d4b\u5f97\u503c\u8ba1\u7b97\u8f66\u8f6e\u4f4d\u79fb\uff08\u56e0\u4e3a\u6b64\u65f6\u5217\u8f66\u8fd0\u52a8\u5b66\u5931\u6548\uff0c\u540e\u7eed\u529f\u80fd\u5e76\u4e0d\u4f7f\u7528\u6d4b\u5f97\u7684\u5217\u8f66\u8f66\u8f6e\u4f4d\u79fb\uff09\u3002", "en": "In invalid status, ATP shall calculate wheel movement by using measured value of the odometer.", "code": "if (OdometerState(k) == INVALID)    WheelMinimumMovement(k) = MinCogCalibration(k-1) * (TeethCounter(k) \u2014 TeethCounter(k-1))    WheelMaximumMovement(k) = MaxCogCalibration(k-1) * (TeethCounter(k) \u2014 TeethCounter(k-1))"}, {"cn": "SensorTestContradiction\uff0c\u5f53\u91cc\u7a0b\u8ba1\u8bfb\u6570\u4e3a0\uff0c\u4f46\u4e2d\u65ad\u4e2d\u5374\u672a\u8fdb\u884c\u4f20\u611f\u5668\u6d4b\u8bd5\u65f6\uff0c\u8bbe\u7f6e\u8be5\u53d8\u91cf\u4e3aTrue\uff0c\u5426\u5219\u4e3aFalse\u3002NoCommunicationWithOdometer\uff0c\u5f53SensorTestContradiction\u4fdd\u6301\u4e3aTrue\u8d85\u8fc7\u9650\u5b9a\u65f6\u95f4\u540e\uff0c\u8bbe\u7f6e\u8be5\u503c\u4e3a\u771f\uff0c\u8868\u660e\u4e2d\u65ad\u4e2d\u7684\u4f20\u611f\u5668\u6d4b\u8bd5\u5224\u65ad\u5931\u8d25\u3002", "en": "ATP shall invalidate wheel kinematic if minimum odometer motion is null and sensors test is not performed for more than ATPsetting.OdoTestContradictionDuration.", "code": "def SensorTestContradiction(k):    return (not WheelFilteredStopped(k)            and TeethCounter(k-1) == TeethCounter(k-2)            and not SensorTestPerformed(k))def NoCommunicationWithOdometer(k):    if (Initialization        or not SensorTestContradiction(k)):        SensorTestContradictionDuration = 0        return False    else:        SensorTestContradictionDuration = SensorTestContradictionDuration(k-1) + 1                if (SensorTestContradictionDuration > ATPsetting.OdoTestContradictionDuration):            return True        else:            return False"}, {"cn": "ValidWheelKinematic\uff0c\u8f66\u8f6e\u8fd0\u52a8\u5b66\u7279\u6027\u6709\u6548.", "en": "Wheel kinematic is valid if odometer is valid, the calculated motion is not greater than the default value, and there is communication with odometer.", "code": "ValidWheelKinematic(k) = ((OdometerState(k) != INVALID)   and (not WheelKinematicsInvalidForCogCount(k))   and (not NoCommunicationWithOdometer(k)))"}, {"cn": "WheelMinSpeed\uff0c\u91cc\u7a0b\u8ba1\u6d4b\u5f97\u8f66\u8f6e\u6700\u5c0f\u901f\u5ea6\uff0c\u975e\u8d1f\u503c\u3002%def WheelMinSpeed(k):return round.floor(abs(WheelMinimumMovement(k)) / ATP_CYCLE_TIME)#@WheelMaxSpeed\uff0cATP\u6839\u636e\u91cc\u7a0b\u8ba1\u6d4b\u5f97\u4f4d\u79fb\u8ba1\u7b97\u8f66\u8f6e\u6700\u5927\u901f\u5ea6\uff0c\u8be5\u503c\u4e3a\u975e\u8d1f\u6570\uff0c\u5e76\u4e14\u5411\u4e0a\u53d6\u6574\u3002", "en": "ATP calculates the maximum wheel speed according to the maximum wheel movement; this value is non-negative and rounded up.", "code": "def WheelMaxSpeed(k):    return round.ceil(abs(WheelMaximumMovement(k)) / ATP_CYCLE_TIME)"}, {"cn": "InstantaneousWheelAcceleration\uff0c\u5728\u8fdb\u884c\u6700\u5927\u4f4d\u79fb\u8fc7\u4f30\u7b97\u6cd5\u4e4b\u524d\uff0c\u9700\u8ba1\u7b97\u77ac\u65f6\u8f66\u8f6e\u52a0\u901f\u5ea6\uff08\u4e3a\u51cf\u5c11\u91c7\u6837\u5468\u671f\u8fc7\u77ed\u4f7f\u5f97\u91c7\u6837\u8bef\u5dee\u5bfc\u81f4\u7684\u52a0\u901f\u5ea6\u5927\u5e45\u53d8\u5316\uff0cATP\u4f7f\u7528\u76f8\u90bb2\u4e2a\u5468\u671f\u7684\u7b97\u672f\u5e73\u5747\u52a0\u901f\u5ea6\u4f5c\u4e3a\u77ac\u65f6\u52a0\u901f\u5ea6\uff09\u3002", "en": "When wheel motion and acceleration are measurable, then instantaneous acceleration computed according following expression:", "code": "def InstantaneousWheelAcceleration(k):    return ((abs(TeethCounter(k) - TeethCounter(k-2))             - abs(TeethCounter(k-2) - TeethCounter(k-4)))            * MaxCogCalibration(k-1) / pow(2*ATP_CYCLE_TIME))"}, {"cn": "FilteredWheelAcceleration\uff0c\u5728\u8fdb\u884c\u6700\u5927\u4f4d\u79fb\u8fc7\u4f30\u7b97\u6cd5\u4e4b\u524d\uff0cATP\u9700\u8ba1\u7b97FILTERED_ACCELERATION_NB\u4e2a\u5468\u671f\u7684\u6ee4\u6ce2\u5e73\u5747\u52a0\u901f\u5ea6", "en": "FilteredWheelAcceleration measurement is the average of InstantaneousWheelAcceleration over FILTERED_ACCELERATION_NB cycles for filtering the fluctuation causing by the sampling period.", "code": "FilteredWheelAcceleration(k) = (InstantaneousWheelAcceleration(k)     + InstantaneousWheelAcceleration(k-1)     + ...     + InstantaneousWheelAcceleration(k-FILTERED_ACCELERATION_NB+1))    / FILTERED_ACCELERATION_NB"}, {"cn": "AverageWheelAcceleration\uff0c\u5728\u8fdb\u884c\u6700\u5927\u4f4d\u79fb\u8fc7\u4f30\u7b97\u6cd5\u4e4b\u524d\uff0cATP\u9700\u8ba1\u7b97AVERAGE_ACCELERATION_NB\u4e2a\u5468\u671f\u7684\u5e73\u5747\u8f66\u8f6e\u52a0\u901f\u5ea6", "en": "When wheel motion and acceleration are measurable, sliding average acceleration at cycle k defined by following expression:", "code": "AverageWheelAcceleration(k) = (InstantaneousWheelAcceleration(k)     + InstantaneousWheelAcceleration(k-1)     + ...     + InstantaneousWheelAcceleration(k-AVERAGE_ACCELERATION_NB+1))    / AVERAGE_ACCELERATION_NB"}, {"cn": "StartBrakingMovementMax\uff0c\u8bb0\u5f55\u7531COASTING\u2192BRAKING\uff0cCOASTING\u2192SLIDING\uff0c\u6216BRAKING\u2192SLIDING\u72b6\u6001\u65f6\u7684\u6700\u5927\u4f4d\u79fb\u3002", "en": "ATP records the maximum movement when the state transferring from COASTING to BRAKING or SLIDING, or from BRAKING to SLIDING.", "code": "def StartBrakingMovementMax(k):    if (Initialization        or (MotionOverEstimationState(k) is COASTING)):        return 0    elif ((MotionOverEstimationState(k-1) is COASTING             and MotionOverEstimationState(k) is BRAKING)            or (MotionOverEstimationState(k-1) is COASTING                 and MotionOverEstimationState(k) is SLIDING)            or (MotionOverEstimationState(k-1) is BRAKING                 and MotionOverEstimationState(k) is SLIDING))):        return MaximumTrainMotion(k-1)    else:        return StartBrakingMovementMax(k-1)"}, {"cn": "MaxMotionDuringBrakingOrSliding\uff0c\u5728\u5236\u52a8\u6216\u8005\u6253\u6ed1\u72b6\u6001\u4e0b\u53cd\u5411\u8fd0\u884c\u7684\u6700\u5927\u4f4d\u79fb.", "en": "ATP shall record the reversed motions during the braking or sliding state.", "code": "if (StartBrakingMovementMax(k-1) > 0)    MaxMotionDuringBrakingOrSliding(k)     = min((MaxMotionDuringBrakingOrSliding(k-1) + WheelMaximumMovement(k)), 0)elif (StartBrakingMovementMax(k-1) < 0)    MaxMotionDuringBrakingOrSliding(k)     = max((MaxMotionDuringBrakingOrSliding(k-1) + WheelMaximumMovement(k)), 0)else:    MaxMotionDuringBrakingOrSliding = 0"}, {"cn": "MaxMotionOdometerSignChanged\uff0c\u7528\u4e8e\u76d1\u63a7\u662f\u5426\u53d1\u751f\u4e86\u6d4b\u5f97\u8f66\u8f6e\u4f4d\u79fb\u53cd\u5411.", "en": "If the reversed motion during braking or sliding state is greater than a project defined distance, ATP shall consider the motion sign changed.", "code": "def MaxMotionOdometerSignChanged(k):    return (sign(StartBrakingMovementMax(k-1)) != sign(WheelMaximumMovement(k))            and (abs(MaxMotionDuringBrakingOrSliding(k))                  > ATPsetting.OdoMinDistAfterSenseChange)) "}, {"cn": "StartSlidingSpeed\uff0c\u8bb0\u5f55\u7531COASTING\u6216BRAKING\u8fdb\u5165SLIDING\u72b6\u6001\u65f6\u7684\u901f\u5ea6\u3002", "en": "ATP shall record the speed when the train begins to slide.", "code": "if (Initialization     or (MotionOverEstimationState(k) == COASTING)     or (MotionOverEstimationState(k) == BRAKING))    StartSlidingSpeed = 0elif (((MotionOverEstimationState(k-1) == COASTING)          or (MotionOverEstimationState(k-1) == BRAKING))       and (MotionOverEstimationState(k) == SLIDING))    StartSlidingSpeed = WheelMaxSpeed(k-1)else:    StartSlidingSpeed = StartSlidingSpeed(k-1)"}, {"cn": "TimeInSliding\uff0c\u8bb0\u5f55\u5728SLINDING\u72b6\u6001\u4e0b\u6301\u7eed\u4e86\u591a\u5c11\u4e2a\u5468\u671f.", "en": "ATP shall record how many cycles staying in SLIDING state.", "code": "if (Initialization     or ((MotionOverEstimationState(k-1) == SLIDING)          and (MotionOverEstimationState(k) != SLIDING)))    TimeInSliding = 0elif (MotionOverEstimationState(k) == SLIDING)    TimeInSliding = TimeInSliding(k-1) + 1else:    TimeInSliding = TimeInSliding(k-1)"}, {"cn": "\u5f53\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\u65f6\uff0cMotionOverEstimationState\u7531COASTING\u8f6c\u5165BRAKING\uff0c\u5e76\u6267\u884c\uff1a", "en": "The state transfers from \u201cCOASTING\u201d to \u201cBRAKING\u201d when:", "code": "if ((MotionOverEstimationState(k-1) == COASTING)    and (WheelFilteredStopped(k) != True)    and (FilteredWheelAcceleration(k)< ATPsetting.BrakingStartAcc)    and (FilteredWheelAcceleration(k)>= ATPsetting.SlidingStartAcc)    and OdometerState(k) is INITIALIZED)    MotionOverEstimationState = BRAKING"}, {"cn": "", "en": "The MotionOverEstimationState transfers from \u201cCOASTING\u201d to \u201cSLIDING\u201d when:", "code": "if ((MotionOverEstimationState(k-1) == COASTING)    and (WheelFilteredStopped(k) != True)    and (FilteredWheelAcceleration(k) < ATPsetting.SlidingStartAcc)    and OdometerState(k) is INITIALIZED)    MotionOverEstimationState = SLIDING"}, {"cn": "", "en": "The MotionOverEstimationState transfers from \u201cBRAKING\u201d to \u201cSLIDING\u201d when:", "code": "if (MotionOverEstimationState(k-1) == BRAKING    and (FilteredWheelAcceleration(k) < ATPsetting.SlidingStartAcc)    and (AverageWheelAcceleration(k) < ATPsetting.BrakingStartAcc)    and (OdometerState(k) is INITIALIZED)    and (not MaxMotionOdometerSignChanged(k)))    MotionOverEstimationState = SLIDING"}, {"cn": "", "en": "The MotionOverEstimationState transfers from \u201cBRAKING\u201d to \u201cCOASTING\u201d when:", "code": "if (MotionOverEstimationState(k-1) == BRAKING    and ((AverageWheelAcceleration(k)>= ATPsetting.BrakingStartAcc)          or (OdometerState(k) is INVALID)          or (MaxMotionOdometerSignChanged(k))))    MotionOverEstimationState = COASTING"}, {"cn": "", "en": "The MotionOverEstimationState transfers from \u201cSLIDING\u201d to \u201cCOASTING\u201d when:", "code": "if ((MotionOverEstimationState(k-1) == SLIDING)     and ((OdometerState(k) is INVALID)           or (MaxMotionOdometerSignChanged(k) == True))    MotionOverEstimationState = COASTING"}, {"cn": "SlidingEnded\uff0c\u5224\u65ad\u662f\u5426\u7ed3\u675f\u6253\u6ed1\u72b6\u6001\u7684\u6761\u4ef6\u4e4b\u4e00\u3002", "en": "At cycle k, if motion overestimation status is SLIDING, ATP shall consider that sliding effect is ended (SlidingEnded) if FilteredWheelAcceleration is strictly less than ATPsetting.SlippingStopAcc and strictly greater than ATPsetting.SlidingStopAcc for more than ATPsetting.SlidingGripRecoveryTime.", "code": "if (MotionOverEstimationState(k-1) == SLIDING    and (FilteredWheelAcceleration(k) < ATPsetting.SlippingStopAcc)    and (FilteredWheelAcceleration(k) > ATPsetting.SlidingStopAcc)    and (MotionOverEstimationState(k-2) == SLIDING)    and (FilteredWheelAcceleration(k-1) < ATPsetting.SlippingStopAcc)    and (FilteredWheelAcceleration(k-1) > ATPsetting.SlidingStopAcc)    ...    and (MotionOverEstimationState(k-ATPsetting.SlidingGripRecoveryTime) == SLIDING)    and (FilteredWheelAcceleration(k-ATPsetting.SlidingGripRecoveryTime+1)           < ATPsetting.SlippingStopAcc)    and (FilteredWheelAcceleration(k-ATPsetting.SlidingGripRecoveryTime+1)           > ATPsetting.SlidingStopAcc))    SlidingEnded = Trueelse:    SlidingEnded = False"}, {"cn": "", "en": "The MotionOverEstimationState transfers from \u201cSLIDING\u201d to \u201cBRAKING\u201d when:", "code": "if ((MotionOverEstimationState(k-1) == SLIDING)     and (OdometerState(k) is INITIALIZED)     and (not MaxMotionOdometerSignChanged(k))     and (TimeInSliding(k-1) <= ATPsetting.SlidingTimeout)     and (0 < (|StartSlidingSpeed(k-1)| + TimeInSliding(k-1)* ATPsetting.SlidingStopAcc))     and ((|StartSlidingSpeed(k-1)| + TimeInSliding(k-1)* ATPsetting.SlidingStopAcc)           < |WheelMaxSpeed(k)|)     and (SlidingEnded(k) == True))    MotionOverEstimationState = BRAKING"}, {"cn": "SlidingExcess\uff0c\u6d4b\u5f97\u7684\u52a0\u901f\u5ea6\u5728\u9879\u76ee\u914d\u7f6e\u8303\u56f4\u5185\u6ee1\u8db3\u4e00\u5b9a\u65f6\u95f4\uff0c\u662fATP\u5224\u65ad\u8fc7\u5ea6\u6253\u6ed1\u7684\u5fc5\u8981\u6761\u4ef6\u4e4b\u4e00\u3002", "en": "At cycle k, if motion overestimation status is SLIDING, ATP shall consider that sliding is excess (SlidingExcess) if FilteredWheelAcceleration is strictly less than ATPsetting.SlippingStopAcc and strictly greater than ATPsetting.SlidingStopAcc for more than ATPsetting.SlidingExcessTime.", "code": "if (MotionOverEstimationState(k-1) == SLIDING    and (FilteredWheelAcceleration(k) < ATPsetting.SlippingStopAcc)    and (FilteredWheelAcceleration(k) > ATPsetting.SlidingStopAcc)    and (MotionOverEstimationState(k-2) == SLIDING)    and (FilteredWheelAcceleration(k-1) < ATPsetting.SlippingStopAcc)    and (FilteredWheelAcceleration(k-1) > ATPsetting.SlidingStopAcc)    ...    and (MotionOverEstimationState(k-ATPsetting.SlidingExcessTime) == SLIDING)    and (FilteredWheelAcceleration(k-ATPsetting.SlidingExcessTime+1)           < ATPsetting.SlippingStopAcc)    and (FilteredWheelAcceleration(k-ATPsetting.SlidingExcessTime+1)           > ATPsetting.SlidingStopAcc))    SlidingExcess = Trueelse:    SlidingExcess = False"}, {"cn": "", "en": "The MotionOverEstimationState transfers from SLIDING to SKIDDING when:", "code": "if (MotionOverEstimationState(k-1) is SLIDING     and OdometerState(k) is INITIALIZED     and not MaxMotionOdometerSignChanged(k)     and (TimeInSliding(k-1) > ATPsetting.SlidingTimeout          or (StartSlidingSpeed(k-1)+ TimeInSliding(k-1) * ATPsetting.SlidingStopAcc) <= 0           or (((StartSlidingSpeed(k-1) + TimeInSliding(k-1)* ATPsetting.SlidingStopAcc)                >= WheelMaxSpeed(k))               and SlidingExcess(k))))    MotionOverEstimationState = SKIDDING"}, {"cn": "\u7531\u4e8e\u5f53\u524d\u9879\u76ee\u5e94\u7528\u7684\u8f66\u8f86\u90fd\u88c5\u6709ABS\u9632\u62b1\u6b7b\u7cfb\u7edf\uff0c\u4f7f\u5f97\u5728\u5236\u52a8\u65f6\u5217\u8f66\u7684\u52a0\u901f\u5ea6\u4e0d\u4f1a\u8fde\u7eed\u82e5\u5e72\u5468\u671f\u5c0f\u4e8eATPsetting.SlidingStopAcc\u3002\u56e0\u6b64\uff0c\u5982\u679c\u67d0\u5468\u671f\u77ac\u95f4\u52a0\u901f\u5ea6\u5c0f\u4e8eATPsetting.SlidingStopAcc\uff1b\u5e76\u4e14\u5728\u4e4b\u540e\u7684\u6d4b\u5f97\u52a0\u901f\u5ea6\u6ee1\u8db3SlidingExcess\u6761\u4ef6\uff0c\u90a3\u4e48\uff0c\u4e0b\u5217\u4e24\u4e2a\u6761\u4ef6\u53ef\u4ee5\u540c\u65f6\u6210\u7acb\uff1a", "en": "Because the application of anti-lock braking system for the train of current project, makes the brake acceleration cannot continuous less than ATPsetting.SlidingStopAcc for serious cycles. Therefore, if there was an unexpected instantaneous acceleration less than ATPsetting.SlidingStopAcc, and the after cycles' acceleration met the criteria of SlidingExcess, then the following two conditions can hold simultaneously.", "code": "|StartSlidingSpeed(k-1)| + TimeInSliding(k) * ATPsetting.SlidingStopAcc >= |WheelMaxSpeed(k)|)AND (SlidingExcess(k) == True)"}, {"cn": "", "en": "The MotionOverEstimationState transfers from SKIDDING to COASTING when:", "code": "if (MotionOverEstimationState(k-1) is SKIDDING     and (WheelFilteredStopped(k)           or OdometerState(k) is INVALID))    MotionOverEstimationState = COASTING"}, {"cn": "StartBrakingMovementMin\uff0c\u8bb0\u5f55\u7531COASTING\u8fdb\u5165BRAKING\uff0cCOASTING\u8fdb\u5165SLIDING\uff0c\u6216\u8005BRAKING\u8fdb\u5165SLIDING\u72b6\u6001\u65f6\u7684\u6700\u5c0f\u4f4d\u79fb\u3002", "en": "ATP records the minimum movement when the state transferring from COASTING to BRAKING or SLIDING, or from BRAKING to SLIDING.", "code": "def StartBrakingMovementMin(k):    if (Initialization        or OdometerState(k-1) is not INITIALIZED        or (MotionOverEstimationState(k) is COASTING)):        return 0    elif ((MotionOverEstimationState(k-1) is COASTING             and MotionOverEstimationState(k) is BRAKING)           or (MotionOverEstimationState(k-1) is COASTING               and MotionOverEstimationState(k) is SLIDING)           or (MotionOverEstimationState(k-1) is BRAKING                and MotionOverEstimationState(k) is SLIDING)):        return MinimumTrainMotion(k-1)    else:        return StartBrakingMovementMin(k-1)"}, {"cn": "OverestimatedMotionMin\uff0c\u6839\u636e\u6253\u6ed1\u72b6\u6001\u673a\uff0c\u5bf9\u91cc\u7a0b\u8ba1\u6d4b\u5f97\u7684\u6700\u5c0f\u4f4d\u79fb\u8fdb\u884c\u8865\u507f\u3002\u5728BRAKING\u6216SLIDING\u72b6\u6001\u65f6\uff0c\u7531\u4e8e\u8f66\u8f86ABS\u7684\u4f5c\u7528\uff0c\u4f1a\u5728\u77ac\u95f4\u91ca\u653e\u5236\u52a8\u800c\u4f7f\u5f97\u8f6c\u901f\u7a81\u7136\u589e\u5927\uff0c\u53ef\u80fd\u63a5\u8fd1\u4f46\u4e0d\u4f1a\u5927\u4e8e\u8fdb\u5165\u5236\u52a8\u72b6\u6001\u65f6\u523b\u7684\u901f\u5ea6\u3002\u800c\u7531\u4e8e\u83b7\u53d6\u91cc\u7a0b\u8ba1\u8bfb\u503c\u67091\u4e2a\u9f7f\u7684\u91c7\u6837\u8bef\u5dee\uff0c\u5728\u8be5\u8bef\u5dee\u7684\u4f5c\u7528\u4e0b\uff0c\u53ef\u80fd\u4f1a\u4f7f\u5f97\u6d4b\u5f97\u4f4d\u79fb\u5927\u4e8e\u8fdb\u5165\u5236\u52a8\u72b6\u6001\u65f6\u523b\u7684\u4f4d\u79fb\uff0c\u5373\u51fa\u73b0\u6d4b\u5f97\u8f66\u8f6e\u6700\u5c0f\u4f4d\u79fb\u5927\u4e8e\u5217\u8f66\u6700\u5927\u4f4d\u79fb\u7684\u60c5\u5f62\u3002\u4e3a\u9632\u6b62\u8fd9\u79cd\u60c5\u51b5\uff0c\u9700\u8981\u5bf9\u5217\u8f66\u6700\u5c0f\u4f4d\u79fb\u8fdb\u884c\u8c03\u6574\uff0c\u5373\u59cb\u7ec8\u4f7f\u7528\u8fdb\u5165\u5236\u52a8\u72b6\u6001\u65f6\u523b\u4e0e\u6d4b\u5f97\u8f66\u8f6e\u6700\u5c0f\u4f4d\u79fb\u4e2d\u7edd\u5bf9\u503c\u8f83\u5c0f\u7684\u4e00\u4e2a\u3002\u5176\u4ed6\u60c5\u51b5\uff0c\u65e0\u9700\u8865\u507f\uff0c\u4f7f\u7528\u6d4b\u5f97\u4f4d\u79fb\u3002%def OverstimatedMotionMin(k):if (sign(StartBrakingMovementMin(k)) == sign(WheelMinimumMovement(k))and (MotionOverEstimationState (k) is BRAKINGor MotionOverEstimationState (k) is SLIDING)):if (StartBrakingMovementMin(k) >= 0):return min(StartBrakingMovementMin(k), WheelMinimumMovement(k))else:return (-1 * min(abs(StartBrakingMovementMin(k)), abs(WheelMinimumMovement(k))))else:return WheelMinimumMovement(k)#@OverestimatedMotionMax\uff0c\u6839\u636e\u6253\u6ed1\u72b6\u6001\u673a\uff0c\u5bf9\u91cc\u7a0b\u8ba1\u6d4b\u5f97\u7684\u6700\u5927\u4f4d\u79fb\u8fdb\u884c\u8865\u507f\u3002\u5982\u679c\u672c\u5468\u671f\u5728BRAKING\u72b6\u6001\uff0c\u6309\u5982\u4e0b\u89c4\u5219\u66f4\u65b0\u5217\u8f66\u6700\u5927\u4f4d\u79fb\uff1a\u5982\u679c\u672c\u5468\u671f\u6d4b\u5f97\u8f66\u8f6e\u4f4d\u79fb\u4e0eStartBrakingMovementMax\u65b9\u5411\u76f8\u540c\uff0c\u4e14\u524d\u8005\u7684\u7edd\u5bf9\u503c\u5927\u4e8e\u540e\u8005\u7684\u7edd\u5bf9\u503c\uff0c\u8868\u660e\u7531\u4e8e\u91c7\u6837\u9f7f\u6570\u6ce2\u52a8\uff0c\u6d4b\u5f97\u4f4d\u79fb\u5927\u4e8eStartBrakingMovementMax\uff0c\u6b64\u65f6\u4f7f\u7528\u6d4b\u5f97\u4f4d\u79fb\u4f5c\u4e3a\u6700\u5927\u5217\u8f66\u4f4d\u79fb\uff1b\u5426\u5219\uff0c\u6839\u636e\u914d\u7f6e\u5bf9\u6d4b\u5f97\u4f4d\u79fb\u8fdb\u884c\u8865\u507f\uff0c\u53d6StartBrakingMovementMax\u4e0e\u8865\u507f\u540e\u7684\u6d4b\u5f97\u4f4d\u79fb\u4e2d\u7edd\u5bf9\u503c\u8f83\u5c0f\u7684\u4e00\u4e2a\uff0c\u4f4d\u79fb\u65b9\u5411\u4e0eStartBrakingMovementMax\u76f8\u540c\u3002\u5982\u679c\u672c\u5468\u671f\u5728SLIDING\u72b6\u6001\u65f6\uff0c\u6309\u5982\u4e0b\u89c4\u5219\u66f4\u65b0\u5217\u8f66\u6700\u5927\u4f4d\u79fb\uff1a\u5982\u679c\u672c\u5468\u671f\u6d4b\u5f97\u8f66\u8f6e\u4f4d\u79fb\u4e0eStartBrakingMovementMax\u65b9\u5411\u76f8\u540c\uff0c\u4e14\u524d\u8005\u7684\u7edd\u5bf9\u503c\u5927\u4e8e\u540e\u8005\u7684\u7edd\u5bf9\u503c\uff0c\u8868\u660e\u7531\u4e8e\u91c7\u6837\u9f7f\u6570\u6ce2\u52a8\uff0c\u4f7f\u5f97\u6d4b\u5f97\u4f4d\u79fb\u5927\u4e8eStartBrakingMovementMax\u3002\u6b64\u65f6\u4f7f\u7528\u6d4b\u5f97\u4f4d\u79fb\u4f5c\u4e3a\u6700\u5927\u5217\u8f66\u4f4d\u79fb\uff1b\u5426\u5219\uff0c\u4f7f\u7528StartBrakingMovementMax\u3002\u5176\u4ed6\u72b6\u6001\u4e0b\uff0c\u65e0\u9700\u5bf9\u6d4b\u5f97\u6700\u5927\u4f4d\u79fb\u8fdb\u884c\u8865\u507f\u3002", "en": "In BRAKING state, the maximum train motion overestimated as ATPsetting.SlidingCoefficient (15% normally) at most. If the overestimated motion has greater than the start braking movement, ATP shall use the start breaking movement as the current train motion. That said the train speed during braking could not faster than before. In state SLIDING: If both WheelMaximumMovement and StartBrakingMovementMax are same direction, and the absolute value of the former is greater than the absolute value of the latter, indicating that due to the sampling error makes the measured movement greater than StartBrakingMovementMax. In this case, ATP shall uses WheelMaximumMovement as current train maximum motion.Otherwise, uses StartBrakingMovementMax as train maximum motion. In other state (COASTING, SKIDDING), uses measured wheel maximum movement as current overestimated maximum train motion.", "code": "def OverestimatedMotionMax(k):    if MotionOverEstimationState(k) is BRAKING:        if (sign(StartBrakingMovementMax(k)) == sign(WheelMaximumMovement(k))                and abs(WheelMaximumMovement(k)) > abs(StartBrakingMovementMax(k))):            return WheelMaximumMovement(k)         elif (StartBrakingMovementMax(k) >= 0):            return min(abs(StartBrakingMovementMax(k)),                       abs(WheelMaximumMovement(k) * ATPsetting.SlidingCoefficient))        else:            return -1 * min(abs(StartBrakingMovementMax(k)),                            abs(WheelMaximumMovement(k) * ATPsetting.SlidingCoefficient))    elif MotionOverEstimationState(k) is SLIDING:        if (sign(StartBrakingMovementMax(k)) == sign(WheelMaximumMovement(k))                and abs(WheelMaximumMovement(k)) > abs(StartBrakingMovementMax(k))):            return WheelMaximumMovement(k)        else:            return StartBrakingMovementMax(k)    else:  # Coasting and Skidding        return WheelMaximumMovement(k)"}, {"cn": "StartSlippingSpeed\uff0c\u8bb0\u5f55\u7531COASTING\u6216MOTORING\u8fdb\u5165SLIPPING\u72b6\u6001\u65f6\u7684\u901f\u5ea6\u3002", "en": "ATP shall record the speed when the train begins to slip.", "code": "def StartSlippingSpeed(k):    if (Initialization        or OdometerState(k-1) is not INITIALIZED        or MotionUnderEstimationState(k) is COASTING        or MotionUnderEstimationState(k) is MOTORING):        return 0    elif ((MotionUnderEstimationState(k-1) is COASTING            or MotionUnderEstimationState(k-1) is MOTORING)           and MotionUnderEstimationState(k) is SLIPPING):        return WheelMinSpeed(k-1)    else:        return StartSlippingSpeed(k-1)"}, {"cn": "TimeInSlipping\uff0c\u8bb0\u5f55\u5728SLIPPING\u72b6\u6001\u4e0b\u6301\u7eed\u4e86\u591a\u5c11\u4e2a\u5468\u671f.", "en": "ATP shall record how many cycles staying in SLIPPING state.", "code": "def TimeInSlipping(k):    if (Initialization        or (MotionUnderEstimationState(k-1) is SLIPPING            and MotionUnderEstimationState(k) is not SLIPPING)):        return 0    elif (MotionUnderEstimationState(k) is SLIPPING):        return TimeInSlipping(k-1) + 1    else:        return TimeInSlipping(k-1)"}, {"cn": "OdometerAxleMotorized\uff0c\u8868\u793a\u9700\u8003\u8651\u91cc\u7a0b\u8ba1\u6240\u5b89\u5728\u8f66\u8f74\u7275\u5f15\u5bfc\u81f4\u7684\u7a7a\u8f6c\u3002", "en": "If the project that odometer installed on the traction axle of the train, ATP shall consider the slipping effect to impact the underestimation of measured wheel movement.", "code": "def OdometerAxleMotorized(k):    return not ATPsetting.OdoNotOnMotorizedAxle"}, {"cn": "", "en": "The MotionUnderEstimationState transfers from \u201cCOASTING\u201d to \u201cMOTORING\u201d when:", "code": "if (MotionUnderEstimationState(k-1) is COASTING    and OdometerAxleMotorized(k)    and FilteredWheelAcceleration(k) <= ATPsetting.SlippingStartAcc    and FilteredWheelAcceleration(k) > ATPsetting.TractionStartAcc    and OdometerState(k) is INITIALIZED)    MotionUnderEstimationState = MOTORING"}, {"cn": "", "en": "The MotionUnderEstimationState transfers from \u201cCOASTING\u201d to \u201cSLIPPING\u201d when:", "code": "if (MotionUnderEstimationState(k-1) is COASTING    and OdometerAxleMotorized(k)    and FilteredWheelAcceleration(k) > ATPsetting.SlippingStartAcc    and OdometerState(k) is INITIALIZED)    MotionUnderEstimationState = SLIPPING"}, {"cn": "", "en": "The MotionUnderEstimationState transfers from \u201cMOTORING\u201d to \u201cSLIPPING\u201d when:", "code": "if (MotionUnderEstimationState(k-1) is MOTORING    and FilteredWheelAcceleration(k) > ATPsetting.SlippingStartAcc    and AverageWheelAcceleration(k) > ATPsetting.MotoringStartAc)    and OdometerState(k) is INITIALIZED    and OdometerAxleMotorized(k))    MotionUnderEstimationState = SLIDING"}, {"cn": "", "en": "The MotionUnderEstimationState transfers from MOTORING to COASTING\u201d when:", "code": "if (MotionUnderEstimationState(k-1) is MOTORING    and (AverageWheelAcceleration(k) <= ATPsetting.TractionStartAcc          or OdometerState(k) is INVALID          or not OdometerAxleMotorized(k)))    MotionUnderEstimationState = COASTING"}, {"cn": "", "en": "The MotionUnderEstimationState transfers from SLIPPING to COASTING when:", "code": "if (MotionUnderEstimationState(k-1) is SLIPPING     and (OdometerState(k) is INVALID           or not OdometerAxleMotorized(k)))    MotionUnderEstimationState = COASTING"}, {"cn": "SlippingEnded\uff0c\u5224\u65ad\u662f\u5426\u7ed3\u675f\u7a7a\u8f6c\u72b6\u6001\u7684\u6761\u4ef6\u4e4b\u4e00\u3002%def SlippingEnded(k):if (MotionUnderEstimationState(k-1) is not SLIPPING):slipping_ended_counter = 0return Falseelif (FilteredWheelAcceleration(k) < ATPsetting.SlippingStopAccand FilteredWheelAcceleration(k) > ATPsetting.SlidingStopAcc):slipping_ended_counter = slipping_ended_counter + 1return (slipping_ended_counter >= ATPsetting.SlippingGripRecoveryTime)#", "en": "The MotionUnderEstimationState transfers from SLIPPING to MOTORING when:", "code": "if (MotionUnderEstimationState(k-1) is SLIPPING     and OdometerState(k) is INITIALIZED     and OdometerAxleMotorized(k)     and TimeInSlipping(k-1) <= ATPsetting.SlippingTimeout     and ((StartSlippingSpeed(k-1) + TimeInSlipping(k-1)* ATPsetting.SlippingStopAcc)           > WheelMinSpeed(k))     and SlippingEnded(k))    MotionUnderEstimationState = MOTORING"}, {"cn": "SlippingExcess\uff0c\u6d4b\u5f97\u7684\u52a0\u901f\u5ea6\u5728\u9879\u76ee\u914d\u7f6e\u8303\u56f4\u5185\u6ee1\u8db3\u4e00\u5b9a\u65f6\u95f4\uff0c\u662fATP\u5224\u65ad\u8fc7\u5ea6\u7a7a\u8f6c\u7684\u5fc5\u8981\u6761\u4ef6\u4e4b\u4e00\u3002%def SlippingExcess(k):if (MotionUnderEstimationState(k-1) is not SLIPPING):slipping_excess_counter = 0return Falseelif (FilteredWheelAcceleration(k) < ATPsetting.SlippingStopAccand FilteredWheelAcceleration(k) > ATPsetting.SlidingStopAcc):slipping_excess_counter = slipping_excess_counter + 1return (slipping_excess_counter >= ATPsetting.SlippingExcessTime)#", "en": "The MotionUnderEstimationState transfers from SLIPPING to SKIDDING when:", "code": "if (MotionUnderEstimationState(k-1) is SLIPPING     and OdometerState(k) is INITIALIZED     and OdometerAxleMotorized(k)     and (TimeInSlipping(k-1) > ATPsetting.SlippingTimeout          or (((StartSlippingSpeed(k-1) + TimeInSlipping(k-1)* ATPsetting.SlippingStopAcc)                <= WheelMinSpeed(k))               and SlippingExcess(k))))    MotionUnderEstimationState = SKIDDING"}, {"cn": "", "en": "The MotionUnderEstimationState transfers from SKIDDING to COASTING when:", "code": "if (MotionUnderEstimationState(k-1) is SKIDDING     and (WheelFilteredStopped(k)           or OdometerState(k) is INVALID))    MotionUnderEstimationState = COASTING"}, {"cn": "StartMotoringMovementMin\uff0c\u8bb0\u5f55\u7531COASTING\u8fdb\u5165MOTORING\uff0cCOASTING\u8fdb\u5165SLIPPING\uff0c\u6216\u8005MOTORING\u8fdb\u5165SLIPPING\u72b6\u6001\u65f6\u7684\u6700\u5c0f\u4f4d\u79fb\u3002", "en": "ATP records the minimum movement when the state transferring from COASTING to MOTORING or SLIPPING, or from MOTORING to SLIPPING.", "code": "def StartMotoringMovementMin(k):    if (Initialization        or OdometerState(k-1) is not INITIALIZED        or (MotionUnderEstimationState(k) is COASTING)):        return 0    elif ((MotionUnderEstimationState(k-1) is COASTING             and MotionUnderEstimationState (k) is MOTORING)           or (MotionUnderEstimationState(k-1) is COASTING               and MotionUnderEstimationState (k) is SLIPPING)           or (MotionUnderEstimationState(k-1) is MOTORING                and MotionUnderEstimationState(k) is SLIPPING)):        return MinimumTrainMotion(k-1)    else:        return StartMotoringMovementMin(k-1)"}, {"cn": "UnderestimatedMotionMin\uff0c\u6839\u636e\u7a7a\u8f6c\u72b6\u6001\u673a\uff0c\u5bf9\u91cc\u7a0b\u8ba1\u6d4b\u5f97\u7684\u6700\u5c0f\u4f4d\u79fb\u8fdb\u884c\u8865\u507f\u3002\u5728MOTORING\u72b6\u6001\u4e0b\uff0c\u4f7f\u7528\u7275\u5f15\u5165\u53e3\u4f4d\u79fb\u548c\u5c06\u6d4b\u5f97\u4f4d\u79fb\u4f4e\u4f3015%\u8865\u507f\u540e\u4e8c\u8005\u8f83\u5927\u7684\u4e00\u4e2a\uff0c\u4f5c\u4e3a\u8865\u507f\u540e\u7684\u4f4d\u79fb\u3002\u5728SLIPPING\u72b6\u6001\u4e0b\uff0c\u4f7f\u7528\u7275\u5f15\u5165\u53e3\u4f4d\u79fb\u4f5c\u4e3a\u8865\u507f\u540e\u7684\u4f4d\u79fb\u3002%def UnderestimatedMotionMin(k):if MotionUnderEstimationState(k) is MOTORING:if (WheelMinimumMovement(k) >= 0):return max(abs(StartMotoringMovementMin(k)),abs(WheelMinimumMovement(k) * ATPsetting.SlippingCoefficient))else:return -1 * max(abs(StartMotoringMovementMin(k)),abs(WheelMinimumMovement(k) * ATPsetting.SlippingCoefficient))elif MotionUnderEstimationState(k) is SLIPPING:return StartMotoringMovementMin(k)else:return WheelMinimumMovement(k)#@UnderestimatedMotionMax\uff0c\u6839\u636e\u7a7a\u8f6c\u72b6\u6001\u673a\uff0c\u5bf9\u91cc\u7a0b\u8ba1\u6d4b\u5f97\u7684\u6700\u5927\u4f4d\u79fb\u8fdb\u884c\u8865\u507f\u3002%def UnderestimatedMotionMax(k):return WheelMaximumMovement(k)#@SlipSlideDetected\uff0c\u662f\u5426\u68c0\u6d4b\u5230\u6253\u6ed1\u7a7a\u8f6c", "en": "For calibration validation purpose, ATP shall consider that slip/side detected if:motion overestimation modeling status is not coasting nor braking,or motion underestimation modeling status is not coasting nor motoring.", "code": "SlipSlideDetected(k) = ((MotionOverEstimationState(k) !=  COASTING      and MotionOverEstimationState(k) !=  BRAKING)   or (MotionUnderEstimationState(k) !=  COASTING        and MotionUnderEstimationState(k) !=  MOTORING))"}, {"cn": "SlipSlideModellingFault\uff0c\u6253\u6ed1\u8865\u507f\u6a21\u578b\u9519\u8bef", "en": "When the overestimation or underesimation state is SKIDDING, or the motion signed changed in BRAKING or SLIDING state, ATP shall consider the overestimation model as fault.", "code": "def SlipSlideModellingFault(k):    if (MotionOverEstimationState(k) is SKIDDING         or MotionUnderEstimationState(k) is SKIDDING         or ((MotionOverEstimationState(k-1) is BRAKING               or MotionOverEstimationState(k-1) is SLIDING)              and MaxMotionOdometerSignChanged(k)))):        return True    elif (MotionOverEstimationState(k-1) is COASTING           and MotionUnderEstimationState(k-1) is COASTING)        return False    else:        return SlipSlideModellingFault(k-1)"}, {"cn": "ValidSlipSlideModelling\uff0c\u6253\u6ed1\u8865\u507f\u6a21\u578b\u6709\u6548", "en": "If overestimation model was fault, then ATP considers the model invalid.", "code": "def ValidSlipSlideModelling(k):    if (ValidSlipSlideModelling(k-1))        return not SlipSlideModellingFault(k)    elif ((MotionOverEstimationState(k) is COASTING)            and MotionUnderEstimationState(k) is COASTING            and WheelFilteredStopped(k))        return True    else:        return ValidSlipSlideModelling(k-1)"}, {"cn": "MaximumSScompensatedMotion\uff0c\u7ecf\u8fc7\u6253\u6ed1\u7a7a\u8f6c\u8865\u507f\u540e\u7684\u6700\u5927\u4f4d\u79fb%def MaximumSScompensatedMotion(k):if ValidSlipSlideModelling(k):return (sign(OverestimatedMotionMax(k))* max(abs(OverestimatedMotionMax(k)), abs(UnderestimatedMotionMax(k)))else:return WheelMaximumMovement(k)#@MinimumSScompensatedMotion\uff0c\u7ecf\u8fc7\u6253\u6ed1\u7a7a\u8f6c\u8865\u507f\u540e\u7684\u6700\u5c0f\u4f4d\u79fb%def MinimumSScompensatedMotion(k):if ValidSlipSlideModelling(k):return (sign(OverestimatedMotionMin(k))* min(abs(OverestimatedMotionMin(k)), abs(UnderestimatedMotionMin(k)))else:return WheelMinimumMovement(k)#@RadarRawSpeed\uff0c\u76f4\u63a5\u83b7\u53d6\u7684\u96f7\u8fbe\u6d4b\u901f\u503c\uff0c\u8be5\u503c\u59cb\u7ec8\u4e3a\u6b63\u3002%def RadarRawSpeed(k):if RadarInfo(k).DrsValid:return RadarInfo(k).DrsSpeedelse:return MAX_RADAR_SPEED#@RadarDirection\uff0c\u96f7\u8fbe\u6d4b\u5f97\u65b9\u5411\uff0c\u5411End1\u65b9\u5411\u4e3a+1\uff0c\u5411End2\u4e3a-1\uff0c\u5176\u4f59\u4e3a0%def RadarDirection(k):if not RadarInfo(k).DrsValid:return 0elif ((CoreId(k) is END_1and RadarInfo(k).DrsDirection > 0)or (CoreId(k) is END_2and RadarInfo(k).DrsDirection <= 0)):return 1else:return -1#@RadarMotionMax\uff0c\u7edd\u5bf9\u503c\u5411\u4e0a\u8fc7\u4f30\u7684\u96f7\u8fbe\u6700\u5927\u4f4d\u79fb\uff0c\u5411END1\u65b9\u5411\u8be5\u503c\u4e3a\u6b63\uff0c\u5411END2\u65b9\u5411\u8be5\u503c\u4e3a\u8d1f\u3002%def RadarMotionMax(k):if not RadarInfo(k).DrsValid:return 0elif RadarRawSpeed(k) >= ATPsetting.RadarSpeedThreshold:return (ATP_CYCLE_TIME * RadarDirection(k) * (RadarRawSpeed(k)+ RadarRawSpeed(k) * ATPsetting.RadarDeviationAboveThreshold / 1000))else:return (ATP_CYCLE_TIME * RadarDirection(k)* (RadarRawSpeed(k) + ATPsetting.RadarDeviationBelowThreshold))#@RadarMotionMin\uff0c\u7edd\u5bf9\u503c\u5411\u4e0b\u8fc7\u4f30\u7684\u96f7\u8fbe\u6700\u5c0f\u4f4d\u79fb\uff0c\u5411END1\u65b9\u5411\u8be5\u503c\u4e3a\u6b63\uff0c\u5411END2\u65b9\u5411\u8be5\u503c\u4e3a\u8d1f\u3002%def RadarMotionMin(k):if not RadarInfo(k).DrsValid:return 0elif RadarRawSpeed(k) >= ATPsetting.RadarSpeedThreshold:return (ATP_CYCLE_TIME * RadarDirection(k) * (RadarRawSpeed(k)- RadarRawSpeed(k) * ATPsetting.RadarDeviationAboveThreshold / 1000))else:return (ATP_CYCLE_TIME * RadarDirection(k)* max(0, RadarRawSpeed(k) - ATPsetting.RadarDeviationBelowThreshold))#@RadarSpeedValid\uff0c\u5224\u65ad\u96f7\u8fbe\u901f\u5ea6\u662f\u5426\u53ef\u7528%def RadarSpeedValid(k):return (ATPsetting.RadarAppliedand  RadarInfo(k).DrsValidand (not ValidSlipSlideModelling(k)or (RadarDirection(k) * MaximumSScompensatedMotion(k) >= 0and abs(RadarMotionMin(k)) <= abs(MaximumSScompensatedMotion(k))and abs(RadarMotionMax(k)) >= abs(MinimumSScompensatedMotion(k)))))#@OdometerSpeedAvailable\uff0c\u5f53\u524d\u91cc\u7a0b\u8ba1\u6d4b\u901f\u662f\u5426\u53ef\u7528\u4e8e\u53c2\u8003\u901f\u5ea6\u5224\u65ad%OdometerSpeedAvailable(k):return (ValidWheelKinematic(k)and OdometerState(k) is INITIALIZED)#@OdometerSpeedUnderThreshold\uff0c\u672c\u7aef\u91cc\u7a0b\u8ba1\u6d4b\u901f\u4f4e\u4e8e\u9608\u503c\u3002", "en": "ATP shall detect whether the measured wheel speed is under threshold.", "code": "def OdometerSpeedUnderThreshold(k):    return (WheelMinSpeed(k) < ATPsetting.OdoLockedAxleThresholdSpeed)"}, {"cn": "ReferenceSpeedUnderThreshold_1\uff0c\u6765\u81eaCCNV\u7684\u53c2\u8003\u901f\u5ea61\u662f\u5426\u5c0f\u4e8e\u6307\u5b9a\u9608\u503c\u3002", "en": "ReferenceSpeedUnderThreshold_1 defines whether the referenced speed 1 from CCNV is lower than a configurable threshold.", "code": "def ReferenceSpeedUnderThreshold_1(k):    if RadarSpeedValid(k):        return (RadarRawSpeed(k) < ATPsetting.OdoLockedAxleThresholdSpeed)    else:        return (ATOcontrolTimeValid(k)                and NonVitalRequest.OdometerRef1SpeedUnderThreshold(k))"}, {"cn": "ReferenceSpeedAvailable_1\uff0c\u6765\u81eaCCNV\u7684\u53c2\u8003\u901f\u5ea61\u662f\u5426\u53ef\u7528", "en": "ReferenceSpeedAvailable_1 defines whether the referenced speed 1 from CCNV is valid or not.", "code": "def ReferenceSpeedAvailable_1(k):    return (RadarSpeedValid(k)            or (ATOcontrolTimeValid(k)                and NonVitalRequest.OdometerRef1Available(k)))"}, {"cn": "ReferenceSpeedUnderThreshold_2\uff0c\u6765\u81eaCCNV\u7684\u53c2\u8003\u901f\u5ea62\u662f\u5426\u5c0f\u4e8e\u6307\u5b9a\u9608\u503c\u3002", "en": "ReferenceSpeedUnderThreshold_2 defines whether the referenced speed 2 from CCNV is lower than a configurable threshold.", "code": "if (ATOcontrolTimeValid(k) == True)    ReferenceSpeedUnderThreshold_2(k) = NonVitalRequest.OdometerRef2SpeedUnderThreshold(k)else:    ReferenceSpeedUnderThreshold_2 = False"}, {"cn": "ReferenceSpeedAvailable_2\uff0c\u6765\u81eaCCNV\u7684\u53c2\u8003\u901f\u5ea62\u662f\u5426\u53ef\u7528", "en": "ReferenceSpeedAvailable_2 shows whether the referenced speed 2 from CCNV is effective or not.", "code": "if (ATOcontrolTimeValid(k) == True)    ReferenceSpeedAvailable_2(k) = NonVitalRequest.OdometerRef2Available(k)else:    ReferenceSpeedAvailable_2 = False"}, {"cn": "OdometerRef_1.PossiblyDisabled\uff0c\u5f53\u672c\u7aef\u91cc\u7a0b\u8ba1\u53ef\u7528\u4e14\u4e0d\u4e3a0\u901f\uff0c\u800c\u53c2\u8003\u901f\u5ea61\u53ef\u7528\u4f46\u4e3a0\u901f\u65f6\uff0c\u5219\u8ba4\u4e3a\u53c2\u8003\u901f\u5ea61\u53ef\u80fd\u9519\u8bef", "en": "The independent source of odometry reference 1 said to disable if following conditions reached: local source of odometry is available (ValidWheelKinematic),and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,and source of odometry reference 1 is available,and odometer reference 1 indicates that train speed is less than reference speed threshold.", "code": "OdometerRef_1. PossiblyDisabled(k)   = (ReferenceSpeedAvailable_1(k)      and ReferenceSpeedUnderThreshold_1(k)      and OdometerSpeedAvailable(k)      and not OdometerSpeedUnderThreshold(k))"}, {"cn": "OdometerRef_2. PossiblyDisabled\uff0c\u5f53\u672c\u7aef\u91cc\u7a0b\u8ba1\u53ef\u7528\u4e14\u4e0d\u4e3a0\u901f\uff0c\u800c\u53c2\u8003\u901f\u5ea62\u53ef\u7528\u4f46\u4e3a0\u901f\u65f6\uff0c\u5219\u8ba4\u4e3a\u53c2\u8003\u901f\u5ea62\u53ef\u80fd\u9519\u8bef", "en": "The independent source of odometry reference 2 said to disable if following conditions reached:local source of odometry is available (ValidWheelKinematic),and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,and source of odometry reference 2 is available,and odometer reference 2 indicates that train speed is less than reference speed threshold.", "code": "OdometerRef_2. PossiblyDisabled(k)   = (ReferenceSpeedAvailable_2(k)      and ReferenceSpeedUnderThreshold_2(k)      and OdometerSpeedAvailable(k)      and not OdometerSpeedUnderThreshold(k))"}, {"cn": "OdometerRef_1.PossiblyEnabled\uff0c\u5f53\u672c\u7aef\u91cc\u7a0b\u8ba1\u548c\u53c2\u8003\u901f\u5ea61\u5747\u53ef\u7528\u4e14\u6d4b\u5f97\u5217\u8f66\u5728\u52a8\u65f6\uff0c\u8ba4\u4e3a\u53c2\u8003\u901f\u5ea61\u53ef\u80fd\u5df2\u6062\u590d\u6709\u6548\u3002", "en": "The independent source of odometry reference 1 said to enable if following conditions reached:local source of odometry is available,and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,and source of odometry reference 1 is available,and odometer reference 1 indicates that train speed is greater than reference speed threshold.", "code": "OdometerRef_1. PossiblyEnabled(k)  = (ReferenceSpeedAvailable_1(k)      and not ReferenceSpeedUnderThreshold_1(k)      and OdometerSpeedAvailable(k)      and not OdometerSpeedUnderThreshold(k))"}, {"cn": "OdometerRef_2.PossiblyEnabled\uff0c\u5f53\u672c\u7aef\u91cc\u7a0b\u8ba1\u548c\u53c2\u8003\u901f\u5ea62\u5747\u53ef\u7528\u4e14\u6d4b\u5f97\u5217\u8f66\u5728\u52a8\u65f6\uff0c\u8ba4\u4e3a\u53c2\u8003\u901f\u5ea62\u53ef\u80fd\u5df2\u6062\u590d\u6709\u6548\u3002", "en": "The independent source of odometry reference 2 said to enable if following conditions reached:local source of odometry is available,and OdometerSpeedUnderThreshold indicates that train speed is greater than reference speed threshold,and source of odometry reference 2 is available,and odometer reference 2 indicates that train speed is greater than reference speed threshold.", "code": "OdometerRef_2. PossiblyEnabled(k)  = (ReferenceSpeedAvailable_2(k)     and not ReferenceSpeedUnderThreshold_2(k)     and OdometerSpeedAvailable(k)     and not OdometerSpeedUnderThreshold(k))"}, {"cn": "OdometerRef_1.OutOfOrder\uff0c\u5f53\u5224\u65ad\u53c2\u8003\u901f\u5ea61\u53ef\u80fd\u4e0d\u53ef\u7528\u65f6\uff0c\u5ef6\u8fdf\u4e00\u6bb5\u65f6\u95f4\uff0c\u82e5\u4ecd\u4e0d\u53ef\u7528\uff0c\u5219\u5224\u65ad\u53c2\u8003\u901f\u5ea61\u5931\u6548\u3002\u5f53\u5224\u65ad\u53c2\u8003\u901f\u5ea61\u53ef\u80fd\u53ef\u7528\u65f6\uff0c\u5ef6\u8fdf\u4e00\u6bb5\u65f6\u95f4\uff0c\u82e5\u4ecd\u53ef\u7528\uff0c\u5219\u5224\u65ad\u53c2\u8003\u901f\u5ea61\u6709\u6548", "en": "The independent source of odometry reference 1 is said to be out of order if it is possibly disabled during more than ATPsetting.OdoLockedAxleDisablingLatency. When the independent source of odometry reference 1 had out of order, it considered not out of order one if the source of odometry reference 1 is possibly enabled during more than ATPsetting.OdoLockedAxleEnablingLatency:", "code": "if (OdometerRef_1.PossiblyDisabled(k) == True    and OdometerRef_1.PossiblyDisabled(k-1) == True    ...    and OdometerRef_1.PossiblyDisabled(k+1-ATPsetting.OdoLockedAxleDisablingLatency) == True)OdometerRef_1.OutOfOrder  = Trueif (OdometerRef_1.PossiblyEnabled(k) == True    and OdometerRef_1.PossiblyEnabled(k-1) == True    ...    and OdometerRef_1.PossiblyEnabled(k+1-ATPsetting.OdoLockedAxleEnablingLatency) == True)    OdometerRef_1.OutOfOrder = False"}, {"cn": "OdometerRef_2.OutOfOrder\uff0c\u5f53\u5224\u65ad\u53c2\u8003\u901f\u5ea62\u53ef\u80fd\u4e0d\u53ef\u7528\u65f6\uff0c\u5ef6\u8fdf\u4e00\u6bb5\u65f6\u95f4\uff0c\u82e5\u4ecd\u4e0d\u53ef\u7528\uff0c\u5219\u5224\u65ad\u53c2\u8003\u901f\u5ea62\u5931\u6548\u3002\u5f53\u5224\u65ad\u53c2\u8003\u901f\u5ea62\u53ef\u80fd\u53ef\u7528\u65f6\uff0c\u5ef6\u8fdf\u4e00\u6bb5\u65f6\u95f4\uff0c\u82e5\u4ecd\u53ef\u7528\uff0c\u5219\u5224\u65ad\u53c2\u8003\u901f\u5ea62\u6709\u6548\u3002", "en": "The independent source of odometry reference 2 is said to be out of order if it is possibly disabled during more than ATPsetting.OdoLockedAxleDisablingLatency. When the independent source of odometry reference 2 had out of order, It considered not out of order one if the source of odometry reference 2 is possibly enabled during more than ATPsetting.OdoLockedAxleEnablingLatency:", "code": "if (OdometerRef_2.PossiblyDisabled(k) == True     and OdometerRef_2.PossiblyDisabled(k-1) == True     ...     and OdometerRef_2.PossiblyDisabled(k+1-ATPsetting.OdoLockedAxleDisablingLatency) == True)OdometerRef_2.OutOfOrder = Trueif (OdometerRef_2.PossiblyEnabled(k) == True    and OdometerRef_2.PossiblyEnabled(k-1) == True    ...    and OdometerRef_2.PossiblyEnabled(k+1-ATPsetting.OdoLockedAxleEnablingLatency) == True)   OdometerRef_2.OutOfOrder = False"}, {"cn": "OdometerRef_1.Contradictory\uff0c\u82e5\u53c2\u8003\u901f\u5ea61\u6709\u6548\u4e14\u5224\u65ad\u8f66\u52a8\uff0c\u800c\u672c\u7aef\u91cc\u7a0b\u8ba1\u5224\u65ad\u8f66\u9759\u6b62\uff0c\u5219\u8ba4\u4e3a\u53c2\u8003\u901f\u5ea61\u5224\u65ad\u51fa\u91cc\u7a0b\u8ba1\u53ef\u80fd\u6545\u969c\u3002", "en": "The source of odometry reference 1 said to be contradictory with local source of odometry if:local source of odometry is available (ValidWheelKinematic)and OdometerSpeedUnderThreshold indicates that wheel speed is less than reference speed threshold,and source of odometry reference 1 is available and not out of order,and odometer reference 1 indicates that train speed is greater than reference speed threshold.", "code": "OdometerRef_1. Contradictory(k) = (not OdometerRef_1.OutOfOrder(k)     and ReferenceSpeedAvailable_1(k)     and not ReferenceSpeedUnderThreshold_1(k)     and ValidWheelKinematic(k)     and OdometerSpeedUnderThreshold(k))"}, {"cn": "OdometerRef_2. Contradictory\uff0c\u82e5\u53c2\u8003\u901f\u5ea62\u6709\u6548\u4e14\u5224\u65ad\u8f66\u52a8\uff0c\u800c\u672c\u7aef\u91cc\u7a0b\u8ba1\u5224\u65ad\u8f66\u9759\u6b62\uff0c\u5219\u8ba4\u4e3a\u53c2\u8003\u901f\u5ea62\u5224\u65ad\u51fa\u91cc\u7a0b\u8ba1\u53ef\u80fd\u6545\u969c\u3002", "en": "The source of odometry reference 2 said to be contradictory with local source of odometry if:local source of odometry is available (ValidWheelKinematic)and OdometerSpeedUnderThreshold indicates that wheel speed is less than reference speed threshold,and source of odometry reference 2 is available and not out of order,and odometer reference 2 indicates that train speed is greater than reference speed threshold.", "code": "OdometerRef_2.Contradictory (k) = (not OdometerRef_2.OutOfOrder(k)     and ReferenceSpeedAvailable_2(k)     and not ReferenceSpeedUnderThreshold_2(k)     and ValidWheelKinematic(k)     and OdometerSpeedUnderThreshold(k))"}, {"cn": "AxlePossiblyLocked\uff0c\u5728\u4e24\u8def\u53c2\u8003\u901f\u5ea6\u90fd\u6b63\u5e38\uff08\u6ca1\u6709\u5931\u6548out of order\uff09\u7684\u60c5\u51b5\u4e0b\uff0c\u5f53\u4e24\u8def\u53c2\u8003\u901f\u5ea6\u5747\u5224\u65ad\u672c\u7aef\u91cc\u7a0b\u8ba1\u53ef\u80fd\u6545\u969c\u7684\u60c5\u51b5\u4e0b\uff0c\u8ba4\u4e3a\u5f53\u524d\u53ef\u80fd\u8f74\u9501\u3002\u6216\u8005\uff0c\u5f53\u6709\u4e00\u8def\u53c2\u8003\u901f\u5ea6\u8ba4\u4e3a\u8f74\u9501\uff0c\u800c\u53e6\u4e00\u8def\u53c2\u8003\u901f\u5ea6\u5931\u6548\u6216\u4e0d\u53ef\u7528\uff0c\u4e5f\u8ba4\u4e3a\u5f53\u524d\u53ef\u80fd\u8f74\u9501\u3002", "en": "Odometer axle shall consider possibly locked if:Both independent sources of odometry indicates a contradiction with local odometer,Or one source of odometry is contradictory and the other one is out of order (or not available).", "code": "AxlePossiblyLocked(k) = ((OdometerRef_1.Contradictory(k) and OdometerRef_2.Contradictory(k))    or (OdometerRef_1.Contradictory(k)         and (OdometerRef_2.OutOfOrder(k) or  not ReferenceSpeedAvailable_2(k)))    or (OdometerRef_2.Contradictory(k)         and (OdometerRef_1.OutOfOrder(k) or not ReferenceSpeedAvailable_1(k))))"}, {"cn": "UnrecoverableAxleLocked\uff0c\u5f53\u8fde\u7eed\u82e5\u5e72\u4e2a\u5468\u671f\u5224\u65ad\u53ef\u80fd\u8f74\u9501\uff0c\u6216\u8005\u5df2\u7ecf\u5224\u65ad\u4e3a\u8f74\u9501\uff0c\u5219\u6c38\u4e45\u8f74\u9501.", "en": "If AxlePossiblyLocked situation lasts more than ATPsetting.OdoLockedAxleTimeout, the odometer axle shall be considered locked. Once UnrecoverableAxleLocked set to True, it will stay at state True unless ATP re-initialized.", "code": "UnrecoverableAxleLocked(k) = UnrecoverableAxleLocked(k-1)   or (AxlePossiblyLocked(k)        and AxlePossiblyLocked(k-1)        and ...        and AxlePossiblyLocked(k+1-ATPsetting.OdoLockedAxleTimeout)"}, {"cn": "AxleLockedDetectionAvailable\uff0c\u53ea\u8981\u6709\u4e00\u8def\u53c2\u8003\u901f\u5ea6\u53ef\u4ee5\u5de5\u4f5c\uff0c\u5c31\u8ba4\u4e3a\u8f74\u9501\u4fa6\u6d4b\u53ef\u7528\u3002", "en": "If only one or no source of odometry is available, then ATP shall invalidate kinematic while this situation lasting.", "code": "AxleLockedDetectionAvailable  = ((not OdometerRef_1.OutOfOrder and ReferenceSpeedAvailable_1(k))    or (not OdometerRef_2.OutOfOrder and ReferenceSpeedAvailable_2(k)))"}, {"cn": "WheelTrainKinematicCorrelation\uff0c\u8f66\u8f6e\u548c\u5217\u8f66\u7684\u901f\u5ea6\u4e00\u81f4\u6027", "en": "Wheel and train kinematic shall consider correctly correlated if and only if:odometer axle is not detected locked,and odometer axle detection is available", "code": "WheelTrainKinematicCorrelation(k) = AxleLockedDetectionAvailable(k) and not UnrecoverableAxleLocked(k)"}, {"cn": "ValidTrainKinematic\uff0c\u5217\u8f66\u4f4d\u79fb\u901f\u5ea6\u8ba1\u7b97\u6709\u6548\u7684\u6761\u4ef6", "en": "Train kinematic information shall declare invalid if at least one of following condition is True:odometer kinematic is not valid,or neither radar speed nor over-estimation modeling of train movement is valid,or train movement and wheel movement has been detected de-correlated.", "code": "def ValidTrainKinematic(k):    return ((ValidSlipSlideModelling(k)              or RadarSpeedValid(k))            and WheelTrainKinematicCorrelation(k)            and ValidWheelKinematic(k))"}, {"cn": "MaximumTrainMotion\uff0c\u6839\u636e\u6765\u81ea\u91cc\u7a0b\u8ba1\u6216\u96f7\u8fbe\u7684\u4fe1\u606f\uff0c\u8ba1\u7b97\u5217\u8f66\u7684\u5468\u671f\u6700\u5927\u4f4d\u79fb\u3002\u8be5\u503c\u4e3a\u77e2\u91cf\uff0c\u5411END_1\u65b9\u5411\u4e3a\u6b63\uff0cEND_2\u65b9\u5411\u4e3a\u8d1f\u3002%def MaximumTrainMotion(k):if (not RadarSpeedValid(k)):return MaximumSScompensatedMotion(k)elif (not ValidSlipSlideModelling(k)):return RadarMotionMax(k)else:return (min(abs(MaximumSScompensatedMotion(k)), abs(RadarSpeedMax(k)))* sign(MaximumSScompensatedMotion(k)))#@MinimumTrainMotion\uff0c\u6839\u636e\u6765\u81ea\u91cc\u7a0b\u8ba1\u6216\u96f7\u8fbe\u7684\u4fe1\u606f\uff0c\u8ba1\u7b97\u5217\u8f66\u7684\u5468\u671f\u6700\u5c0f\u4f4d\u79fb\u3002\u8be5\u503c\u4e3a\u77e2\u91cf\uff0c\u5411END_1\u65b9\u5411\u4e3a\u6b63\uff0cEND_2\u65b9\u5411\u4e3a\u8d1f\u3002%def MinimumTrainMotion(k):if (not RadarSpeedValid(k)):return MinimumSScompensatedMotion(k)elif (not ValidSlipSlideModelling(k)):return RadarMotionMin(k)else:return (max(abs(MinimumSScompensatedMotion(k)), abs(RadarSpeedMin(k)))* sign(MinimumSScompensatedMotion(k)))#", "en": "TrainStopped, train shall consider strictly stopped if and only if:wheel is detected strictly stopped,and train kinematic elaboration is valid,and wheel is not detected sliding.", "code": "TrainStopped(k) = ((WheelStopped(k) == True)    and ((MotionOverEstimationState == COASTING)           or (MotionOverEstimationState == BRAKING))    and (ValidTrainKinematic(k) == True))"}, {"cn": "TrainFilteredStopped\uff0c\u5217\u8f66\u51c6\u9759\u6b62\u5224\u65ad\u3002", "en": "Train shall consider stopped with the tolerance of one cog detection if:wheel is detected at filtered stop,and train kinematic elaboration is valid,and wheel is not detected sliding.", "code": "TrainFilteredStopped(k) = ((WheelFilteredStopped(k) == True)    and ((MotionOverEstimationState == COASTING)          or (MotionOverEstimationState == BRAKING))    and (ValidTrainKinematic(k) == True))"}, {"cn": "TrainHasMoved\uff0c\u8868\u660e\u81ea\u4e0a\u7535\u4ee5\u540e\uff0c\u5217\u8f66\u662f\u5426\u79fb\u52a8\u8fc7\u3002%def TrainHasMoved(k):if (Initialization):return Falseelif (not TrainHasMoved(k-1)and not TrainFilteredStopped(k)and (TeethCounter(k) != TeethCounter(k-1))):return Trueelse:return TrainHasMoved(k-1)#@TrainMinSpeed\uff0c\u8ba1\u7b97\u5217\u8f66\u6700\u5c0f\u901f\u5ea6\u3002%def TrainMinSpeed(k):if (OdometerSpeedAvailable(k)):return max(0, (round.floor(abs(MinimumTrainMotion(k) / ATP_CYCLE_TIME))+ ((ATPsetting.BrakingMinAcc - ATPsetting.MaxGradientAcc)* ATP_CYCLE_TIME / 2)))else:return 0#@TrainMaxSpeed\uff0c\u8003\u8651\u6253\u6ed1\u8fc7\u4f30\u8865\u507f\u7684\u5217\u8f66\u6700\u5927\u901f\u5ea6\uff0c\u8be5\u901f\u5ea6\u4e3a\u975e\u8d1f\u503c\u3002", "en": "According to the matching of odometer cog counter and code, maximum train speed shall computed using the followings expressions:", "code": "def TrainMaxSpeed(k):    if (OdometerSpeedAvailable(k)):        return (round.ceil(abs(MaximumTrainMotion(k) / ATP_CYCLE_TIME))                + ((ATPsetting.TractionMaxAcc[TrainMinSpeed(k)] + ATPsetting.MaxGradientAcc)                   * ATP_CYCLE_TIME / 2))    else:        return round.ceil(abs(MaximumTrainMotion(k)) / ATP_CYCLE_TIME)"}, {"cn": "NewBeaconObtained\uff0c\u8868\u660e\u6536\u5230\u4e86\u53ef\u7528\u7684RB%def NewBeaconObtained(k):if (BeaconMessageReceive(k)and ValidTrainKinematic(k)and not TrainFilteredStopped(k)and OdometerState(k) is INITIALIZED):NewBeaconObtained = Trueelse:NewBeaconObtained = False#@BeaconBeforeLastObtained\uff0c\u8bb0\u5f55\u8bfb\u5230\u7684\u6b21\u65b0\u7684\u4fe1\u6807%def BeaconBeforeLastObtained(k):if (Initialization):BeaconBeforeLastObtained = Noneelif (NewBeaconObtained(k)):BeaconBeforeLastObtained = BeaconLastObtained(k-1)else:BeaconBeforeLastObtained = BeaconBeforeLastObtained(k-1)return BeaconBeforeLastObtained#@BeaconLastObtained\uff0c\u8bb0\u5f55\u8bfb\u5230\u7684\u6700\u65b0\u7684\u4fe1\u6807%def BeaconLastObtained(k):if (Initialization):BeaconLastObtained = Noneelif (NewBeaconObtained(k)):BeaconLastObtained = TrackMap.Beacons[LockedBeaconMsgByte.Id]else:BeaconLastObtained = BeaconLastObtained(k-1)return BeaconLastObtained#@\u5728\u672c\u5468\u671f\u7684\u91cc\u7a0b\u8ba1\u548c\u6d4b\u901f\u4fe1\u606f\u6709\u6548\u7684\u60c5\u51b5\u4e0b\uff0c\u9700\u8981\u6839\u636e\u5f53\u524d\u9f7f\u6570\u548c\u9501\u5b58\u7684\u8bfb\u5230\u4fe1\u6807\u65f6\u7684Top-loc\u4fe1\u606f\uff0c\u8ba1\u7b97DistLastBeaconMax\u548cDistLastBeaconMin\uff0c\u8868\u793a\u5f53\u524d\u7ecf\u8fc7\u4fe1\u6807\u540e\u5df2\u8fd0\u884c\u7684\u6700\u5927\u6700\u5c0f\u8ddd\u79bb\u3002", "en": "If a valid beacon with top-loc received between cycle k-1 and k, then minimum and maximum distance ran since top-loc shall evaluate as the difference between current teeth counter and recorded cog position just before or after top-loc. If there is no beacon received, ATP updates distances from last beacon using the train movements.", "code": "if (NewBeaconObtained(k)):    DistLastBeaconMin(k)= MinCogCalibration(k) * (TeethCounter(k)- CogPositionAfterTopLoc(k))    DistLastBeaconMax(k)= MaxCogCalibration(k) * (TeethCounter(k)- CogPositionBeforeTopLoc(k))else:    DistLastBeaconMin = DistLastBeaconMin(k-1) + MinimumTrainMotion(k)    DistLastBeaconMax = DistLastBeaconMax(k-1) + MaximumTrainMotion(k)"}, {"cn": "End2RunningForward\uff0c\u6839\u636e\u8f66\u8f6e\u65cb\u8f6c\u65b9\u5411\uff0c\u5224\u65ad\u5217\u8f66\u662f\u5426\u5411END_2\u65b9\u5411\u8fd0\u884c%def End2RunningForward(k):if (OdometerState(k) is INITIALIZED):return (MaximumTrainMotion(k) < 0)else:return True#@End1RunningForward\uff0c\u6839\u636e\u8f66\u8f6e\u65cb\u8f6c\u65b9\u5411\uff0c\u5224\u65ad\u5217\u8f66\u662f\u5426\u5411END_1\u65b9\u5411\u8fd0\u884c%def End1RunningForward(k):if (OdometerState(k) is INITIALIZED):return (MaximumTrainMotion(k) > 0)else:return True#@\u5728CALI_WATING\u72b6\u6001\u4e0b\u4f7f\u7528\u9ed8\u8ba4\u9f7f\u8ddd\u503c", "en": "From power-up and while calibration process is not successfully performed, ATP shall use default calibration to compute train motion and shall consider itself in the state of waiting for the first beacon belonging to a couple of calibration.", "code": "if (Initialization)    CalibrationState =  CALI_WAITING    MinCogCalibration = ATPsetting.OdoCaliDefaultCogLengthMin    MaxCogCalibration = ATPsetting.OdoCaliDefaultCogLengthMax"}, {"cn": "\u5f53\u8bfb\u5230\u7ebf\u8def\u5730\u56fe\u4e2d\u7684MTIB1\u65f6\uff0c\u9f7f\u8ddd\u6821\u51c6\u72b6\u6001\u4eceCALI_WAITING\u8f6c\u5165CALI_MEASURING\u3002", "en": "If ATP is in the state of CALI_WAITING, can transform to the measuring state if following conditions fulfilled:a valid beacon has been received and this beacon belongs to a couple of calibration,and train kinematic was valid,and no excessive slip/slide effect was detected,and WheelMinimumMovement is not null,Then, ATP shall memorize:position of the wheel before and after top location signal of received beacon,the ID of received beacon,the sign of the movement when crossing beacon,and shall consider itself as CALI_MEASURING.", "code": "if ((CalibrationState(k-1) =  CALI_WAITING)    and (NewBeaconObtained(k) == True)    and (TrackMap.BeaconBelongsToCalibrationCouple(BeaconMessage.Id(k)) == True)    and (SlipSlideDetected(k) == False))    CalibrationMeasurementStartPositionMin = CogPositionBeforeTopLoc(k)    CalibrationMeasurementStartPositionMax = CogPositionAfterTopLoc(k)    CalibrationMeasurementStartBeacon = BeaconMessage.Id(k)    CalibrationEnd1RunningForward = End1RunningForward(k)    CalibrationState = CALI_MEASURING"}, {"cn": "\u5f53\u8bfb\u5230\u7ebf\u8def\u5730\u56fe\u4e2d\u4e0e\u4e4b\u524dMTIB1\u5339\u914d\u7684MTIB2\u65f6\uff0c\u6839\u636e\u7ecf\u8fc7\u7684\u9f7f\u6570\u503c\uff0c\u5728ATPsetting\u4e2d\u67e5\u8868\u5f97\u5230\u6700\u5927\u6700\u5c0f\u9f7f\u8ddd\uff0c\u5e76\u6bd4\u8f83\u6d4b\u5f97\u7684\u9f7f\u8ddd\u7ed3\u679c\uff1a\u5982\u679c\u6d4b\u5f97\u7684\u6700\u5927\u6700\u5c0f\u9f7f\u8ddd\u5728\u7406\u8bba\u503c\u8303\u56f4\u5185\uff0c\u5219\u9f7f\u8ddd\u6821\u51c6\u72b6\u6001\u4eceCALI_MEASURING\u5230CALI_VALIDATING\uff1b\u5982\u679c\u5728\u7406\u8bba\u8303\u56f4\u5916\uff0c\u5219\u72b6\u6001\u4eceCALI_MEASURING\u8f6c\u5165CALI_WAITING\u3002\u5176\u4e2d\u6700\u5927\u6700\u5c0f\u6d4b\u5f97\u9f7f\u8ddd\u662f\u6839\u636e\u6821\u51c6\u8fc7\u7a0b\u4e2d\u6d4b\u5f97\u9f7f\u6570\uff0c\u5728\u79bb\u7ebf\u5de5\u5177\u8ba1\u7b97\u7684\u9f7f\u6570-\u9f7f\u8ddd\u5bf9\u7167\u8868\u4e2d\u67e5\u5230\u7684\u3002\u5176\u4e2dCaliMinRatio\u548cCaliMaxRatio\u662f\u79bb\u7ebf\u5de5\u5177\u8ba1\u7b97\u7684\u8be5\u6821\u51c6\u4fe1\u6807\u6240\u5bf9\u5e94\u7684MTIB\u7ed3\u6784\u7684\u76f8\u5173\u5c5e\u6027\uff0c\u8868\u793a\u8be5\u5bf9MTIB\u7684\u95f4\u8ddd\u4e0e\u6807\u51c6\u95f4\u8ddd\uff0821\u7c73\uff09\u7684\u6bd4\u7387\uff0c\u8be5\u7ed3\u6784\u5b9a\u4e49\u89c1[REF11]\u3002", "en": "If ATP is in the state of CALI_MEASURING and following conditions fulfilled: a valid beacon has been received and the beacon and first memorized calibration beacon is one of possible dedicated couple of calibration,and train kinematic was valid,and no excessive slip/slide effect was detected,and sign of train motion is still identical to thus detected on first beacon signaling,Then,if resulting calibration range is included in default calibration range, then ATP shall: memorize: position of the wheel before and after top location signal of received beacon, the id of received beacon,and shall consider itself as CALI_VALIDATING. else: ATP shall consider that calibration process has failed and back to CALI_WAITING. Among them, the measured maximum and minimum calibration fetches from the offline-generated counter-calibration table, based on the calculated cog counter. The CaliMinRation and CaliMaxRation are elements of structure MTIB generated by offline tool for each couple of calibration beacons. Refer to [REF11] for the definition of MTIB.", "code": "if ((CalibrationState(k-1) == CALI_MEASURING)     and (NewBeaconObtained(k) == True)     and (TrackMap.AreNeighbouredBeacons(BeaconMessage.Id(k),                                                CalibrationMeasurementStartBeacon(k)) == True)     and (SlipSlideDetected(k) == False)     and (CalibrationEnd1RunningForward(k-1) == End1RunningForward(k)))    if ((ATPsetting.OdoCaliDefaultCogLengthMax >= MaxCogCalibrationMeasured)        and (ATPsetting.OdoCaliDefaultCogLengthMin <= MinCogCalibrationMeasured))         CalibrationValidationStartPositionMin = CogPositionBeforeTopLoc(k)         CalibrationValidationStartPositionMax = CogPositionAfterTopLoc(k)         CalibrationValidationStartBeacon = BeaconMessage.Id(k))         CalibrationResultMin = MinCogCalibrationMeasured         CalibrationResultMax = MaxCogCalibrationMeasured         CalibrationState =  CALI_VALIDATING    else:         CalibrationState = CALI_WAITINGMinCogCalibrationMeasured = CaliMinRatio * ATPsetting.MeterCaliMaxMinCalibration[1][|CalibrationMeasurementStartPositionMin(k)-CogPositionAfterTopLoc(k)| - ATPsetting.OdoCaliCogCounterMin]MaxCogCalibrationMeasured = CaliMaxRatio * ATPsetting.MeterCaliMaxMinCalibration[0][|CalibrationMeasurementStartPositionMax(k)-CogPositionBeforeTopLoc(k)| - ATPsetting.OdoCaliCogCounterMin]"}, {"cn": "\u5982\u679c\u6821\u51c6\u8fc7\u7a0b\u4e2d\u53d1\u751f\u4e0b\u5217\u60c5\u51b5\uff0c\u5219\u4eceCALI_MEASURING\u56de\u5230CALI_WAITING", "en": "If ATP is in the state of CALI_MEASURING and following conditions fulfilled:train kinematic has been detected not valid,or excessive slip/slide effect has been detected,or WheelMinimumMovement sign is in the opposite direction of thus observed on first beacon or becomes null,or an unexpected beacon has been received. That is, a beacon not belonging calibration measurement couple.Then, ATP shall abort calibration process and back to CALI_WAITING.", "code": "if ((CalibrationState(k-1) =  CALI_MEASURING)     and ((ValidTrainKinematic(k) == False)          or (OdometerState(k) is INVALID)          or (SlipSlideDetected(k) == True)          or (CalibrationEnd1RunningForward(k-1) != End1RunningForward(k))          or (TrainFilteredStopped(k) == True)          or ((NewBeaconObtained(k) == True)              and TrackMap.BeaconBelongsToCalibrationCouple(BeaconMessage.Id(k)) == False)))    CalibrationState = CALI_WAITING"}, {"cn": "\u5f53\u53d1\u751f\u4ee5\u4e0b\u60c5\u51b5\u65f6\uff0c\u8ba4\u4e3a\u6821\u51c6\u5931\u8d25\uff0c\u4eceCALI_VALIDATING\u56de\u5230CALI_WAITING", "en": "If ATP is in the state of calibration validation in progress and following conditions fulfilled:train kinematic has been detected not valid,or excessive slip/slide effect has been detected,or WheelMinimumMovement sign is in the opposite direction of thus observed on first beacon or becomes null,or an unexpected beacon has been received. That is, a beacon not belonging calibration validation couple.In such case, then ATP shall consider that calibration process as not sable and so back to CALI_WAITING.", "code": "if ((CalibrationState(k-1) =  CALI_VALIDATING)     and ((ValidTrainKinematic(k) == False)           or (OdometerState(k) is INVALID)           or (SlipSlideDetected(k) == True)           or ((CalibrationEnd1RunningForward(k-1) != End1RunningForward(k))           or (TrainFilteredStopped(k) == True)           or ((NewBeaconObtained(k) == True)               and (TrackMap.IsCalibrationValidationBeacon(BeaconMessage.Id(k),                                                      CalibrationValidationStartBeacon(k)) == False))))    CalibrationState = CALI_WAITING"}, {"cn": "\u5f53\u8bfb\u5230\u6709\u6548\u7684\u9a8c\u8bc1\u4fe1\u6807\uff0c\u5e76\u5224\u65ad\u4e4b\u524d\u6d4b\u5f97\u9f7f\u8ddd\u5728\u6709\u6548\u8303\u56f4\u5185\u65f6\uff0c\u8ba4\u4e3a\u6821\u51c6\u6210\u529f\uff0c\u8f6c\u5165CALI_COMPLETED\u72b6\u6001\uff1b\u5426\u5219\uff0c\u6821\u51c6\u5931\u8d25\uff0c\u8fd4\u56deCALI_WATING\u72b6\u6001\u3002", "en": "If ATP is in the state of calibration validation in progress and following conditions fulfilled: a valid beacon has been received and this beacon is one of possible confirmation beacons related to second beacon signaled of possible confirmation beacons related to second beacon signaled of calibration measurement,and train kinematic was valid,and no excessive slip/slide effect was detected,and sign of train motion is still identical to thus detected on first beacon signaling,and WheelMinimumMovement is not null. Then,if resulting calibration range fully includes the calibration range in track map, then ATP shall: update ATP minimum and maximum calibration with last calibration computed on beacons,and shall consider that calibration process is CALI_COMPLETED.else: ATP shall consider that calibration process is not usable and so back to CALI_WATING waiting for new measurement calibration beacons.", "code": "if (CalibrationState(k-1) =  CALI_VALIDATING)    and (NewBeaconObtained(k) == True)    and (TrackMap.IsCalibrationValidationBeacon(BeaconMessage.Id(k),                                                        CalibrationValidationStartBeacon(k)))    and (SlipSlideDetected(k) == False)    and (CalibrationEnd1RunningForward(k-1) == End1RunningForward(k)))    if ((TrackMap.CalibrationCoupleMaxDistance(BeaconMessage.Id(k),                              CalibrationValidationStartBeacon(k)) <= MaxDistanceRanForValidation)        and TrackMap.CalibrationCoupleMinDistance(BeaconMessage.Id(k),                             CalibrationValidationStartBeacon(k)) >= MinDistanceRanForValidation)         MinCogCalibration = CalibrationResultMin(k)         MaxCogCalibration = CalibrationResultMax(k)         CalibrationState = CALI_COMPLETED    else:         CalibrationState = CALI_WAITINGMaxDistanceRanForValidation =(abs(CalibrationValidationStartPositionMin(k)\u2014 CogPositionAfterTopLoc(k)) + 1)   * CalibrationResultMax(k)MinDistanceRanForValidation =(abs(CalibrationValidationStartPositionMax(k)\u2014 CogPositionBeforeTopLoc(k)) - 1)   * CalibrationResultMin(k)"}, {"cn": "End2OrientationByBeacon\uff0c\u5f53\u5b9a\u4f4d\u521d\u59cb\u5316\u65f6\uff0c\u901a\u8fc7\u7ecf\u8fc7\u7684\u4fe1\u6807\uff0c\u5224\u65adEND_2\u9a7e\u9a76\u5ba4\u6240\u9762\u5bf9\u7684\u8fd0\u8425\u65b9\u5411\u3002", "en": "The orientation of the train END means the UP or DOWN orientation which this END toward to. When a pair of consecutive beacon read, ATP can determine the orientation for each train END according to the direction of these beacons in track map and the direction of train movement.", "code": "def End2OrientationByBeacon(k):    if (Initialization        or not MovingInitialByBeacon(k)):        return DOT_UNKNOWN    elif (ATPsetting.PolarizedTrain):        return ATPsetting.End2Orientation    elif (NewBeaconObtained(k)          and TrackMap.AreNeighbouredBeacons(BeaconBeforeLastObtained(k),                                                    BeaconLastObtained(k))):        if (End2RunningForward(k)):            return (TrackMap.OrientationOfNeighbouredBeacons(BeaconBeforeLastObtained(k),                                                                       BeaconLastObtained(k)))        else:            return (TrackMap.OrientationOfNeighbouredBeacons(BeaconLastObtained(k),                                                                       BeaconBeforeLastObtained(k)))    else:        return End2OrientationByBeacon(k-1)"}, {"cn": "BeaconLocation\uff0c\u5982\u679c\u672c\u5468\u671f\u8bfb\u5230\u4e86\u91cd\u5b9a\u4f4d\u4fe1\u6807\uff08\u65e0\u8bba\u662f\u5426\u5df2\u7ecf\u5728\u5b9a\u4f4d\u72b6\u6001\uff09\uff0c\u5219ATP\u9700\u6839\u636e\u8be5\u4fe1\u6807\u5728\u7ebf\u8def\u5730\u56fe\u4e2d\u7684\u5750\u6807\u8ba1\u7b97\u8bfb\u5230\u4fe1\u6807\u65f6\u523bEND_2\u8f66\u5934\u7684\u4f4d\u7f6e\uff1a", "en": "If a valid beacon read, ATP shall calculate actual maximum and minimum location of the END_2 according to the beacon location in track map, the distance from beacon antenna to the END_2, the distance after top-loc, the orientation of END_2 and the direction of train movement. The beacon location indicate the actual external location of the END_2.", "code": "def BeaconLocation(k):    if (NewBeaconObtained(k)):        if (End2OrientationByBeacon(k) is not None):            BeaconLocation.Ext2 = (TrackMap.LocationUpdateExt2                                       (End2RunningForward(k),                                        End2OrientationByBeacon(k),                                        BeaconLastObtained.Location(k),                                        MaxMotionOfEnd2(k),                                        MinMotionOfEnd2(k)))        elif (TrainLocalized(k-1)):            BeaconLocation.Ext2 = (TrackMap.LocationUpdateExt2                                       (End2RunningForward(k),                                        TrainLocation(k-1).Ext2.Ort,                                        BeaconLastObtained.Location(k),                                        MaxMotionOfEnd2(k),                                        MinMotionOfEnd2(k)))        else:            BeaconLocation.Ext2 = None                    BeaconLocation.Uncertainty = (2 * BeaconLastObtained(k).PositionTolerance                                            + abs(DistLastBeaconMax(k) - DistLastBeaconMin(k)))         BeaconLocation.Int2 = UpdateInt2FromExt2        BeaconLocation.Ext1 = UpdateExt1FromExt2        BeaconLocation.Int1 = UpdateInt1FromExt2    else:        BeaconLocation = None    return BeaconLocationdef MaxMotionOfEnd2(k)    return (DistLastBeaconMax(k)            - ATPsetting.CCcoreEnd2BeaconAntennaDistance[CoreId(k)]            - BeaconLastObtained(k).PositionTolerance)def MinMotionOfEnd2(k)    return (DistLastBeaconMin(k)            - ATPsetting.CCcoreEnd2BeaconAntennaDistance[CoreId(k)]            - BeaconLastObtained(k).PositionTolerance)"}, {"cn": "MovingInitialByBeacon\uff0c\u662f\u5426\u5728\u4fe1\u6807\u521d\u59cb\u5316\u5b9a\u4f4d\u8fc7\u7a0b\u4e2d\u3002%def MovingInitialByBeacon(k):if (Initializationor TrainLocalized(k-1)or TrainFilteredStopped(k)or (End1RunningForward(k) and not End1RunningForward(k-1))or (End2RunningForward(k) and not End2RunningForward(k-1))or abs(DistLastBeaconMax(k)) >= ATPsetting.BeaconPairMaxDistance):return Falseelif (NewBeaconObtained(k)):return Trueelse:return MovingInitialByBeacon(k-1)#@TrainLocatedOnBeacon\uff0c\u5217\u8f66\u901a\u8fc7\u4fe1\u6807\u8fdb\u884c\u521d\u59cb\u5316\u5b9a\u4f4d\uff08\u8be5\u503c\u4ec5\u5728\u5904\u7406\u4fe1\u6807\u7684\u5468\u671f\u4e3aTrue\uff09\u3002\u5982\u679c\u5728\u5b9a\u4f4d\u521d\u59cb\u5316\u9636\u6bb5\u8bfb\u5230\u4fe1\u6807\uff0c\u4e14\u80fd\u591f\u6839\u636e\u8be5\u4fe1\u6807\u7684\u4f4d\u7f6e\u8ba1\u7b97\u51fa\u5217\u8f66\u7684\u5b9a\u4f4d\uff0c\uff08\u5373\u8f66\u8eab\u8303\u56f4\u5185\u6ca1\u6709\u8f68\u9053\u8fb9\u754c\u6216\u672a\u77e5\u72b6\u6001\u7684\u9053\u5c94\uff09\uff0c\u5373\u8ba4\u4e3a\u521d\u59cb\u5316\u5b9a\u4f4d\u6210\u529f\u3002%def TrainLocatedOnBeacon(k):return (MovingInitialByBeacon(k)and NewBeaconObtained(k)and (ATPsetting.PolarizedTrainor (MovingInitialByBeacon(k-1)and TrackMap.AreNeighbouredBeacons(BeaconBeforeLastObtained(k),BeaconLastObtained(k))))and BeaconLocation(k) is not None)#@MemorizedLocationAuthorized\uff0c\u9879\u76ee\u914d\u7f6e\u662f\u5426\u6388\u6743\u4f7f\u7528\u8bb0\u5fc6\u5b9a\u4f4d%def MemorizedLocationAuthorized(k):return Offline.GetMemorizedLocationAuthorized(k)#@MemorizedLocationEnable\uff0c\u4ec5\u5728\u521a\u4e0a\u7535\u8f66\u8fd8\u672a\u52a8\u65f6\u5141\u8bb8\u4f7f\u7528\u8bb0\u5fc6\u5b9a\u4f4d%def MemorizedLocationEnable(k):return (not TrainHasMoved(k))#@MemorizedLocationAvailable\uff0c\u8bb0\u5fc6\u5b9a\u4f4d\u662f\u5426\u53ef\u7528%def MemorizedLocationAvailable(k):return (TrainFilteredStopped(k)and ValidTrainKinematic(k)and MemorizedLocationAuthorized(k)and MemorizedLocationEnable(k)and Message.VitalChecksumValid(MemLocation)and MemLocation.MemLocVersion == MEM_LOCATION_VERSIONand MemLocation.TrainType == TrainType(k)and MemLocation.TrainId == SubSystemId(k)and MemLocation.SleepAreaId == (TrackMap.ExistZoneLocationIncluded(SGL_SLEEPING_ZONE, MemLocation(k).Ext2).Id)and MemLocation.SleepAreaVersion == (TrackMap.ExistZoneLocationIncluded(SGL_SLEEPING_ZONE, MemLocation(k).Ext2).Version)and MemLocation.TrainLength == ATPsetting.LocationTrainLength)#@MotionSinceMemorizedLocation\uff0c\u8bb0\u5f55\u81ea\u5524\u9192\u540e\u8fd0\u884c\u4e86\u591a\u5c11\u8ddd\u79bb%def MotionSinceMemorizedLocation(k):if (TrainLocatedOnOtherATP(k-1)):return OtherATP(k).MotionSinceMemLocelif (MemorizedLocationAvailable(k)or not MemLocationNotConfirmed(k-1)):return 0else:return (MotionSinceMemorizedLocation(k-1) + MaximumTrainMotion(k))#@TrainPresumablyLocalized\uff0c\u5217\u8f66\u4f7f\u7528\u8bb0\u5fc6\u5b9a\u4f4d\uff0c\u4f46\u8fd8\u672a\u8bfb\u5230\u786e\u8ba4\u4fe1\u6807\u7684\u72b6\u6001\u3002\u5f85\u5df2\u7ecf\u901a\u8fc7\u4fe1\u6807\u91cd\u5b9a\u4f4d\uff0c\u6216\u8005\u5931\u4f4d\u540e\uff0c\u6e05\u9664\u8be5\u503c\u3002%def TrainPresumablyLocalized(k):if (MemorizedLocationAvailable(k)and not TrainPresumablyLocalized(k-1)):return Trueelif (TrainPresumablyLocalized(k-1)and (not TrainLocalized(k-1)or TrainRealignmentOnBeacon(k-1)):return Falseelse:return TrainPresumablyLocalized(k-1)#@TrainStoppedStartTime\uff0c\u8bb0\u5f55\u5f00\u59cb\u505c\u8f66\u7684\u65f6\u95f4%def TrainStoppedStartTime(k):if (Initializationor (not TrainFilteredStopped(k-1)and TrainFilteredStopped(k)):return ATPtime(k)else:return TrainStoppedStartTime(k-1)#@TrainLocatedOnOtherATP\uff0c\u672c\u7aef\u548c\u8fdc\u7aef\u90fd\u5728\u505c\u8f66\u72b6\u6001\u65f6\uff0c\u624d\u6709\u53ef\u80fd\u4f7f\u7528\u8fdc\u7aef\u5b9a\u4f4d", "en": "Only when ATP and redundant ATP are all in filtered stopped state, can ATP use redundant ATP location for initialization.", "code": "def TrainLocatedOnOtherATP(k):    if (OtherATP(k).LocatedOnKnownPath        and TrainFilteredStopped(k)        and OtherATP(k).TrainFilteredStopped        and Message.IsMoreRecent(OtherATP(k).LatestTimeOtherCore, TrainStoppedStartTime(k))        and not TrainLocatedOnKnownPath(k-1)        and not TrainPresumablyLocalized(k)):        TrainLocatedOnOtherATP = True    else:        TrainLocatedOnOtherATP = False    return TrainLocatedOnOtherATP"}, {"cn": "TrainInitialLocation\uff0c\u8bb0\u5f55\u5217\u8f66\u901a\u8fc7\u8fdc\u7aefATP\u3001\u8bb0\u5fc6\u5b9a\u4f4d\u3001\u6216\u4fe1\u6807\u521d\u59cb\u5316\u65f6\u7684\u4f4d\u7f6e\u3002\u5982\u679c\u5217\u8f66\u5931\u4f4d\uff0c\u5219\u6e05\u9664\u8be5\u4f4d\u7f6e\uff1b\u5982\u679c\u5217\u8f66\u4fdd\u6301\u5b9a\u4f4d\uff0c\u5219\u4fdd\u7559\u8be5\u4f4d\u7f6e\u3002", "en": "ATP determine the initial train location by redundant ATP, memorized location and beacon location in order. If train delocalized, the train location should be clear.", "code": "def TrainInitialLocation(k):    if (TrainLocatedOnOtherATP(k)):        return OtherATP(k).Location    elif (TrainPresumablyLocalized(k)          and not TrainHasMoved(k)):        return MemLocation(k)    elif (TrainLocatedOnBeacon(k)):        return BeaconLocation(k)    elif (TrainLocalized(k-1)):        return TrainInitialLocation(k-1)    else:        return None"}, {"cn": "LocationBeforeReloc\uff0c\u4e0a\u5468\u671f\u5217\u8f66\u5df2\u5b9a\u4f4d\u7684\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u91cc\u7a0b\u8ba1\u6d4b\u5f97\u7684\u4f4d\u79fb\u6765\u66f4\u65b0\u5217\u8f66\u5b9a\u4f4d\u3002", "en": "If train has localized on the track map, according to the orientation of END_2, ATP using the maximum and minimum train motion to update the external or internal location of the END_2.", "code": "def LocationBeforeReloc(k):    if (TrainLocalized(k-1) and ValidTrainKinematic(k)):        if (OdometerState(k) is INITIALIZED):            if (End2RunningForward(k)):                LocationBeforeReloc.Uncertainty = (TrainLocation(k-1).Uncertainty                                                     - (MaximumTrainMotion(k) - MinimumTrainMotion(k)))            else:                LocationBeforeReloc.Uncertainty = (TrainLocation(k-1).Uncertainty                                                     + (MaximumTrainMotion(k) - MinimumTrainMotion(k)))        else:            LocationBeforeReloc.Uncertainty = (TrainLocation(k-1).Uncertainty                                                      + abs(MaximumTrainMotion(k))                                                      + abs(MinimumTrainMotion(k)))         LocationBeforeReloc.Ext2 = (TrackMap.LocationUpdateExt2(End2RunningForward(k),                                                                           TrainLocation(k-1).Ext2.Ort,                                                                           TrainLocation(k-1).Ext2,                                                                           MaximumTrainMotion(k),                                                                           MinimumTrainMotion(k)))        LocationBeforeReloc.Int2 = UpdateInt2FromExt2        LocationBeforeReloc.Ext1 = UpdateExt1FromExt2        LocationBeforeReloc.Int1 = UpdateInt1FromExt2    else:        LocationBeforeReloc = None    return LocationBeforeReloc"}, {"cn": "LocationUntravelable\uff0c\u5224\u65ad\u8f66\u8eab\u8303\u56f4\u5185\u662f\u5426\u6709\u7ebf\u8def\u8fb9\u754c\u6216\u8005\u72b6\u6001\u4e0d\u7b26\u7684\u9053\u5c94\u3002\u5f53\u4e0a\u5468\u671f\u5217\u8f66\u5b9a\u4f4d\uff0c\u5e76\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\u65f6\uff0c\u672c\u5468\u671f\u8bbe\u7f6e\u4e3aTrue\u3002\u5982\u679c\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u5230\u8f66\u5934\u6700\u5927\u5b9a\u4f4d\u4e4b\u95f4\u5b58\u5728\u72b6\u6001\u672a\u77e5\u7684\u9053\u5c94(\u5305\u62ec\u53d1\u6563\u6216\u6c47\u805a\u8282\u70b9)\uff1b\u6216\u8005\uff0c\u5982\u679c\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u5230\u8f66\u5934\u6700\u5927\u5b9a\u4f4d\u4e4b\u95f4\u5b58\u5728\u53d8\u91cf\u72b6\u6001\u4e0e\u4e4b\u524d\u5217\u8f66\u4f4d\u7f6e\u4e0d\u7b26\u7684\u53d1\u6563\u6c47\u805a\u8282\u70b9\uff1b\u6216\u8005\uff0c\u8f68\u9053\u8fb9\u754c\u5728\u5217\u8f66\u5b9a\u4f4d\u8303\u56f4\u5185\uff1b\u5426\u5219\uff0c\u8bbe\u7f6e\u8be5\u503c\u4e3aFalse\u3002", "en": "ATP shall determine whether there is an unknown-status point intersecting with the train location.If the train has localized at the previous cycle, and fulfills one of the following conditions: There is an unknown-status divergence of convergence located in the range from train tail to train head, then ATP shall set as True; Or else:, if there is a convergence with reverse route located in the range from train tail to train head, the ATP shall set as True;Or else, train crossed the boundary of ATC area, shall set as True.Otherwise, set as False.", "code": "def LocationUntravelable(k):    return (TrainLocalized(k-1)             and (not (TrackMap.ReachableBetweenTwoLocations                         (LocationBeforeReloc(k).Ext2, LocationBeforeReloc(k).Ext1,                          (abs(MaximumTrainMotion) + ATPsetting.LocationTrainLength                                + LocationBeforeReloc(k).Uncertainty)))                   or not (TrackMap.ReachableBetweenTwoLocations                            (LocationBeforeReloc(k).Ext1, LocationBeforeReloc(k).Ext2,                             (abs(MaximumTrainMotion) + ATPsetting.LocationTrainLength                              + LocationBeforeReloc(k).Uncertainty)))))"}, {"cn": "InverseLocation\uff0c\u5224\u65adEND_2\u8f66\u5934\u7684\u5916\u4fa7\u548c\u5185\u4fa7\u5b9a\u4f4d\u987a\u5e8f\u662f\u5426\u6b63\u786e\u3002", "en": "ATP shall determine the correct order of the external and internal location of train END.", "code": "def InverseLocation(k):    return (LocationBeforeReloc(k).Uncertainty < 0)"}, {"cn": "LocationUncertaintyExceed\uff0c\u5217\u8f66\u5b9a\u4f4d\u72b6\u6001\u4e0b\uff0c\u6bcf\u5468\u671f\u8ba1\u7b97\u5217\u8f66\u5916\u4fa7\u5b9a\u4f4d\u548c\u5185\u4fa7\u4e4b\u95f4\u7684\u8ddd\u79bb\u662f\u5426\u8d85\u8fc7\u6700\u5927\u5141\u8bb8\u8bef\u5dee\u3002", "en": "ATP shall calculate the uncertain distance between the external and internal locations of train END_2.", "code": "def LocationUncertaintyExceed(k):    return (LocationBeforeReloc(k).Uncertainty > ATPsetting.LocationMaxUncertaintyConfirmed)"}, {"cn": "TrainRealignmentOnBeacon\uff0c\u662f\u5426\u5728\u4fe1\u6807\u4e0a\u91cd\u5b9a\u4f4d\u6210\u529f%def TrainRealignmentOnBeacon(k):return (TrainLocalized(k-1)and NewBeaconObtained(k)and (TrackMap.IntersectionOfTwoZones(BeaconLocation.Int2, BeaconLocation.Ext2,LocationBeforeReloc.Int2, LocationBeforeReloc.Ext2)is not None))#@RealignmentFailed\uff0c\u4e0a\u5468\u671f\u5b9a\u4f4d\u72b6\u6001\u4e0b\uff0c\u5982\u679c\u8bfb\u5230\u65b0\u7684\u91cd\u5b9a\u4f4d\u4fe1\u6807\uff0c\u4f46ATP\u6839\u636e\u4f4d\u79fb\u8ba1\u7b97\u7684\u6700\u5927\u6700\u5c0f\u5b9a\u4f4d\uff0c\u4e0e\u901a\u8fc7\u8bfb\u5230\u4fe1\u6807\u4f4d\u7f6e\u8ba1\u7b97\u7684\u6700\u5927\u6700\u5c0f\u5b9a\u4f4d\u4e4b\u95f4\u6ca1\u6709\u4ea4\u96c6\uff0c\u5219\u8ba4\u4e3a\u91cd\u5b9a\u4f4d\u5931\u8d25\u3002%def RealignmentFailed(k):return (TrainLocalized(k-1)and NewBeaconObtained(k)and (TrackMap.IntersectionOfTwoZones(BeaconLocation.Int2, BeaconLocation.Ext2,LocationBeforeReloc.Int2, LocationBeforeReloc.Ext2)is None))#@LocationAfterReloc\uff0c\u7ecf\u8fc7\u4fe1\u6807\u91cd\u5b9a\u4f4d\u540e\u7684\u5217\u8f66\u5b9a\u4f4d%def LocationAfterReloc(k):if (TrainRealignmentOnBeacon(k)):(LocationAfterReloc.Int2,LocationAfterReloc.Ext2) = (TrackMap.IntersectionOfTwoZones(LocationBeforeReloc(k).Int2,LocationBeforeReloc(k).Ext2,BeaconLocation(k).Int2,BeaconLocation(k).Ext2))LocationAfterReloc.Uncertainty = (TrackMap.DistanceBtwTwoLocs(LocationAfterReloc.Int2,LocationAfterReloc.Ext2,ATPsetting.LocationMaxUncertaintyConfirmed))LocationAfterReloc.Int1 = UpdateInt1FromExt2LocationAfterReloc.Ext1 = UpdateExt1FromExt2elif (not TrainLocalized(k-1)):LocationAfterReloc = Noneelse:LocationAfterReloc = LocationAfterReloc(k-1)return LocationAfterReloc#@LocPermanentFailure\uff0c\u5728\u5217\u8f66\u5df2\u5b9a\u4f4d\uff0c\u4e14\u672a\u4f7f\u7528\u975e\u786e\u8ba4\u7684BM\u53d8\u91cf\u60c5\u51b5\u4e0b\uff0c\u82e5\u53d1\u751f\u91cd\u5b9a\u4f4d\u5931\u8d25\uff0c\u5219\u6c38\u4e45\u5931\u4f4d\u3002%def LocPermanentFailure(k):return (LocPermanentFailure(k-1)or (TrainLocatedOnKnownPath(k-1)and RealignmentFailed(k)))#@MotionSinceLastReloc\uff0c\u8bb0\u5f55\u81ea\u4e0a\u6b21\u4fe1\u6807\u91cd\u5b9a\u4f4d\u540e\u7684\u8fd0\u884c\u8ddd\u79bb\u7edd\u5bf9\u503c%def MotionSinceLastReloc(k):if (TrainLocatedOnOtherATP(k)):return OtherATP(k).MotionSinceLastRelocelif (TrainRealignmentOnBeacon(k)):return abs(DistLastBeaconMax(k))elif (not TrainLocalized(k-1)):return 0else:return (MotionSinceLastReloc(k-1) + abs(MaximumTrainMotion(k)))#@CBTCwithoutKnownPath\uff0c\u5728CBTC\u4e0b\uff0c\u82e5\u4e0a\u5468\u671f\u5b9a\u4f4dpath\u4e3a\u5047\uff0c\u5219\u5931\u4f4d%def CBTCwithoutKnownPath(k):return (TrainLocalized(k-1)and not LocationPathKnown(k-1)and not BlockModeUsed(k))#@TrainUnitIntegrity\uff0c\u4efb\u4e00\u7aef\u8f66\u5934\u80fd\u4fdd\u8bc1\u5217\u8f66\u5b8c\u6574\u6027\uff0c\u5219\u8ba4\u4e3a\u8f66\u8f86\u5b8c\u6574\u6027\u80fd\u88ab\u4fdd\u8bc1\u3002\u5982\u679c\u8be5\u9879\u76ee\u672a\u914d\u7f6e\u5217\u8f66\u5b8c\u6574\u6027\u91c7\u96c6\uff0c\u5219\u8ba4\u4e3a\u5217\u8f66\u5b8c\u6574\u6027\u5df2\u7531\u8f66\u8f86\u4fdd\u8bc1\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "If either of ends can ensure the train integrity, ATP shall set TrainUnitIntegrity as True. If the project is not configured with the capture of train integrity, it is sure that the train can guarantees the integrity.", "code": "def TrainUnitIntegrity(k):    return Offline.GetTrainUnitIntegrity(k)"}, {"cn": "LocalizationFault\u7528\u4e8e\u8868\u660e\u662f\u5426\u53d1\u751f\u5b9a\u4f4d\u9519\u8bef\u3002\u5224\u65ad\u6761\u4ef6\u5982\u4e0b:", "en": "If the localization state is not NOT_LOCALIZED, ATP shall determine whether the localization fault happens or not, according to the following pseudo-codes:", "code": "def LocalizationFault(k):    return (not TrainUnitIntegrity(k)             or not ValidTrainKinematic(k)             or LocationUntravelable(k)             or InverseLocation(k)             or LocationUncertaintyExceed(k)             or RealignmentFailed(k)             or LocPermanentFailure(k)             or (MotionSinceLastReloc(k) > ATPsetting.LocationBeaconValidityDistance)             or (MemLocationNotConfirmed(k-1)                 and abs(MotionSinceMemorizedLocation(k)) >= ATPsetting.MemLocValidityDistance)             or CBTCwithoutKnownPath(k)             or CoupledTypeInconsistent(k))"}, {"cn": "TrainLocalized\uff0c\u8868\u793a\u5f53\u524d\u5217\u8f66\u662f\u5426\u5b9a\u4f4d\u3002\u5f53\u5217\u8f66\u5b9a\u4f4d\u521d\u59cb\u5316\u540e\uff0cATP\u53ef\u6839\u636e\u91cc\u7a0b\u8ba1\u6d4b\u5f97\u5e76\u7ecf\u6253\u6ed1\u8865\u507f\u548c\u8f74\u9501\u5224\u65ad\u5904\u7406\u7684\u5217\u8f66\u4f4d\u79fb\uff0c\u6bcf\u5468\u671f\u66f4\u65b0\u5217\u8f66\u5728\u7ebf\u8def\u5730\u56fe\u4e2d\u7684\u4f4d\u7f6e\u3002\u5982\u679c\u518d\u8bfb\u5230\u4fe1\u6807\uff0c\u5219ATP\u53ef\u6839\u636e\u8be5\u4fe1\u6807\u7684\u4f4d\u7f6e\u5bf9\u4e4b\u524d\u7684\u5b9a\u4f4d\u8fdb\u884c\u91cd\u65b0\u6821\u6b63\u3002\u8003\u8651\u5230\u5b89\u5168\uff0cATP\u9700\u7ef4\u62a4\u5217\u8f66\u6bcf\u7aef\u8f66\u5934\u7684\u5916\u4fa7\u548c\u5185\u4fa7\u4e24\u7ec4\u5b9a\u4f4d\u4fe1\u606f\u3002", "en": "Only the localization state is LOCALIZED, ATP shall consider the train has localized. When the train passed the continuous two beacons, ATP can judge the initial location and direction according to the position and the sequences of above-mentioned beacons in track map. Later, ATP can update the train location in the track map in each cycle based on the train movement combined with sliding overestimation and wheel block consideration. If ATP received a new beacon, it will realign the train location according to this beacon. For safety, ATP needs to maintain the location information from the external and internal side of each trainend.", "code": "def TrainLocalized(k):    if (Initialization        or LocalizationFault(k)):        return False    elif (not TrainLocalized(k-1)          and (TrainPresumablyLocalized(k)               or TrainLocatedOnOtherATP(k)               or TrainLocatedOnBeacon(k))):        return True    else:        return TrainLocalized(k-1)"}, {"cn": "TrainLocation\uff0c\u5217\u8f66End1\u548cEnd2\u7aef\u5b9a\u4f4d\u3002\u5206\u4e3a\u4ee5\u4e0b\u56db\u79cd\u60c5\u51b5\uff1a\u672c\u5468\u671f\u975e\u5b9a\u4f4d\uff1b\u672c\u5468\u671f\u521a\u521d\u59cb\u5316\uff1b\u672c\u5468\u671f\u7ecf\u8fc7\u4fe1\u6807\u91cd\u5b9a\u4f4d\uff1b\u672c\u5468\u671f\u4f7f\u7528\u4f4d\u79fb\u7d2f\u52a0\u5b9a\u4f4d\u3002%def TrainLocation(k):if (not TrainLocalized(k)):return Noneelif (not TrainLocalized(k-1)):return TrainInitialLocation(k)elif (TrainRealignmentOnBeacon(k)):return LocationAfterReloc(k)else:return LocationBeforeReloc(k)#@DriverInCab_1\u6216DriverInCab_2\uff0c\u5982\u679c\u91c7\u96c6\u5230\u67d0\u7aef\u7684\u9a7e\u9a76\u5ba4\u88ab\u6fc0\u6d3b\uff0c\u5219ATP\u8ba4\u4e3a\u53f8\u673a\u5728\u8be5\u7aef\u9a7e\u9a76\u5ba4\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "ATP shall consider the driver is in this cab if it captures that either end of cab activated, which shown by the data from DriverInCab_1 or DriverInCab_2.", "code": "def DriverInCab_1(k):    return Offline.GetDriverInCab_1(k)def DriverInCab_2(k):    return Offline.GetDriverInCab_2(k)"}, {"cn": "DriverInTrain\uff0c\u5f53\u524d\u662f\u5426\u6709\u53f8\u673a\u5728\u8f66\u5185", "en": "If the active status is different between two ENDs of the train, ATP consider there is a driver in train.", "code": "def DriverInTrain(k):    return (DriverInCab_1(k) is not DriverInCab_2(k))"}, {"cn": "NonVitalSelectedFrontEnd\uff0c\u6765\u81eaCCNV\u7684\u8f66\u5934\u9009\u62e9\u4fe1\u606f\uffe5NonVitalSelectedFrontEnd represents the train front choice from CCNV.%if (ATOcontrolTimeValid(k) == True)NonVitalSelectedFrontEnd = NonVitalRequest.SelectedFrontEnd(k)else:NonVitalSelectedFrontEnd = UNKNOW#@TrainFrontEnd\uff0c\u5224\u65ad\u53f8\u673a\u5728END_1\u8fd8\u662fEND_2\u8fd8\u662f\u7531CCNV\u9009\u62e9\u3002", "en": "If there is a driver in the train, the train front is the activated END. or else: the front determined by CCNV.Otherwise, the train front is the default one or the front one when train is moving.", "code": "def TrainFrontEnd(k):    if (Initialization):       return END_2    elif (DriverInTrain(k)):        if (DriverInCab_1(k)):            return END_1        else:            return END_2    elif (NonVitalSelectedFrontEnd(k) is END_1          or NonVitalSelectedFrontEnd(k) is END_2):        return NonVitalSelectedFrontEnd(k)    elif (WheelFilteredStopped(k)):        return TrainFrontEnd(k-1)    elif (not End2RunningForward(k)):        return END_1    else:        return END_2"}, {"cn": "TrainFrontOrientation\uff0c\u5217\u8f66\u8fd0\u8425\u65b9\u5411.", "en": "The train front orientation is the orientation of the active train END.", "code": "def TrainFrontOrientation(k):    if (TrainFrontEnd(k) is END_2):        return TrainLocation.Ext2.Ort(k)    else:        return TrainLocation.Ext1.Ort(k)"}, {"cn": "TrainFrontLocation\uff0c\u8f66\u5934\u5b9a\u4f4d\u7684\u66f4\u65b0:", "en": "ATP updates the train front location according to the active train END.", "code": "def TrainFrontLocation(k):    if (TrainFrontEnd(k) is END_1):        TrainFrontLocation.Max = TrainLocation.Ext1        TrainFrontLocation.Min = TrainLocation.Int1    else:        TrainFrontLocation.Max = TrainLocation.Ext2        TrainFrontLocation.Min = TrainLocation.Int2    return TrainFrontLocation"}, {"cn": "TrainRearLocation\uff0c\u8f66\u5c3e\u5b9a\u4f4d\u7684\u66f4\u65b0:", "en": "ATP updates the train rear locations according to the active train END.", "code": "def TrainRearLocation(k):    if (TrainFrontEnd(k) is END_1):        TrainRearLocation.Max = TrainLocation.Int2        TrainRearLocation.Min = TrainLocation.Ext2    else:        TrainRearLocation.Max = TrainLocation.Int1        TrainRearLocation.Min = TrainLocation.Ext1    return TrainRearLocation"}, {"cn": "LocationPathKnown\uff0c\u5224\u65ad\u5217\u8f66\u5728Block\u6a21\u5f0f\u6ca1\u6709\u79fb\u52a8\u6388\u6743\u6761\u4ef6\u4e0b\u662f\u5426\u7ecf\u8fc7\u9053\u5c94\u5bfc\u81f4\u975e\u786e\u8ba4\u5b9a\u4f4d\u3002", "en": "In BM mode, if train localized but EOA is invalid, LocationPathKnown cannot be TRUE when train cross switch. After train crossed switch and relocalized by beacon successfully, LocationPathKnown can be set to TRUE.", "code": "def LocationPathKnown(k):    if (Initialization         or (BlockModeUsed(k)            and TrainLocalized(k)            and not BlockModeEOAvalid(k-1)            and not TrainFilteredStopped(k)            and TrackMap.ExistSwitchBtwTwoLocs(TrainRearLocation(k).Min,                                                      TrainFrontLocation(k).Max))):        return False    elif (TrainLocatedOnBeacon(k)          or TrainRealignmentOnBeacon(k)          or TrainLocatedOnOtherATP(k)          or (TrainPresumablyLocalized(k) and not TrainHasMoved(k))):        return True    else:        return LocationPathKnown(k-1)"}, {"cn": "TrainLocatedOnKnownPath\uff0c\u5224\u65ad\u5217\u8f66\u662f\u5426\u5b9a\u4f4d\u5e76\u5df2\u77e5LocationPathKnown\u3002%def TrainLocatedOnKnownPath(k):return (TrainLocalized(k)and LocationPathKnown(k))#@LocalizationState\uff0c\u5217\u8f66\u7684\u5b9a\u4f4d\u72b6\u6001\uff0c\u7528\u4e8e\u7528\u4e8e\u7ef4\u62a4\u8bca\u65ad\u529f\u80fd\u3002%def LocalizationState(k):if (TrainLocatedOnKnownPath(k)and not MemLocationNotConfirmed(k)):return LOCALIZED_CONFIRMEDelif (TrainLocalized(k)):return LOCALIZED_NOT_CONFIRMEDelif (MovingInitialByBeacon(k)):return MOVING_INITelse:return NOT_LOCALIZED#@MemLocationNotConfirmed\uff0c\u662f\u5426\u901a\u8fc7\u672c\u7aef\u6216\u8fdc\u7aef\u7684\u8bb0\u5fc6\u5b9a\u4f4d\u521d\u59cb\u5316\u5217\u8f66\u5b9a\u4f4d\uff0c\u4f46\u8fd8\u672a\u901a\u8fc7\u91cd\u5b9a\u4f4d\u4fe1\u6807\u786e\u8ba4\u5b9a\u4f4d\u3002%def MemLocationNotConfirmed(k):if (Initializationor not TrainLocalized(k)or TrainRealignmentOnBeacon(k)):return Falseelif (TrainPresumablyLocalized(k)):return Trueelif (TrainLocatedOnOtherATP(k)):return OtherATP.LocatedWithMemLocation(k)else:return MemLocationNotConfirmed(k-1)#@LocationUncertaintyExceedTime\uff0c\u8bb0\u5f55\u8d85\u8fc7\u6700\u5927\u5b9a\u4f4d\u8bef\u5dee\u7684\u65f6\u95f4%def LocationUncertaintyExceedTime(k):if (Initialization):return 0elif (TrainLocalized(k)and ((MemLocationNotConfirmed(k) or not LocationPathKnown(k))and (TrainLocation(k).Uncertainty> ATPsetting.LocationMaxUncertaintyNotConfirmed))):return (ATPtime(k) + ATPsetting.LocReportValidityTime)else:return LocationUncertaintyExceedTime(k-1)#@LocationNotUncertaintyExceed\uff0c\u5224\u65ad\u662f\u5426\u8fd8\u5904\u5728\u6700\u5927\u5b9a\u4f4d\u8bef\u5dee\u7684\u786e\u8ba4\u65f6\u95f4\u5185%def LocationNotUncertaintyExceed(k):if (Initialization):return Falseelif (TrainLocalized(k)):return Message.IsMoreRecent(ATPtime(k), LocationUncertaintyExceedTime(k))else:return LocationNotUncertaintyExceed(k-1)#@LocalizedAuthorizationForSweepping\uff0c\u53d1\u7ed9ZC\u7684\u662f\u5426\u5b9a\u4f4d\u4fe1\u606f\u3002", "en": "ATP shall send the current localization status to the ZC.", "code": "def LocalizedAuthorizationForSweepping(k):    return (TrainLocalized(k)            and LocationNotUncertaintyExceed(k))"}, {"cn": "TrainConfirmedLocalized\uff0c\u53d1\u7ed9ZC\u7684\u662f\u5426\u786e\u8ba4\u5b9a\u4f4d\u4fe1\u606f\u3002", "en": "ATP shall send the status of the localization status whether confirmed.", "code": "def TrainConfirmedLocalized(k):    return (LocationPathKnown(k)            and not MemLocationNotConfirmed(k))"}, {"cn": "TrainIncludedInSleepingZone\uff0c\u5217\u8f66\u505c\u8f66\u540e\u5b9a\u4f4d\u5b8c\u5168\u6240\u5728\u7684Sleeping zone%def TrainIncludedInSleepingZone(k):if (not TrainFilteredStopped(k)):return Noneelse:for SleepZone in (TrackMap.AllSingsBtwTwoLocs(SGL_SLEEPING_ZONE,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrainFrontLocation(k).Max)):if (TrackMap.LocationInZone(TrainFrontLocation(k).Max,SleepZone.Location,SleepZone.Length,SleepZone.Orientation)and TrackMap.LocationInZone(TrainRearLocation(k).Min,SleepZone.Location,SleepZone.Length,SleepZone.Orientation)):return SleepZoneelse:continue:return None#@WritingMemLocRequest\uff0c\u662f\u5426\u5199\u5165\u8bb0\u5fc6\u5b9a\u4f4d\u3002", "en": "Only when train has moved and filtered stopped in sleeping zone, can ATP writing memorized location information.", "code": "def WritingMemLocRequest(k):    return (TrainHasMoved(k)              and TrainIncludedInSleepingZone(k) is not None              and TrainLocatedOnKnownPath(k))"}, {"cn": "ClearingMemLocRequest\uff0c\u662f\u5426\u6e05\u9664\u8bb0\u5fc6\u5b9a\u4f4d", "en": "When train has moved and does not fulfill the condition of writing memory location, ATP shall clear memorized location information.", "code": "def ClearingMemLocRequest(k):    return (not WritingMemLocRequest(k) and TrainHasMoved(k))"}, {"cn": "MemLocWritten\uff0c\u5199\u5165\u8bb0\u5fc6\u5b9a\u4f4d\u7684\u5185\u5bb9%def MemLocWritten(k):if (WritingMemLocRequest(k)):MemLocWritten.MemLocVersion = MEM_LOCATION_VERSIONMemLocWritten.SleepAreaId = TrainIncludedInSleepingZone(k).IdMemLocWritten.SleepAreaVersion = TrainIncludedInSleepingZone(k).VersionMemLocWritten.TrainType = TrainType(k)MemLocWritten.TrainId = SubSystemId(k)MemLocWritten.Ext2 = TrainLocation.Ext2MemLocWritten.Ext1 = TrainLocation.Ext1MemLocWritten.Uncertainty = TrainLocation.UncertaintyMemLocWritten.TrainLength = ATPsetting.LocationTrainLengthelif (ClearingMemLocRequest(k)):MemLocWritten.MemLocVersion = NoneMemLocWritten.SleepAreaId = NoneMemLocWritten.SleepAreaVersion = NoneMemLocWritten.TrainType = NoneMemLocWritten.TrainId = NoneMemLocWritten.Ext2 = NoneMemLocWritten.Ext1 = NoneMemLocWritten.Uncertainty = NoneMemLocWritten.TrainLength = Noneelse:MemLocWritten = MemLocWritten(k-1)return MemLocWritten#@RestrictiveSignalOverrun\uff0cBM\u6a21\u5f0f\u4e0b\uff0c\u672c\u5468\u671f\u5217\u8f66\u8f66\u5934\u6700\u5927\u5b9a\u4f4d\u662f\u5426\u5192\u8fdb\u9650\u5236\u72b6\u6001\u7684\u4fe1\u53f7\u673a\u3002\u5f53\u6ee1\u8db3\u4ee5\u4e0b\u6240\u6709\u6761\u4ef6\u65f6\uff0cATP\u8ba4\u4e3a\u5217\u8f66\u5192\u8fdb\u4e86\u9650\u5236\u72b6\u6001\u7684\u4fe1\u53f7\u673a\uff0c\u9700\u8bbe\u7f6eRestrictiveSignalOverrun\u4e3aTrue\u3002\u672c\u5468\u671f\u5217\u8f66\u5df2\u5b9a\u4f4d\uff0c\u5373TrainLocalized\u4e3aTrue\uff1b\u672c\u5468\u671f\u4f7f\u7528BM\u53d8\u91cf\uff1b\u4e0a\u5468\u671fRestrictiveSignalOverrun\u4e3aFalse\uff1b\u672c\u5468\u671f\u5217\u8f66\u4f4d\u79fbMaximumTrainMotion\u5411\u6fc0\u6d3b\u7684\u9a7e\u9a76\u5ba4\u65b9\u5411\u8fd0\u884c\uff1b\u672c\u5468\u671f\u5217\u8f66\u8f66\u5934\u6700\u5927\u5b9a\u4f4dTrainFrontLocation\u7ecf\u8fc7\u4e86\u4e00\u4e2a\u4fe1\u53f7\u673a\u5947\u70b9\uff1b\u8be5\u4fe1\u53f7\u673a\u4e3a\u9650\u5236\u72b6\u6001\uff0c\u6216\u8005\u5efa\u7acb\u4e86Overlap\u7684\u72b6\u6001\u3002\u5426\u5219\uff0c\u8bbe\u7f6eRestrictiveSignalOverrun\u4e3aFalse\u3002", "en": "RestrictiveSignalOverrun, ATP shall determine whether the location of maximum train head overruns a restricted signal in BLOCK mode.When all of the following conditions fulfilled, ATP considers the train has overrun a restricted signal in this cycle, and set RestrictiveSignalOverrun as True.Train has localized;And the current type of EOA is BLOCK_MODE_EOA; And RestrictiveSignalOverrun was False at the last cycle;And the moving direction in current cycle is toward on the train front end; And the maximum location of train front end passes the position of the signal in this cycle;And the status of the signal is restriction or overlap established.Otherwise, ATP set RestrictiveSignalOverrun as False.", "code": "def RestrictiveSignalOverrun(k):    sing = TrackMap.ExistSingBtwTwoLocs(SGL_SIGNAL, TrainFrontLocation(k-1).Max,                                               TrainFrontLocation(k).Max)    return (sing is not None            and BMvariantValidWhileTemporallyValid(k)            and ((TrainFrontEnd(k) is END_2 and End2RunningForward(k))                 or (TrainFrontEnd(k) is END_1 and End1RunningForward(k)))            and not BMvariantValue(sing.Variant, k))"}, {"cn": "TrainInBMinitialZone\uff0c\u8f66\u5934\u6700\u5c0f\u5b9a\u4f4d\u5728\u5728BM\u521d\u59cb\u5316\u533a\u57df\u5185\u3002%def TrainInBMinitialZone(k):NewBlock = TrackMap.ExistSingularityInZone(SGL_NEW_BLOCK, TrainFrontLocation(k).Min,ATPsetting.BMinitAreaLength)Signal = (TrackMap.ExistSingularityInReverseZone(SGL_SIGNAL,NewBlock.Location,ATPsetting.BMinitAreaLength))if (Signal is not Noneand Signal.BmInitialization):return Signalelse:return None#@TrainEnteredInBMinitialZoneAge\uff0c \u5982\u679c\u5217\u8f66\u5728BM\u521d\u59cb\u5316\u533a\u57df\u5185\uff0c\u5219\u8bb0\u5f55\u5df2\u5728\u8be5\u533a\u57df\u5185\u8fd0\u884c\u7684\u65f6\u95f4%def TrainEnteredInBMinitialZoneAge(k):if (TrainInBMinitialZone(k) is None):TrainEnteredInBMinitialZoneAge = 0else:TrainEnteredInBMinitialZoneAge = TrainEnteredInBMinitialZoneAge(k-1) + 1return TrainEnteredInBMinitialZoneAge#@StopAssuredPointCrossed\uff0c\u672c\u5468\u671f\u662f\u5426\u901a\u8fc7\u4e86\u4fe1\u53f7\u673a\u524d\u65b9\u7684BMCP\u70b9%def StopAssuredPointCrossed(Cbi, k):Bmcp = TrackMap.ExistSingBtwTwoLocs(SGL_BMCP, TrainFrontLocation(k-1).Max,TrainFrontLocation(k).Max)return (Bmcp is not Noneand cbi == Bmcp.CbiId)#@CBIminProductionAgeSinceSSAcrossing\uff0c\u8bb0\u5f55\u4ece\u901a\u8fc7\u4e0a\u4e2aBMCP\u70b9\u5f00\u59cb\u5230\u73b0\u5728\u5df2\u7ecf\u8fc7\u4e86\u591a\u957f\u65f6\u95f4%def CBIminProductionAgeSinceSSAcrossing(Cbi, k):if (Initializationor CBIminProductionAgeSinceSSAcrossing(k-1)>= REPORT_AGE_MAX):return REPORT_AGE_MAXelif (StopAssuredPointCrossed(Cbi, k)):return ATPsetting.VariantsBMALSpresenceTimerelse:return (CBIminProductionAgeSinceSSAcrossing(Cbi, k-1) + 1)#@CBIminProductionAge\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u8054\u9501\uff0cATP\u7ef4\u62a4\u6700\u540e\u6536\u5230\u5176\u53d8\u91cf\u6d88\u606f\u65f6\u8054\u9501\u7684\u6700\u5c0f\u65f6\u95f4\uff0c\u5230\u73b0\u5728\u7ecf\u8fc7\u7684\u65f6\u95f4\u3002%def CBIminProductionAge(cbi, k):return min(CBIminProductionAgeSinceSSAcrossing(Cbi, k),CBIvariantReportLastAge(Cbi, k))#@ReceivedVariantsAfterEnteredBMinitialZone\uff0c\u5148\u8fdb\u5165BM\u521d\u59cb\u5316\u533a\uff0c\u518d\u6536\u5230\u65e0\u7ebf\u6216\u8005\u4fe1\u6807\u7684\u53d8\u91cf%def ReceivedVariantsAfterEnteredBMinitialZone(k):CbiId = TrackMap.CbiId(TrainInBMinitialZone(k).Block)return (TrainInBMinitialZone(k) is not Noneand ((CBIvariantMoreAvailableThanBeacon(CbiId, k)and ((CBIvariantReportLastAge(CbiId, k)+ ATPsetting.VariantsBMproductionLatencyRadio)< TrainEnteredInBMinitialZoneAge(k)))or (BMbeaconReadAge(k) + ATPsetting.VariantsBMproductionLatencyBeacon< TrainEnteredInBMinitialZoneAge(k))))#@BlockModeEOAvalid\uff0cBM\u4e0b\u7684\u79fb\u52a8\u6388\u6743\u662f\u5426\u53ef\u7528%def BlockModeEOAvalid(k):if (Initializationor not BlockModeUsed(k)or TrainFrontEnd(k) is not TrainFrontEnd(k-1)or not TrainLocatedOnKnownPath(k)or HazardousMotionOnNonExclusiveRoute(k)or RestrictiveSignalOverrun(k)):return Falseelif (not BlockModeEOAvalid(k-1)and TrainInBMinitialZone(k) is not Noneand BMvariantValue(TrainInBMinitialZone.Variant(k), k)and ReceivedVariantsAfterEnteredBMinitialZone(k)):return Trueelse:return BlockModeEOAvalid(k-1)#@TrainInSMIzone\uff0c\u5224\u65ad\u5f53\u8f66\u5934\u6700\u5927\u5b9a\u4f4d\u5728SMI\u533a\u57df\u5185\uff0c\u4e14\u8f66\u901f\u5c0f\u4e8eSMI\u9650\u901f\u65f6\uff0c\u53ef\u4f7f\u7528ZC\u7684EOA\u6d88\u606f\u4e2d\u7684WithoutSpacingEoa\u8fdb\u884c\u76d1\u63a7\u3002%def TrainInSMIzone(k):Smi = TrackMap.ExistZoneLocationIncluded(SGL_SMI_ZONE, TrainFrontEnd(k).Max)return (Smi is not Noneand TrainMaxSpeed(k) < Smi.SpeedLimit(k))#@CBTCmodeEOAvalid\uff0cCBTC\u6a21\u5f0f\u4e0b\u5224\u65ad\u6765\u81eaZC\u7684EOA\u662f\u5426\u6709\u6548\u3002\u5982\u679c\u5728SMI\u533a\u57df\u5185\u4e14\u8f66\u901f\u5c0f\u4e8eSMI\u9650\u901f\uff0c\u5219\u5e94\u5f53\u4f7f\u7528WithoutSpacingEOA\uff1b\u5426\u5219\uff0c\u5e94\u5f53\u4f7f\u7528\u666e\u901a\u7684EOA%def CBTCmodeEOAvalid(k):return (not BlockModeUsed(k)and ReceivedEOAreport.TrainFrontEnd == TrainFrontEnd(k)and ((TrainInSMIzone(k)and (Message.IsMoreRecent(ReceivedEOAreport(k).WithoutSpacing.ValidityTime,ATPtime(k)))and (ReceivedEOAreport(k).WithoutSpacing.Location.Block != 0)and (TrackMap.DistanceBtwTwoLocs(TrainFrontLocation(k).Min,ReceivedEOAreport(k).WithoutSpacing.Location,ATPsetting.EOAmaxDistance) is not None))or (not TrainInSMIzone(k)and TrainLocatedOnKnownPath(k)and (Message.IsMoreRecent(ReceivedEOAreport(k).Classic.ValidityTime,ATPtime(k)))and (ReceivedEOAreport(k).Classic.Location.BlockId != 0)and (TrackMap.DistanceBtwTwoLocs(TrainFrontLocation(k).Min,ReceivedEOAreport(k).Eoa.Location,ATPsetting.EOAmaxDistance) is not None))))#@CBTCmodeEOAlocation\uff0cCBTC\u4e0b\u7684EOA\u4f4d\u7f6e\u3002%def CBTCmodeEOAlocation(k):if (CBTCmodeEOAvalid(k)):if (TrainInSMIzone(k)):return ReceivedEOAreport.WithoutSpacing.Locationelse:return ReceivedEOAreport.Classic.Locationelse:return None#@EndOfAuthorityValid\uff0c\u7edf\u4e00BM\u6216CBTC\u4e0b\u7684EOA\u662f\u5426\u53ef\u7528\u3002%def EndOfAuthorityValid(k):if (BlockModeUsed(k)):return BlockModeEOAvalid(k)else:return CBTCmodeEOAvalid(k)#@TractionAuthorisedSenseEnd1\uff0c\u5982\u679cEOA\u6709\u6548\u4e14\u5728END_1\u65b9\u5411\uff0c\u5219ATP\u6388\u6743\u5217\u8f66\u5411END_1\u65b9\u5411\u8fd0\u884c\u3002", "en": "If current EOA is valid and whose orientation is END_1, ATP shall authorize the train can move toward END_1.", "code": "def TractionAuthorisedSenseEnd1(k):    if (EndOfAuthorityValid(k)        and TrainFrontEnd(k) is END_1):        TractionAuthorisedSenseEnd1 = True    else:        TractionAuthorisedSenseEnd1 = False    return TractionAuthorisedSenseEnd1"}, {"cn": "TractionAuthorisedSenseEnd2\uff0c\u5982\u679cEOA\u6709\u6548\u4e14\u5728END_2\u65b9\u5411\uff0c\u5219ATP\u6388\u6743\u5411\u9a7e\u9a76\u5ba42\u65b9\u5411\u8fd0\u884c\u3002", "en": "If current EOA is valid and whose orientation is END_2, ATP shall authorize the train can move toward END_2.", "code": "def TractionAuthorisedSenseEnd2(k):    if (EndOfAuthorityValid(k)        and TrainFrontEnd(k) is END_2):        TractionAuthorisedSenseEnd2 = True    else:        TractionAuthorisedSenseEnd2 = False    return TractionAuthorisedSenseEnd2"}, {"cn": "BMoverlapReleasableSendable\uff0c\u5728BM\u4e0b\u4e14\u672a\u88abATC\u5207\u9664\u72b6\u6001\u4e0b\uff0c\u901a\u8fc7\u65e0\u7ebf\u53d1\u7ed9CI\u89e3\u9501\u4fe1\u606f\u3002%def BMoverlapReleasableSendable(k):return Offline.GetBMoverlapReleasableSendable(k)#@OverlapReleasable\uff0c\u53ef\u53d1\u9001Overlap\u89e3\u9501\u4fe1\u606f%def OverlapReleasable(k):return (BMoverlapReleasableSendable(k)and TrainFilteredStopped(k)and BlockModeEOAvalid(k)and NonVitalRequest.OverlapRelease(k))#@CrossedOverlapTimerInitialSignal\uff0c\u5373\u672c\u5468\u671f\u901a\u8fc7\u4e00\u4e2aoverlap timer\u521d\u59cb\u5316\u4fe1\u53f7\u673a\u65f6\uff0c\u8fd4\u56de\u8be5\u4fe1\u53f7\u673a\u5947\u70b9%def CrossedOverlapTimerInitialSignal(k):Signal = TrackMap.ExistSingBtwTwoLocs(SGL_SIGNAL, TrainFrontLocation(k-1).Max,TrainFrontLocation(k).Max)if (Signal is not Noneand Signal.BmOverlapTimerInit):return Signalelse:return None#@OverlapTimer\uff0c\u5f53\u7ecf\u8fc7\u5177\u6709Overlap\u521d\u59cb\u5316\u5c5e\u6027\u7684\u4fe1\u53f7\u673a\u65f6\uff0c\u5c06OverlapTimer\u8bbe\u7f6e\u4e3a\u5f53\u65f6\u4fe1\u53f7\u673a\u7684\u53d8\u91cf\u6709\u6548\u671f\u3002%def OverlapTimer(k):if (not BlockModeEOAvalid(k)or OverlapReleasable(k)):return 0elif (BMvariantValidWhileTemporallyValid(k)and CrossedOverlapTimerInitialSignal(k) is not None):return BMvariantRemainingTime(CrossedOverlapTimerInitialSignal(k).CBIvariant.Id, k)else:return OverlapTimer(k-1) - 1#@OverlapTimerPermissive\uff0c\u7528\u4e8e\u5224\u65ad\u662f\u5426\u5728BM\u4e0b\u5f3a\u5236Overlap\u72b6\u6001\u5efa\u7acb.%def OverlapTimerPermissive(k):return (OverlapTimer(k) > 0)#@NotCoercedRestrictive_1\uff0c\u975e\u5f3a\u5236\u9650\u52361%def NotCoercedRestrictive_1(k):return Offline.GetNotCoercedRestrictive_1(k)#@NotCoercedRestrictive_2\uff0c\u975e\u5f3a\u5236\u9650\u52362%def NotCoercedRestrictive_2(k):return Offline.GetNotCoercedRestrictive_2(k)#@NotCoercedRestrictive_3\uff0c\u975e\u5f3a\u5236\u9650\u52363%def NotCoercedRestrictive_3(k):return Offline.GetNotCoercedRestrictive_3(k)#@NotCoercedRestrictive_4\uff0c\u975e\u5f3a\u5236\u9650\u52364%def NotCoercedRestrictive_4(k):return Offline.GetNotCoercedRestrictive_4(k)#@CoercedRestrictive\uff0c\u7b49\u4e8e\u76f8\u5e94\u7684\u201c\u975e\u5f3a\u5236\u9650\u5236\u201d\u53d6\u53cd\u3002%def CoercedRestrictive(ncr, k):if (ncr is NOT_COERCED_RESTRICTIVE_1):CoercedRestrictive = not NotCoercedRestrictive_1(k)elif (ncr is NOT_COERCED_RESTRICTIVE_2):CoercedRestrictive = not NotCoercedRestrictive_2(k)elif (ncr is NOT_COERCED_RESTRICTIVE_3):CoercedRestrictive = not NotCoercedRestrictive_3(k)elif (ncr is NOT_COERCED_RESTRICTIVE_4):CoercedRestrictive = not NotCoercedRestrictive_4(k)elif (ncr is VARIANTS_RECEIVED_FROM_CBI_ID):CoercedRestrictive = not CBIvariantLowValidity(VARIANTS_RECEIVED_FROM_CBI_ID, k)else:CoercedRestrictive = Falsereturn CoercedRestrictive#@CoercedPermissive_1\uff0c\u5f3a\u5236\u5141\u8bb8\u8f93\u51651%def CoercedPermissive_1 (k):CoercedPermissive_1 = Offline.GetCoercedPermissive_1(k)return CoercedPermissive_1#@CoercedPermissive_2\uff0c\u5f3a\u5236\u5141\u8bb8\u8f93\u51652%def CoercedPermissive_2(k):CoercedPermissive_2 = Offline.GetCoercedPermissive_2(k)return CoercedPermissive_2#@CoercedPermissive_3\uff0c\u5f3a\u5236\u5141\u8bb8\u8f93\u51653%def CoercedPermissive_3(k):CoercedPermissive_3 = Offline.GetCoercedPermissive_3(k)return CoercedPermissive_3#@CoercedPermissive_4\uff0c\u5f3a\u5236\u5141\u8bb8\u8f93\u51654%def CoercedPermissive_4(k):CoercedPermissive_4 = Offline.GetCoercedPermissive_4(k)return CoercedPermissive_4#@CoercedPermissive\uff0c\u8fd4\u56de\u91c7\u96c6\u5230\u7684\u201c\u5f3a\u5236\u5141\u8bb8\u201d\u7ed3\u679c%def CoercedPermissive(cr, k):if (cr is COERCED_PERMISSIVE_1):CoercedPermissive = CoercedPermissive_1(k)elif (cr is COERCED_PERMISSIVE_2):CoercedPermissive = CoercedPermissive_2(k)elif (cr is COERCED_PERMISSIVE_3):CoercedPermissive = CoercedPermissive_3(k)elif (cr is COERCED_PERMISSIVE_4):CoercedPermissive = CoercedPermissive_4(k)elif (cr is VARIANTS_OVERLAP_PERMISSIVE):CoercedPermissive = OverlapTimerPermissive(k)else:CoercedPermissive = False#@TSRreportReceived\uff0c\u6536\u5230TSR\u6d88\u606f%def TSRreportReceived(lcId, k):return Message.Received(TSRdownloadContent(lcId), k)#@TSRreportAvailable\uff0cTSR\u6d88\u606f\u53ef\u7528%def TSRreportAvailable(lcId, k):return Message.Available(TSRreportReceived(lcId, k),TSRdownloadContent.CcLoopHour,ATPsetting.TSRvalidityTime,LastTSRreportAge(lcId, k-1),k)#@LastTSRreportAge\uff0c\u8bb0\u5f55\u5f53\u524d\u4f7f\u7528\u7684TSR\u6d88\u606f\u5df2\u7ecf\u8fc7\u4e86\u591a\u957f\u65f6\u95f4\u3002%def LastTSRreportAge(lcId, k):return Message.LastAge(TSRreportAvailable(lcId, k),TSRdownloadContent.CcLoopHour,LastTSRreportAge(lcId, k-1),k)#@ReceivedTSRdatabase\uff0c\u5c06LC\u53d1\u9001\u7684TSR\u6d88\u606f\u62a5\u6587\u6620\u5c04\u5230BLOCK\u6570\u7ec4\u4e2d\u3002\u5bf9\u4e8e\u7ebf\u8def\u4e0a\u7684\u6bcf\u4e2aBLOCK\uff0c\u5224\u65ad\u5176\u662f\u5426\u6709\u5bf9\u5e94\u7684TSR\uff0c\u82e5\u6709\uff0c\u5219\u66f4\u65b0\u5176\u9996\u672b\u70b9\u5750\u6807\u548c\u9650\u901f\u503c\uff0c\u5176\u4e2d\u9700\u5c06TSR\u6d88\u606f\u4e2d\u7684\u5750\u6807\u548c\u901f\u5ea6\u5355\u4f4d\u8f6c\u5316\u4e3aATP\u8f6f\u4ef6\u4f7f\u7528\u7684\u5750\u6807\u548c\u901f\u5ea6\u5355\u4f4d\u3002", "en": "ATP shall map the TSR message received from LC to structure of block. It need to judge whether there is corresponding TSR for each BLOCK in the track map. If yes, ATP shall update the abscissa of the starting and ending points, as well as the restriction speed. During the process, it need to transfer the abscissa and speed unit of TSR message to the corresponding one used in ATP.", "code": "def ReceivedTSRdatabase(lc, k):    if (Initialization        or (Message.Exists(DateSynchronizationReport(lc), k)            and Message.Exists(VersionAuthorization(lc), k)            and not Message.Exists(TSRdownloadContent(lc), k))        or (not Message.IsMoreRecent(ReceivedTSRdatabase(lc, k-1).ValidityTime, ATPtime(k))            and not TSRreportAvailable(k))):            SetAllBlockAsDefaultTsr    elif (TSRreportAvailable(lc, k)):        NewValidity = 0        if (Message.ReplyLocalCC(TSRdownloadContent(lc).CcLoopHour)):            NewValidity = (TSRdownloadContent(lc).CcLoopHour + ATPsetting.TSRvalidityTime)        else:            NewValidity = (ATPtime(k) + ATPsetting.TSRvalidityTime                            - (OtherATPmaxTime(k) - TSRdownloadContent(lc).CcLoopHour))        ReceivedTSRdatabase.ValidityTime = NewValidity        for tsr in range(0, TSRdownloadContent(lc).NumberOfTsr):            SetTsrInFirstBlock            SetTsrInLastBlock            for blk in range(TSRdownloadContent(lc).Tsr[tsr].FirstBlockId + 1,                              TSRdownloadContent(lc).Tsr[tsr].LastBlockId):                SetTsrInIntermediateBlock    else:        ReceivedTSRdatabase = ReceivedTSRdatabase(lc, k-1)    return ReceivedTSRdatabase"}, {"cn": "TrainEnergy\uff0c\u8ba1\u7b97EB\u65bd\u52a0\u65f6\u523b\u7684\u5217\u8f66\u52a8\u80fd\uff0c\u4f5c\u4e3a\u80fd\u91cf\u76d1\u63a7\u4f7f\u7528\u7684\u5217\u8f66\u80fd\u91cf\u3002", "en": "ATP shall calculate the train energy where EB indeed applied. The calculation shall consider the kinetic energy and the error of the potential energy. The ATPsetting.MPauthAltitudeMaxErrorEnergy means an algorithm error caused by offline tool to calculate the compensation gradients.", "code": "TrainEnergy = V2EbApplied * V2EbApplied               + ATPsetting.MPauthAltitudeMaxErrorEnergy"}, {"cn": "ZoneVSLNotExceedTrainSpeedLimit\uff0cATP\u5e94\u59cb\u7ec8\u5c06\u9879\u76ee\u914d\u7f6e\u7684\u9650\u901f\u503c\u4e3aATPsetting.MPauthLimitSpeed\u4f5c\u4e3a\u5b89\u5168\u901f\u5ea6\u9650\u5236\u533a\u57df\u3002\u9650\u5236\u533a\u80fd\u91cf%def ZoneVSLNotExceedTrainSpeedLimit(k):return (TrainEnergy(k) < pow(ATPsetting.MPauthLimitSpeed))#@ZoneVSLnotExceedPSR\uff0cPSR\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62\uff0cATP\u5e94\u5c06\u4ee5\u4e0b\u4e24\u79cd\u7c7b\u578b\u7684PSR\u4f5cF\u4e3a\u9650\u5236\u533a\u57df\u8fdb\u884c\u76d1\u63a7\uff1a\u8be5PSR\u662f\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u4e0a\u6e38\u7684\u7b2c\u4e00\u4e2aPSR\uff08\u5373\u4ece\u8be5PSR\u6240\u5728\u4f4d\u7f6e\u5230\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u4e4b\u95f4\u6ca1\u6709\u5176\u4ed6PSR\uff09\uff0c\u5982Figure 518\u4e2d\u7684PSR2\uff1b\u8be5PSR\u4f4d\u4e8e\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u4e0b\u6e38\u5230EB\u5b9e\u9645\u4f4d\u7f6e\u4e4b\u95f4\uff0c\u5982Figure 518\u4e2d\u7684PSR2,PSR3\u548cPSR4\u3002%def ZoneVSLnotExceedPSR(k):for Psr in TrackMap.AllSingsBtwTwoLocs(SGL_PSR,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k))):if (TrainEnergy(k) >= pow(Psr.SpeedLimit)and (not TrackMap.LocationBtwTwoLocs(Psr.Location,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrainRearLocation(k).Min)or (TrackMap.ExistSingBtwTwoLocs(SGL_PSR, Psr.Location,TrainRearLocation(k).Min) is None))):return Falseelse:continuereturn True#@PointVSLnotExceedPSR\uff0cPSR\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62\u3002\u5176\u4e2d\uff0cEnergy.AccumulationPotentialEnergy\u8868\u793a\u6839\u636e\u9650\u5236\u70b9\u6240\u5728\u5761\u5ea6\u6216EB\u6700\u5c0f\u4fdd\u969c\u7387\u7d2f\u52a0\u8ba1\u7b97\u76ee\u6807\u4f4d\u7f6e\u7684\u52bf\u80fd\uff0cEB\u6700\u5c0f\u4fdd\u969c\u7387\u5e94\u6839\u636e\u6240\u5728\u4f4d\u7f6e\u7684Grip\u503c\uff08Normal\u6216Reduce\uff09\u9009\u53d6ATPsetting.EBguaranteedAccNormalGrip\u6216ATPsetting.EBguaranteedAccReducedGrip\u3002\u80fd\u91cf\u8ba1\u7b97\u7684\u539f\u7406\u548c\u65b9\u6cd5\u89c1[REF10]\u3002\u5f53\u8f66\u5c3e\u5728\u4e00\u4e2a\u8f83\u4f4e\u7684PSR\uff08\u6216TSR\uff09\u4e2d\u65f6\uff0c\u82e5\u5f53\u524d\u8f66\u901f\u5c0f\u4e8e\u8be5PSR\u9650\u901f\uff0c\u800c\u8ba1\u7b97\u51fa\u7684V2\u901f\u5ea6\u5927\u4e8e\u8be5PSR\u9650\u901f\uff0c\u6309\u7167\u4e0a\u8ff0\u5904\u7406\u65b9\u5f0f\uff0c\u4e5f\u4f1a\u5bfc\u81f4EB\uff0c\u5c3d\u7ba1\u5f53\u5217\u8f66\u8fd0\u884c\u5230X2\u4f4d\u7f6e\u65f6\uff0c\u5217\u8f66\u4e5f\u8bb8\u5df2\u7ecf\u79bb\u5f00\u4e86\u8be5PSR\u533a\u57df\u3002", "en": "If the train tail intersected with a PSR (or TSR) area, and the speed of train is lower but the V2EbApplied is higher than the limitation. In accordance with the above approach will result in EB, although when the train runs to the EB applied position, the train may have left the PSR area.", "code": "def PointVSLnotExceedPSR(k):    for Psr in (TrackMap.AllSingsInZone(SGL_PSR,                                TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),                                ATPsetting.EOAmaxDistance)):        if (TrainEnergy(k) >= (pow(Psr.SpeedLimit)                                   + (Energy.AccumulationPotentialEnergy                                       (TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,                                                                           X2EbApplied(k)),                                        Psr.Location)))):            return False         else:            continue    return True"}, {"cn": "ZoneVSLnotExceedBSR\uff0c\u8f66\u8eab\u8303\u56f4\u5185\u6709BSR\u7684\u60c5\u5f62%def ZoneVSLnotExceedBSR(k):for Block in (TrackMap.AllSingsBtwTwoLocs(SGL_NEW_BLOCK,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):if (Block.Bsr is not Noneand not CoercedPermissive(Block.CoercedPermissive, k)and not VariantValue(Block.Bsr.Variant, k)and TrainEnergy(k) >= pow(Block.Bsr.Speed)):return Falseelse:continuereturn True#@PointVSLnotExceedBSR\uff0c\u5217\u8f66\u4e0b\u6e38\u6709BSR\u7684\u60c5\u5f62%def PointVSLnotExceedBSR(k):for Block in (TrackMap.AllSingsInZone(SGL_NEW_BLOCK,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance)):if (Block.Bsr is not Noneand not CoercedPermissive(Block.Bsr.CoercedPermissive, k)and not VariantValue(Block.Bsr.Variant, k)and TrainEnergy(k) >= (pow(Block.Bsr.Speed)+ (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),Block.Bsr.Position)))):return Falseelse:continueelse:return True#@TSRcontrolInhibition\uff0c\u4e0d\u5904\u7406TSR\u4fe1\u606f\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "According to the status of TSRcontrollinhibition, ATP can judge whether it is necessary to handle TSR information.", "code": "def TSRcontrolInhibition(k):    return Offline.GetTSRcontrolInhibition(k)"}, {"cn": "ZoneVSLnotExceedTSR\uff0cTSR\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62\u3002\u5373\u5bf9\u4e8e\u4ece\u8f66\u5c3e\u6240\u5728Block\u8d77\u59cb\u70b9\u5230EB\u65bd\u52a0\u4f4d\u7f6e\u5185\u7684\u6240\u6709Block\uff0c\u5f53\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\u65f6\uff0c\u8ba4\u4e3a\u5217\u8f66\u8d85\u8fc7\u4e86TSR\u9650\u901f\uff1a\u672a\u7981\u6b62\u5904\u7406TSR\u4fe1\u606f\uff1b\u4e14\u8be5Block\u5b58\u5728TSR\uff1b\u4e14\u5217\u8f66\u5b9a\u4f4d\u4e0e\u8be5TSR\u533a\u57df\u6709\u4ea4\u96c6\uff1b\u4e14\u8ba1\u7b97\u7684\u5217\u8f66\u80fd\u91cf\u5927\u4e8e\u4e0a\u8ff0TSR\u7684\u9650\u5236\u80fd\u91cf\u3002\u5176\u4e2dTSRonBlock\u8868\u793a\u83b7\u53d6\u6307\u5b9aBlock\u4e0aTSR\u7684\u503c\u3002%def ZoneVSLnotExceedTSR(k):for Blk in (TrackMap.AllSingsBtwTwoLocs(SGL_NEW_BLOCK,TrackMap.BlockOrigin(TrainRearLocation(k).Min)TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):Tsr = TSRonBlock(Blk, TrackMap.OppositeOrientation(TrainFrontOrientation(k)), k)if (not TSRcontrolInhibition(k)and Tsr is not Noneand not TrackMap.LocationBtwTwoLocs(Tsr.Position,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrainRearLocation(k).Min)and TrainEnergy(k) >= pow(Tsr.Value)):return Falseelse:continuereturn Truedef TSRonBlock(blockId, direction, k):if (not ReceivedTSRdatabase.Blocks[blockId].NotRestrictionApplication):if (direction is UP):return (ReceivedTSRdatabase.Blocks[blockId].Position[0],ReceivedTSRdatabase.Blocks[blockId].Value)else:return (ReceivedTSRdatabase.Blocks[blockId].Position[1],ReceivedTSRdatabase.Blocks[blockId].Value)else:return None#@PointVSLnotExceedTSR\uff0cTSR\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedTSR(k):for Blk in (TrackMap.AllSingsInZone(SGL_NEW_BLOCK,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance)):Tsr = TSRonBlock(Blk, TrainFrontOrientation(k), k)if (not TSRcontrolInhibition(k)and Tsr is not Noneand TrainEnergy(k) >= (pow(Tsr.Value)+ (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),Tsr.Position)))):return Falseelse:continueelse:return True#@ZoneVSLnotExceedOTE\uff0cOpen track end\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62%def ZoneVSLnotExceedOTE(k):if (TrackMap.ExistSingularityInZone(SGL_OPEN_TRACK_END, TrainFrontLocation(k).Max,X2EbApplied(k)) is not None)):return Falseelse:return True#@PointVSLnotExceedOTE\uff0cOpen track end\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedOTE(k):Ote = (TrackMap.ExistSingularityInZone(SGL_OPEN_TRACK_END,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance)if (Ote is not None)and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),Ote.Location))):return Falseelse:return True#@ZoneVSLnotExceedCTE\uff0cClose track end\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62%def ZoneVSLnotExceedCTE(k):cte = (TrackMap.ExistSingularityInZone(SGL_CLOSE_TRACK_END, TrainFrontLocation(k).Max,X2EbApplied(k)))if (cte is not Noneand TrainEnergy(k) >= pow(cte.SpeedLimit)):return Falseelse:return True#@PointVSLnotExceedCTE\uff0cClose track end\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedCTE(k):cte = (TrackMap.ExistSingularityInZone(SGL_CLOSE_TRACK_END,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance))if (cte is not Noneand TrainEnergy(k) >= (pow(cte.SpeedLimit)+ (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),cte.Location)))):return Falseelse:return True#@ZoneVSLnotExceedSignal\uff0c\u4fe1\u53f7\u673a\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62%def ZoneVSLnotExceedSignal(k):for Sig in TrackMap.AllSingsInZone(SGL_SIGNAL, TrainFrontLocation(k).Max, X2EbApplied(k)):if ((CoercedRestrictive(Sig.NotCoercedRestrictive, k)or not VariantValue(Sig.Variant, k))and (not CoercedPermissive(Sig.CoercedPermissive, k)and not VariantValue(Sig.OverlapVariant, k))):return Falseelse:continueelse:return True#@PointVSLnotExceedSignal\uff0c\u4fe1\u53f7\u673a\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedSignal(k):for Sig in TrackMap.AllSingsInZone(SGL_SIGNAL,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance)):if ((CoercedRestrictive(Sig.NotCoercedRestrictive, k)or not VariantValue(Sig.Variant, k))and (not CoercedPermissive(Sig.CoercedPermissive, k)and not VariantValue(Sig.OverlapVariant, k))):and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),Sig.Location))):return Falseelse:continueelse:return True#@ZoneVSLnotExceedOverlap\uff0cOverlap\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62%def ZoneVSLnotExceedOverlap(k):for Overlap in TrackMap.AllSingsInZone(SGL_OVERLAP_END, TrainFrontLocation(k).Max,X2EbApplied(k)):Signal = TrackMap.ExistSingBtwTwoLocs(SGL_SIGNAL, TrainFrontLocation(k).Max,Overlap.Location)if (Signal is not Noneand (CoercedRestrictive(Signal.NotCoercedRestrictive, k)or not VariantValue(Signal.Variant, k))and (CoercedPermissive(Signal.CoercedPermissive, k)or VariantValue(Overlap.Variant, k))):return Falseelse:continuereturn True#@PointVSLnotExceedOverlap\uff0cOverlap\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedOverlap(k):for Overlap in (TrackMap.AllSingsInZone(SGL_OVERLAP_END,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance)):Signal = (TrackMap.ExistSingBtwTwoLocs(SGL_SIGNAL,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),Overlap.Location))if (Signal is not Noneand (CoercedRestrictive(Signal.NotCoercedRestrictive, k)or not VariantValue(Signal.Variant, k))and (CoercedPermissive(Signal.CoercedPermissive, k)or VariantValue(Overlap.Variant, k))and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),Overlap.Location))):return Falseelse:continuereturn True#@ZoneVSLnotExceedSwitch\uff0c\u975e\u53d7\u63a7\u9053\u5c94\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62%def ZoneVSLnotExceedSwitch(k):for Switch in TrackMap.AllSwitchesInZone(TrainFrontLocation(k).Max, X2EbApplied(k)):if (VariantValue(Switch.Variant1, k) == VariantValue(Switch.Variant2, k)):return Falseelse:continuereturn True#@PointVSLnotExceedSwitch\uff0c\u975e\u53d7\u63a7\u9053\u5c94\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedSwitch(k):for Switch in (TrackMap.AllSwitchesInZone(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance)):if (VariantValue(Switch.Variant1, k) == VariantValue(Switch.Variant2, k)and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),Switch.Location))):return Falseelse:continuereturn True#@ZoneVSLnotExceedPZ\uff0cPZ\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u3002ATP\u5e94\u76d1\u63a7\u4e0e\u5217\u8f66\u5b9a\u4f4d\u6709\u4ee5\u4e0b\u4e24\u79cd\u5173\u7cfb\u7684\u9650\u5236\u72b6\u6001\u4fdd\u62a4\u533a\uff1a\u8be5\u4fdd\u62a4\u533a\u7684\u8d77\u59cb\u70b9\u5728\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u5230\u7d27\u6025\u5236\u52a8\u65bd\u52a0\u4f4d\u7f6e\u4e4b\u95f4\uff1b\u6216\uff0c\u8be5\u4fdd\u62a4\u533a\u8d77\u59cb\u70b9\u5728\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u4e0a\u6e38\uff0c\u4f46\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u5728\u8be5\u4fdd\u62a4\u533a\u8303\u56f4\u5185\u3002%def ZoneVSLnotExceedPZ(k):for Pz in (TrackMap.AllSingsInZone(SGL_PROTECTION_ZONE,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):if ((not TrackMap.LocationBtwTwoLocs(Pz.Location,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrainRearLocation(k).Min)or TrackMap.LocationInZone(TrainRearLocation(k).Min, Pz.Location, Pz.Length))and not CoercedPermissive(Pz.CoercedPermissive, k)and (CoercedRestrictive(Pz.NotCoercedRestrictive, k)or not VariantValue(Pz.Variant, k))):return Falseelse:continuereturn True#@PointVSLnotExceedPZ\uff0cPZ\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedPZ(k):for Pz in (TrackMap.AllSingsInZone(SGL_PROTECTION_ZONE,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance)):if (not CoercedPermissive(Pz.CoercedPermissive, k)and (CoercedRestrictive(Pz.NotCoercedRestrictive, k)or not VariantValue(Pz.Variant, k))and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),Pz.Location))):return Falseelse:continuereturn True#@ZoneVSLnotExceedPSD\uff0cPSD\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u3002ATP\u5e94\u76d1\u63a7\u4e0e\u5217\u8f66\u5b9a\u4f4d\u6709\u4ee5\u4e0b\u4e24\u79cd\u5173\u7cfb\u7684\u9650\u5236\u72b6\u6001\u5c4f\u853d\u95e8\u533a\u57df\uff1a\u8be5\u5c4f\u853d\u95e8\u533a\u7684\u8d77\u59cb\u70b9\u5728\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u5230\u7d27\u6025\u5236\u52a8\u65bd\u52a0\u4f4d\u7f6e\u4e4b\u95f4\uff1b\u6216\uff0c\u8be5\u5c4f\u853d\u95e8\u533a\u8d77\u59cb\u70b9\u5728\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u4e0a\u6e38\uff0c\u4f46\u8f66\u5c3e\u6700\u5c0f\u5b9a\u4f4d\u5728\u8be5\u5c4f\u853d\u95e8\u533a\u8303\u56f4\u4e4b\u5185\u3002%def ZoneVSLnotExceedPSD(k):for Psd in (TrackMap.AllSingsBtwTwoLocs(SGL_PSD_ZONE,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):if ((not TrackMap.LocationBtwTwoLocs(Psd.Location,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrainRearLocation(k).Min)or TrackMap.LocationInZone(TrainRearLocation(k).Min, Psd.Location, Psd.Length))and not CoercedPermissive(Psd.CoercedPermissive, k)and (CoercedRestrictive(Psd.NotCoercedRestrictive, k)or not VariantValue(Psd.Variant, k))):return Falseelse:continuereturn True#@PointVSLnotExceedPSD\uff0cPSD\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedPSD(k):for Psd in (TrackMap.AllSingsInZone(SGL_PSD_ZONE,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k) ),ATPsetting.EOAmaxDistance)):if (not CoercedPermissive(Psd.CoercedPermissive, k)and (CoercedRestrictive(Psd.NotCoercedRestrictive, k)or not VariantValue(Psd.Variant, k))and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),Psd.Location))):return Falseelse:continuereturn True#@ZoneVSLnotExceedZC\uff0c\u975e\u6388\u6743ZC\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62%def ZoneVSLnotExceedZC(k):for block in (TrackMap.AllSingsBtwTwoLocs(SGL_NEW_BLOCK, TrainRearLocation(k).Min,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)))):if (not BlockModeUsed(k)and not VersionAuthorizedByLC(TrackMap.ZCId(block.Id), k)):return Falseelse:continuereturn True#@PointVSLnotExceedZC\uff0c\u975e\u6388\u6743ZC\u8fb9\u754c\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedZC(k):for NewBlock in (TrackMap.AllSingsInZone(SGL_NEW_BLOCK,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k)),ATPsetting.EOAmaxDistance)):if (not BlockModeUsed(k)and not VersionAuthorizedByLC(TrackMap.ZCId(NewBlock.Id), k)and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),NewBlock.Location))):return Falseelse:continuereturn True#@ZoneVSLnotExceedEOA\uff0cCBTC\u4e0bEOA\u4f5c\u4e3a\u533a\u57df\u578b\u9650\u901f\u7684\u60c5\u5f62%def ZoneVSLnotExceedEOA(k):if (CBTCmodeEOAvalid(k)and (TrackMap.LocationBtwTwoLocs(CBTCmodeEOAlocation(k),TrainFrontLocation(k).Min,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k))))):return Falseelse:return True#@PointVSLnotExceedEOA\uff0cCBTC\u4e0bEOA\u4f5c\u4e3a\u70b9\u578b\u9650\u901f\u7684\u60c5\u5f62%def PointVSLnotExceedEOA(k):if (CBTCmodeEOAvalid(k)and not (TrackMap.LocationBtwTwoLocs(CBTCmodeEOAlocation(k),TrainFrontLocation(k).Min,TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max, X2EbApplied(k))))and TrainEnergy(k) >= (Energy.AccumulationPotentialEnergy(TrackMap.CalculateZoneBorder(TrainFrontEnd(k).Max,X2EbApplied(k)),CBTCmodeEOAlocation(k)))):return Falseelse:return True#@ZoneVSLNotExceed\uff0c\u5224\u65ad\u6709\u65e0\u9650\u5236\u533a\u57df\u8d85\u80fd\u3002", "en": "ATP shall determine whether train exceeds the vital speed limitation of the restrictive zone, by comparing the energy between the energy of the train and the energy of the zone.", "code": " def ZoneVSLNotExceed(k):    return (EndOfAuthorityValid(k)            and ZoneVSLNotExceedTrainSpeedLimit(k)            and ZoneVSLnotExceedPSR(k)            and ZoneVSLnotExceedBSR(k)            and ZoneVSLnotExceedTSR(k)            and ZoneVSLnotExceedOTE(k)            and ZoneVSLnotExceedCTE(k)            and ZoneVSLnotExceedSignal(k)            and ZoneVSLnotExceedOverlap(k)            and ZoneVSLnotExceedSwitch(k)            and ZoneVSLnotExceedPZ(k)            and ZoneVSLnotExceedPSD(k)            and ZoneVSLnotExceedZC(k)            and ZoneVSLnotExceedEOA(k))"}, {"cn": "PointVSLNotExceed\uff0c\u5224\u65ad\u6709\u65e0\u9650\u5236\u70b9\u8d85\u80fd\u3002", "en": "ATP shall determine whether train exceeds the vital speed limitation of the restrictive point,  by comparing the energy between the energy of the train and the kinetic added potential energy of the point.", "code": "def PointVSLNotExceed(k):    return (EndOfAuthorityValid(k)            and PointVSLnotExceedPSR(k)            and PointVSLnotExceedBSR(k)            and PointVSLnotExceedTSR(k)            and PointVSLnotExceedOTE(k)            and PointVSLnotExceedCTE(k)            and PointVSLnotExceedSignal(k)            and PointVSLnotExceedOverlap(k)            and PointVSLnotExceedSwitch(k)            and PointVSLnotExceedPZ(k)            and PointVSLnotExceedPSD(k)            and PointVSLnotExceedZC(k)            and PointVSLnotExceedEOA(k))"}, {"cn": "MotionProtectionInhibition\uff0c\u8868\u793aATP\u4e0d\u8d1f\u8d23\u5217\u8f66\u4f4d\u7f6e\u7684\u76d1\u63a7\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002%def MotionProtectionInhibition(k):return Offline.GetMotionProtectionInhibition(k)#@TrainPossiblyInOverEnergy\uff0c\u5217\u8f66\u80fd\u91cf\u5927\u4e8e\u9650\u5236\u70b9\u6216\u9650\u5236\u533a\u80fd\u91cf\uff0c\u5373\u8d85\u80fd\u3002", "en": "If the train energy exceeds the zone of point vital speed limitation, ATP shall consider the train possibly over energy.", "code": "def TrainPossiblyInOverEnergy(k):    return (not ZoneVSLNotExceed(k)        or not PointVSLNotExceed(k))"}, {"cn": "TrainEnergyControlDisabled\uff0c\u5728RM\u6a21\u5f0f\u4e0b\u4e0d\u62a5\u8d85\u80fd\u3002", "en": "If the RMF or RMR mode selected, ATP shall not monitor the train energy.", "code": "def TrainEnergyControlDisabled(k):    return MotionProtectionInhibition(k)"}, {"cn": "EBforOverEnergy\uff0c\u8d85\u80fd\u540e\u662f\u5426\u8f93\u51faEB", "en": "ATP shall request emergency braking if train is possibly in over-energy and train speed control enabled and if following conditions fulfilled:the train is not detected at filtered stop,or the train is detected at filtered stop and: safe immobilization customization setting for this control indicates to use emergency brake\uff0cor safe immobilization customization setting for this control indicates to use emergency brake when it was already applied.", "code": "def EBforOverEnergy(k):    return (TrainPossiblyInOverEnergy(k)            and not TrainEnergyControlDisabled(k)            and (not TrainFilteredStopped(k)                 or (TrainFilteredStopped(k)                     and (ATPsetting.MPauthImmoBehaviourAtFS                          is IB_APPLY_EMERGENCY_BRAKE)                     or ((ATPsetting.MPauthImmoBehaviourAtFS                          is IB_APPLY_EMERGENCY_BRAKE_WHEN_TRIGGERED)                         and not InhibitEmergencyBrake(k-1)))))"}, {"cn": "PBforOverEnergy\uff0c\u8d85\u80fd\u505c\u8f66\u540e\u662f\u5426\u7ee7\u7eed\u8f93\u51faPB", "en": "ATP shall request parking braking if train is possibly in over-energy and train speed control enabled and if following conditions fulfilled:the train is detected at filtered stop,and safe immobilization customization setting for this control indicates to use parking brake.", "code": "def PBforOverEnergy(k):    return (TrainPossiblyInOverEnergy(k)            and not TrainEnergyControlDisabled            and (TrainFilteredStopped(k)                 and (ATPsetting.MPauthImmoBehaviourAtFS is IB_APPLY_PARKING_BRAKE))) "}, {"cn": "NotOnRestrictiveMoralTimeArea_1\uff0c\u5f53\u5217\u8f66\u5b9a\u4f4d\u65f6\uff0cATP\u9700\u5224\u65adEND_1\u7aef\u8f66\u5934\u7684\u5185\u5916\u4fa7 \u5b9a\u4f4d\u662f\u5426\u4e0e\u8be5\u7aef\u8f66\u5934\u671d\u5411\u7684\u201c\u9650\u5236\u72b6\u6001\u201d\u4fe1\u53f7\u673a\u4e0b\u6e38\u7684\u6a21\u7cca\u65f6\u95f4\u533a\u6709\u65e0\u4ea4\u96c6\u3002\u5176\u4e2d\u6a21\u7cca\u65f6\u95f4\u533a\u5b9a\u4e49\u4e3a\u4fe1\u53f7\u673a\u4e0b\u6e38\u957f\u5ea6\u4e3aATPsetting.MTdistance\u7684\u4e00\u6bb5\u8303\u56f4\u3002\u5f53\u6ee1\u8db3\u4e0b\u5217\u6240\u6709\u6761\u4ef6\u65f6\uff0c\u8bbe\u7f6eNotOnRestrictiveMoralTimeArea_1\u4e3aTrue\uff1a\u5217\u8f66\u5df2\u786e\u8ba4\u5b9a\u4f4d\uff1b\u5e76\u4e14\uff1aEND_1\u7aef\u8f66\u5934\u7684\u5185\u5916\u4fa7\u5b9a\u4f4d\u4e0eEND_1\u7aef\u8f66\u5934\u671d\u5411\u7684\u4fe1\u53f7\u673a\u4e0b\u6e38\u6a21\u7cca\u533a\u6ca1\u6709\u4ea4\u96c6\uff1b\u6216\u8005\uff0cEND_1\u7aef\u8f66\u5934\u7684\u5185\u5916\u4fa7\u5b9a\u4f4d\u4e0eEND_1\u7aef\u8f66\u5934\u671d\u5411\u7684\u4fe1\u53f7\u673a\u4e0b\u6e38\u6a21\u7cca\u533a\u6709\u4ea4\u96c6\uff0c\u4f46\u8be5\u4fe1\u53f7\u673a\u662f\u5141\u8bb8\u72b6\u6001\u3002\u5426\u5219\uff0c\u5e94\u8bbe\u7f6eNotOnRestrictiveMoralTimeArea_1\u4e3aFalse\u3002%def NotOnRestrictiveMoralTimeArea_1(k):Signal = TrackMap.ExistSingularityInReverseZone(SGL_SIGNAL,TrainLocation.Ext1,ATPsetting.MTdistance + TrainLocation(k).Uncertainty)return (TrainLocatedOnKnownPath(k)and (Signal is Noneor not Signal.BmMoralTimeor VariantValue(Signal.Variant, k)))#@NotOnRestrictiveMoralTimeArea_2\uff0c\u5f53\u5217\u8f66\u5b9a\u4f4d\u65f6\uff0cATP\u9700\u5224\u65adEND_2\u7aef\u8f66\u5934\u7684\u5185\u5916\u4fa7\u5b9a\u4f4d\u662f\u5426\u4e0e\u8be5\u7aef\u8f66\u5934\u671d\u5411\u7684\u201c\u9650\u5236\u72b6\u6001\u201d\u4fe1\u53f7\u673a\u4e0b\u6e38\u7684\u6a21\u7cca\u65f6\u95f4\u533a\u6709\u65e0\u4ea4\u96c6\u3002\u5f53\u6ee1\u8db3\u4e0b\u5217\u6240\u6709\u6761\u4ef6\u65f6\uff0c\u8bbe\u7f6eNotOnRestrictiveMoralTimeArea_2\u4e3aTrue\uff1a\u5217\u8f66\u5df2\u786e\u8ba4\u5b9a\u4f4d\uff1b\u5e76\u4e14\uff1aEND_2\u7aef\u8f66\u5934\u7684\u5185\u5916\u4fa7\u5b9a\u4f4d\u4e0eEND_2\u7aef\u8f66\u5934\u671d\u5411\u7684\u4fe1\u53f7\u673a\u4e0b\u6e38\u6a21\u7cca\u533a\u6ca1\u6709\u4ea4\u96c6\uff1b\u6216\u8005\uff0cEND_2\u7aef\u8f66\u5934\u7684\u5185\u5916\u4fa7\u5b9a\u4f4d\u4e0eEND_2\u7aef\u8f66\u5934\u671d\u5411\u7684\u4fe1\u53f7\u673a\u4e0b\u6e38\u6a21\u7cca\u533a\u6709\u4ea4\u96c6\uff0c\u4f46\u8be5\u4fe1\u53f7\u673a\u662f\u5141\u8bb8\u72b6\u6001\u3002\u5426\u5219\uff0c\u5e94\u8bbe\u7f6eNotOnRestrictiveMoralTimeArea_2\u4e3aFalse\u3002%def NotOnRestrictiveMoralTimeArea_2(k):Signal = TrackMap.ExistSingularityInReverseZone(SGL_SIGNAL,TrainLocation.Ext2,ATPsetting.MTdistance + TrainLocation(k).Uncertainty)return (TrainLocatedOnKnownPath(k)and (Signal is Noneor not Signal.BmMoralTimeor VariantValue(Signal.Variant, k)))#@RouteExclusivityGuaranted_1\uff0c\u5982\u679c\u5217\u8f66\u5728\u8f66\u59341\u5bf9\u5e94\u65b9\u5411\u4e14\u9650\u5236\u72b6\u6001\u7684\u6a21\u7cca\u65f6\u95f4\u533a\u5185\u8d85\u8fc7\u9879\u76ee\u8bbe\u5b9a\u65f6\u95f4\uff0c\u5219ATP\u5e94\u5c06\u8be5\u503c\u8bbe\u4e3a\u9650\u5236\u72b6\u6001\u3002\u5176\u4e2dMoralTimeTimer_1\u4e3a\u8bb0\u5f55\u5217\u8f66\u5728\u8f66\u59341\u5bf9\u5e94\u65b9\u5411\u7684\u9650\u5236\u72b6\u6001\u6a21\u7cca\u65f6\u95f4\u533a\u5185\u7684\u65f6\u95f4\u3002", "en": "If ATP cannot determine train is NotOnRestrictiveMoralTimeArea_1, and if this situation lasts more than ATPsetting. MTtimeout cycles, ATP shall consider that route exclusivity is not guaranteed and RouteExclusivityGuaranted_1 shall be set to False. If ATP detects that train is NotOnRestrictiveMoralTimeArea_1, route exclusivity shall consider as guaranteed for that direction of travel and RouteExclusivityGuaranted_1 shall set to True", "code": "def RouteExclusivityGuaranted_1(k):    if (Initialization):        RouteExclusivityGuaranted_1 = False    elif (RouteExclusivityGuaranted_1(k-1)          and not NotOnRestrictiveMoralTimeArea_1(k)):        if (MoralTimeTimer_1(k-1) < round.floor(ATPsetting.MTtimeout)):            MoralTimeTimer_1 = MoralTimeTimer_1(k-1) + 1        else:            RouteExclusivityGuaranted_1 = False    elif (NotOnRestrictiveMoralTimeArea_1(k)):        MoralTimeTimer_1 = 1        RouteExclusivityGuaranted_1 = True    else:        RouteExclusivityGuaranted_1 = RouteExclusivityGuaranted_1(k-1)    return RouteExclusivityGuaranted_1"}, {"cn": "RouteExclusivityGuaranted_2\uff0c\u5982\u679c\u5217\u8f66\u5728\u8f66\u59342\u5bf9\u5e94\u65b9\u5411\u4e14\u9650\u5236\u72b6\u6001\u7684\u6a21\u7cca\u65f6\u95f4\u533a\u5185\u8d85\u8fc7\u9879\u76ee\u8bbe\u5b9a\u65f6\u95f4\uff0c\u5219ATP\u5e94\u5c06\u8be5\u503c\u8bbe\u7f6e\u4e3a\u9650\u5236\u72b6\u6001\uff0c\u5176\u4e2dMoralTimeTimer_2\u4e3a\u8bb0\u5f55\u5217\u8f66\u5728\u8f66\u59342\u5bf9\u5e94\u65b9\u5411\u9650\u5236\u72b6\u6001\u6a21\u7cca\u65f6\u95f4\u533a\u5185\u7684\u65f6\u95f4\u3002", "en": "If ATP cannot determine train is NotOnRestrictiveMoralTimeArea_2, and if this situation lasts more than ATPsetting.MTtimeout cycles, ATP shall consider that route exclusivity is not guaranteed and RouteExclusivityGuaranted_2 shall set to False. If ATP detects that train is NotOnRestrictiveMoralTimeArea_2, route exclusivity shall consider as guaranteed for that direction of travel and RouteExclusivityGuaranted_2 shall set to True", "code": "def RouteExclusivityGuaranted_2(k):    if (Initialization):        RouteExclusivityGuaranted_2 = False    elif (RouteExclusivityGuaranted 2(k-1)          and not NotOnRestrictiveMoralTimeArea_2(k)):        if (MoralTimeTimer_2(k-1) < round.floor(ATPsetting.MTtimeout)):            MoralTimeTimer_2 = MoralTimeTimer_2(k-1) + 1        else:            RouteExclusivityGuaranted_2 = False    elif (NotOnRestrictiveMoralTimeArea_2(k)):        MoralTimeTimer_2 = 1        RouteExclusivityGuaranted_2 = True    else:        RouteExclusivityGuaranted_2 = RouteExclusivityGuaranted_2(k-1)    return RouteExclusivityGuaranted_2"}, {"cn": "HazardousMotionOnNonExclusiveRoute\uff0c\u975eRM\u7684BM\u6a21\u5f0f\u4e0b\uff0c\u5982\u679c\u5217\u8f66\u5728\u6fc0\u6d3b\u7aef\u8f66\u5934\u65b9\u5411\u7684\u9650\u5236\u72b6\u6001\u7684Moral Time\u533a\u505c\u6b62\u8d85\u65f6\u9884\u8bbe\u65f6\u95f4\uff0c\u5219ATP\u8ba4\u4e3a\u5f53\u524d\u5904\u4e8e\u201c\u975e\u72ec\u5360\u8fdb\u8def\u201d\u7684\u98ce\u9669\u4e4b\u4e2d\u3002", "en": "If RouteExclusivityGuaranted_1 is False, ATP shall request emergency braking if and only if:TrainFrontEnd is not END_2,RM forward nor RM reverse are not selected,and block mode is not selected. If RouteExclusivityGuaranted_2 is False, ATP shall request emergency braking if and only if:TrainFrontEnd is not END_1,RM forward nor RM reverse driving mode are not selected,and block mode is not selected.", "code": "def HazardousMotionOnNonExclusiveRoute(k):    return (((not RouteExclusivityGuaranted_1(k) and (TrainFrontEnd(k)!= END_2))             or (not RouteExclusivityGuaranted_2(k) and (TrainFrontEnd(k)!= END_1)))            and not MotionProtectionInhibition(k)            and BlockModeUsed(k)) "}, {"cn": "PBonNonExclusiveRoute\uff0c\u5f53\u7531\u4e8eMoralTime\u76d1\u63a7\u5bfc\u81f4\u7684\u505c\u8f66\u540e\uff0c\u662f\u5426\u4fdd\u6301\u8f93\u51fa\u505c\u8f66\u5236\u52a8\u7684\u53d6\u51b3\u4e8e\u9879\u76ee\u914d\u7f6e\u3002", "en": "ATP shall request parking braking if train considered too near from a non-exclusive route and if following conditions are fulfilled:the train is detected at filtered stop,safe immobilization customization setting for this control indicates to use parking brake.", "code": "PBonNonExclusiveRoute(k)= HazardousMotionOnNonExclusiveRoute(k) and TrainFilteredStopped(k) and (ATPsetting.MTimmoBehaviourAtFS == IB_APPLY_PARKING_BRAKE)"}, {"cn": "EBonNonExclusiveRoute\uff0c\u5982\u679c\u5f53\u524d\u5904\u4e8e\u201c\u975e\u72ec\u5360\u8fdb\u8def\u201d\u7684\u98ce\u9669\u4e2d\uff0c\u4e14\u5217\u8f66\u5728\u79fb\u52a8\uff0c\u5219ATP\u5e94\u5f53\u8f93\u51faEB\uff1b\u5982\u679c\u5f53\u524d\u5df2\u505c\u8f66\uff0c\u5219\u662f\u5426\u7ee7\u7eed\u8f93\u51faEB\u53d6\u51b3\u4e8e\u9879\u76ee\u914d\u7f6e\u3002", "en": "ATP shall request emergency braking if train considered too near from a non-exclusive route and if following conditions are fulfilled:the train is not detected at filtered stop,or the train is detected at filtered stop and:safe immobilization customization setting for this control indicates to use emergency brake,or safe immobilization customization setting for this control indicates to use emergency brake when it was already applied.", "code": "EBonNonExclusiveRoute(k)= \uff08HazardousMotionOnNonExclusiveRoute(k)    and (not TrainFilteredStopped(k)         or (TrainFilteredStopped(k)              and ((ATPsetting.MTimmoBehaviourAtFS == IB_APPLY_EMERGENCY_BRAKE)                 or ((ATPsetting.MTimmoBehaviourAtFS == IB_APPLY_EMERGENCY_BRAKE_WHEN_TRIGGERED)                      and not InhibitEmergencyBrake(k-1))))))"}, {"cn": "PermissiveZoneLogicalInput\uff0c\u5141\u8bb8\u533a\u903b\u8f91\u8f93\u5165\u3002\u5176\u4e2d\uff0c\u5217\u8f66\u5b9a\u4f4d\u5b8c\u5168\u5305\u542b\u5728vital zone\u4e2d\u7684\u6761\u4ef6\u5982\u4e0b\uff1a%def PermissiveZoneLogicalInput(PzType, k):return (TrainLocatedOnKnownPath(k)and IncludedInVitalZone(PzType, k))def IncludedInVitalZone(PzType, k):for Vz in (TrackMap.AllSingsBtwTwoLocs(SGL_VITAL_ZONE,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrainFrontLocation(k).Max)):if (Vz.PermissiveZoneLogicalInput is PzTypeand TrackMap.LocationInZone(TrainFrontLocation(k).Max,Vz.Location,Vz.Length,Vz.Orientation)and TrackMap.LocationInZone(TrainRearLocation(k).Min,Vz.Location,Vz.Length,Vz.Orientation)and (Vz.Variant is Noneor (VariantValue(Vz.Variant, k)))):return Trueelse:continuereturn False#@NotRestrictiveZoneLogicalInput\uff0c\u975e\u9650\u5236\u533a\u903b\u8f91\u8f93\u5165\u3002\u5176\u4e2d\uff0c\u5217\u8f66\u4e0evital zone\u6ca1\u6709\u4ea4\u96c6\u7684\u5224\u522b\u6761\u4ef6\u5982\u4e0b\uff1a%def NotRestrictiveZoneLogicalInput(NrzType, k):return (TrainLocatedOnKnownPath(k)and NotIntersectVitalZone(NrzType, k))def NotIntersectVitalZone(NrzType, k):for Vz in (TrackMap.AllSingsBtwTwoLocs(SGL_VITAL_ZONE,TrackMap.BlockOrigin(TrainRearLocation(k).Min),TrainFrontLocation(k).Max)):if (Vz.NotRestrictiveZoneLogicalInput is NrzTypeand (TrackMap.IntersectionOfTwoZones(TrainRearLocation(k).Min,TrainFrontLocation(k).Max,vz.Location,TrackMap.CalculateZoneBorder(vz.Location, vz.Length))is not None)and (Vz.Variant is Noneor not VariantValue(Vz.Variant, k))):return Falseelse:continuereturn True#@NoUndetectableDanger_1\uff0c\u5df2\u76d1\u63a7\u5411END_1\u65b9\u5411\u7684\u8fd0\u884c\uff0c\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "The No Undetectable Danger in Extremity 1 shall be consider as permissive status according to project configuration.", "code": "def NoUndetectableDanger_1(k):    return Offline.NoUndetectableDanger_1(k)"}, {"cn": "NoUndetectableDanger_2\uff0c\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "The \"No Undetectable Danger in Extremity 2\" shall be consider as permissive status according to project configuration.", "code": "def NoUndetectableDanger_2(k):    return Offline.NoUndetectableDanger_2(k) "}, {"cn": "UndetectableDangerRiskForNoNUDE\uff0c\u5f53\u524d\u4e24\u7aef\u8f66\u5934\u90fd\u6ca1\u6709NUDE\u8f93\u5165\uff0c\u5219\u8ba4\u4e3a\u5217\u8f66\u5b58\u5728\u201c\u65e0\u6cd5\u4fa6\u6d4b\u7684\u98ce\u9669\u201d\u3002", "en": "If there is neither No Undetectable Danger in Extremity 1 nor No Undetectable Danger in Extremity 2 inputs, ATP shall consider the train is possible under the risk of undetectable danger.", "code": "def UndetectableDangerRiskForNoNUDE(k):    return (not NoUndetectableDanger_1(k)             and not NoUndetectableDanger_2(k))"}, {"cn": "PBforUndetectableDangerRisk\uff0c\u5f53\u505c\u8f66\u4e14\u5b58\u5728\u201c\u65e0\u6cd5\u4fa6\u6d4b\u7684\u98ce\u9669\u201d\u65f6\uff0c\u5982\u679c\u9879\u76ee\u914d\u7f6e\u4e3a\u8f93\u51fa\u505c\u8f66\u5236\u52a8\uff0c\u5219ATP\u5e94\u5f53\u8f93\u51fa\u505c\u8f66\u5236\u52a8\u3002", "en": "ATP shall request a parking braking if the possibility of an undetected danger has proven to be and if following conditions are fulfilled:the train is detected at filtered stop,safe immobilization customization setting for this control indicates to use parking brake.", "code": "PBforUndetectableDangerRisk(k) = (UndetectableDangerRiskForNoNUDE(k)    and TrainFilteredStopped(k)    and (ATPsetting.NUDEimmoBehaviourAtFS == IB_APPLY_PARKING_BRAKE))"}, {"cn": "NUDEdistanceAccount_1\uff0c\u76d1\u63a7\u5f53\u53f8\u673a\u672a\u6388\u6743\u5411END_1\u65b9\u5411\u8fd0\u884c\u65f6\uff0c\u5217\u8f66\u5411END_1\u65b9\u5411\u8fd0\u884c\u7684\u8ddd\u79bb\uff0c\u8be5\u503c\u4e3a\u975e\u8d1f\u6570\uff0c\u82e5\u5728\u521d\u59cb\u5316\u9636\u6bb5\uff0c\u6216NUDE1\u4e3aTrue\uff0c\u6216\u5df2\u7ecfEB\u5e76\u505c\u8f66\uff0c\u5219\u7b49\u4e8e0\uff1b\u5426\u5219\uff0c\u5f53\u6d4b\u901f\u65e0\u6548\u65f6\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u503c; \u5426\u5219\uff0c\u5f53\u91cc\u7a0b\u8ba1\u5df2\u521d\u59cb\u5316\u540e\uff1a\u5982\u679cMaximumTrainMotion\u5927\u4e8e0\uff0c\u5219\u7b49\u4e8e\u4e0a\u5468\u671f\u7d2f\u52a0\u8ddd\u79bb\u52a0\u4e0a\u672c\u5468\u671f\u6700\u5927\u4f4d\u79fb\uff0c\u6700\u5c0f\u53d60\u3002\u800c\u5982\u679cMaximumTrainMotion\u5c0f\u4e8e\u7b49\u4e8e0\uff0c\u5219\u4f7f\u7528\u4e0a\u5468\u671f\u503c\u52a0\u6700\u5c0f\u4f4d\u79fb\uff08\u5b9e\u9645\u4e0a\u5c31\u662f\u51cf\u5c0f\u8be5\u7d2f\u52a0\u503c\uff0c\u5012\u8f66\uff09\uff0c\u6700\u5c0f\u53d60\u3002\u5426\u5219\uff0c\u4fdd\u6301\u7d2f\u52a0\u8ddd\u79bb\u4e0d\u53d8\u3002", "en": "When the driver does not authorize the train running toward the END_1, ATP shall accumulate the distance of the train running toward to the END_1.If in initialization, or the NoUndetectableDanger_1 is True, or the train has triggered EB and has stopped, ATP set this distance to 0;Else if train kinematic has invalid, ATP set this distance to the default value.Else if the odometer has initialized:If the MaximumTrainMotionis greater than 0, ATP accumulate the maximum movement in this cycle with the distance of last cycle;Or if the MaximumTrainMotionis less than or equal to 0, ATP use the minimum movement of this cycle plus to the distance last cycle (in fact, decrease the accumulated distance). The minimum of this accumulated distance is 0.Otherwise, keep the distance unchanged.", "code": "def NUDEdistanceAccount_1(k):        if (INTIALIZATION         or NoUndetectableDanger_1(k)         or (EBappliedForMotionWithoutNUDE(k-1) and TrainFilteredStopped(k)))        return 0    elif (ValidTrainKinematic(k) != True)        return ATPsetting.NUDEdistanceWithoutMotionAvailable    elif (OdometerState(k) is INITIALIZED)        if (End1RunningForward(k))             return max(0, NUDEdistanceAccount_1(k-1)+ MaximumTrainMotion(k))        else:             return max(0, NUDEdistanceAccount_1(k-1)+ MinimumTrainMotion(k))    else:        return  NUDEdistanceAccount_1(k-1)"}, {"cn": "NUDEdistanceAccount_2\uff0c\u76d1\u63a7\u5f53\u53f8\u673a\u672a\u6388\u6743\u5411END_2\u65b9\u5411\u8fd0\u884c\u65f6\uff0c\u5217\u8f66\u5411END_2\u65b9\u5411\u8fd0\u884c\u7684\u8ddd\u79bb\uff0c\u8be5\u503c\u4e3a\u975e\u6b63\u6570\uff0c\u82e5\u5728\u521d\u59cb\u5316\u9636\u6bb5\uff0c\u6216NUDE2\u4e3aTrue\uff0c\u6216\u5df2\u7ecfEB\u5e76\u505c\u8f66\uff0c\u5219\u7b49\u4e8e0\uff1b\u5426\u5219\uff0c\u5f53\u6d4b\u901f\u65e0\u6548\u65f6\uff0c\u5c06\u5176\u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u503c\uff1b\u5426\u5219\uff0c\u5f53\u91cc\u7a0b\u8ba1\u5df2\u7ecf\u521d\u59cb\u5316\u540e\uff1a\u82e5 MaximumTrainMotion\u5c0f\u4e8e0\uff0c\u5219\u7b49\u4e8e\u4e0a\u5468\u671f\u7d2f\u52a0\u8ddd\u79bb\u52a0\u4e0a\u672c\u5468\u671f\u6700\u5927\u4f4d\u79fb\uff0c\u6700\u5927\u53d60\u3002\u82e5MaximumTrainMotion\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u4f7f\u7528\u4e0a\u5468\u671f\u503c\u52a0\u6700\u5c0f\u4f4d\u79fb\uff0c\u6700\u5927\u53d60\u3002\u5426\u5219\uff0c\u4fdd\u6301\u7d2f\u52a0\u8ddd\u79bb\u4e0d\u53d8\u3002", "en": "When the driver does not authorize the train running toward the END_2, ATP shall accumulate the distance of the train running toward to the END_2.If in initialization, or the NoUndetectableDanger_2 is True, or the train has triggered EB and has stopped, ATP set this distance to 0;Else if train kinematic has invalid, ATP set this distance to the default value.Else if the odometer has initialized:if the MaximumTrainMotion is less than 0, ATP accumulate the maximum movement in this cycle with the distance of last cycle;Else: if the MaximumTrainMotion is greater than or equal to 0, ATP use the minimum movement of this cycle plus to the distance last cycle (in fact, decrease the accumulated distance). The minimum of this accumulated distance is 0.Otherwise, keep the distance unchanged.", "code": "def NUDEdistanceAccount_2(k):    if (INTIALIZATION         or NoUndetectableDanger_2(k)         or (EBappliedForMotionWithoutNUDE(k-1) and TrainFilteredStopped(k)))        return 0    elif (ValidTrainKinematic(k) != True)        return -1 * ATPsetting.NUDEdistanceWithoutMotionAvailable(k)    elif (OdometerState(k) is INITIALIZED)        if (End2RunningForward(k))             return min(0, NUDEdistanceAccount_2(k-1)+ MaximumTrainMotion(k))        else:             return min(0, NUDEdistanceAccount_2(k-1)+ MinimumTrainMotion(k))    else:        return NUDEdistanceAccount_2(k-1)"}, {"cn": "UndetectDangerMotionWithoutNUDE\uff0c\u5217\u8f66\u8fd0\u884c\u8d85\u8fc7\u9650\u5b9a\u8ddd\u79bb\uff0c\u4f46\u4ecd\u6709\u8f66\u5934\u672a\u68c0\u6d4b\u5230NUDE\u3002", "en": "When the train has moved without NUDE more than project-restricted distance, ATP shall set this value to True.", "code": "UndetectDangerMotionWithoutNUDE(k) = (not NoUndetectableDanger_1(k)       and (NUDEdistanceAccount_1(k)> ATPsetting.NUDElimitDistance))    or (not NoUndetectableDanger_2(k)         and (NUDEdistanceAccount_2(k)< -1 * ATPsetting.NUDElimitDistance)))"}, {"cn": "EBappliedForMotionWithoutNUDE\uff0c\u4fdd\u8bc1\u7531NUDE\u5bfc\u81f4\u7684EB\u4f1a\u5ef6\u8fdf\u4e00\u6bb5\u65f6\u95f4\u3002\u5373\uff1a\u5f53UndetectDangerMotionWithoutNUDE\u4e3aTrue\u65f6\uff0c\u8bbe\u7f6eEBappliedForMotionWithoutNUDE\u4e3aTrue\uff1b\u5f53UndetectDangerMotionWithoutNUDE\u7531True\u53d8\u4e3aFalse\u540e\uff0c\u8fd8\u9700\u4fdd\u6301EBappliedForMotionWithoutNUDE \u5728ATPsetting.NUDEtrainStopDurationBeforeEBrelease\u65f6\u95f4\u5185\u4e3aTrue\uff1b\u8d85\u8fc7\u4e0a\u8ff0\u65f6\u95f4\u540e\uff0c\u8be5\u503c\u4e3aFalse\u3002", "en": "The EB request shall be maintained to True during the application time ATPsetting.NUDEtrainStopDurationBeforeEBrelease, if the train has moved without NUDE more than project restricted distance. When?UndetectDangerMotionWithoutNUDE is?True,?ATP shall set?EBappliedForMotionWithoutNUDE?to?True;When?UndetectDangerMotionWithoutNUDE change from?True?to False,  ATP shallmaintain?EBappliedForMotionWithoutNUDE?to True in period ATPsetting.NUDEtrainStopDurationBeforeEBrelease\uff1bOver?the?time,?set this value to?False.", "code": "def EBappliedForMotionWithoutNUDE(k):    if (UndetectDangerMotionWithoutNUDE(k)):        NudeEBreleaseCounter = 0        return True    elif (NudeEBreleaseCounter < ATPsettings.NUDEtrainStopDurationBeforeEBrelease):        NudeEBreleaseCounter = NudeEBreleaseCounter(k-1) + 1        return True    else:        return False"}, {"cn": "EBforUndetectableDangerRisk\uff0c\u7531\u201c\u65e0\u6cd5\u4fa6\u6d4b\u7684\u5371\u9669\u201d\u5bfc\u81f4EB\u5e76\u505c\u8f66\u540e\uff0cATP\u5e94\u5f53\u6839\u636e\u9879\u76ee\u914d\u7f6e\u5224\u65ad\u662f\u5426\u8f93\u51faEB\u3002", "en": "When the train has triggered emergency brake causing by the \"undetectable danger risk\" and has stopped, ATP shall determine whether keeping the EB output according to the project configuration.", "code": "EBforUndetectableDangerRisk(k) = (EBappliedForMotionWithoutNUDE(k)   or (UndetectableDangerRiskForNoNUDE(k)       and (not TrainFilteredStopped(k)            or (ATPsetting.NUDEimmoBehaviourAtFS == IB_APPLY_EMERGENCY_BRAKE)            or ((ATPsetting.NUDEimmoBehaviourAtFS == IB_APPLY_EMERGENCY_BRAKE_WHEN_TRIGGERED)                  and (not InhibitEmergencyBrake(k-1))))))"}, {"cn": "ConditionForRMlimitSpeed\uff0c\u5f53\u524d\u5e94\u7528\u54ea\u79cdRM\u9650\u901f\u3002ATP\u6700\u591a\u652f\u6301\u9879\u76ee\u914d\u7f6eMAX_RM_CONDITION_NB\u79cdRM\u9650\u901f\u3002%def ConditionForRMlimitSpeed(i, k):return Offline.GetConditionForRMlimitSpeed(i, k)#@RMlimitSpeedApplied\uff0c\u6839\u636e\u5217\u8f66\u8f93\u5165\uff0c\u5224\u65ad\u5f53\u524d\u5e94\u5f53\u76d1\u63a7\u7684RM\u9650\u901f%def RMlimitSpeedApplied(k):for i in range(0, MAX_RM_CONDITION_NB):if (ConditionForRMlimitSpeed(i, k)):return ATPsetting.MPinhibitionLimitSpeed[i]else:continuereturn 0#@NoDangerForRMoverSpeed\uff0c\u5217\u8f66\u901f\u5ea6\u5c0f\u4e8e\u7b49\u4e8eRM\u6a21\u5f0f\u4e0b\u7684\u9650\u901f\u3002", "en": "ATP estimates that current train maximum speed not exceeds the RM limit speed.", "code": "def NoDangerForRMoverSpeed(k):    return (ValidTrainKinematic(k)            and TrainMaxSpeed(k) <= RMlimitSpeedApplied(k)) "}, {"cn": "EBforRMoverSpeed\uff0c\u82e5\u5728RM\u6a21\u5f0f\u4e0b\uff0c\u5217\u8f66\u901f\u5ea6\u5927\u4e8eRM\u6a21\u5f0f\u9650\u901f\uff0c\u5219\u5c06\u8f93\u51faEB\u3002%def EBforRMoverSpeed(k):return (not NoDangerforRMoverSpeed(k)and MotionProtectionInhibition(k))#@NoDangerForMemorizedLocationOverSpeed\uff0c\u5728\u4f7f\u7528\u8bb0\u5fc6\u5b9a\u4f4d\u800c\u8fd8\u672a\u8bfb\u5230\u786e\u8ba4\u4fe1\u6807\u65f6\uff0cATP\u76d1\u63a7\u5217\u8f66\u901f\u5ea6\u662f\u5426\u8d85\u8fc7\u9879\u76ee\u9650\u5236\u503c\u3002%def NoDangerForMemorizedLocationOverSpeed(k):return (not MemLocationNotConfirmed(k)or TrainMaxSpeed < ATPsetting.MemLocLimitSpeed)#@EBforMemorizedLocationOverSpeed\uff0c\u5728\u4f7f\u7528\u8bb0\u5fc6\u5b9a\u4f4d\u800c\u8fd8\u672a\u8bfb\u5230\u786e\u8ba4\u4fe1\u6807\u65f6\uff0cATP\u5e94\u786e\u4fdd\u5217\u8f66\u901f\u5ea6\u4e0d\u8d85\u8fc7\u9879\u76ee\u9650\u5236\u503c\u3002%def EBforMemorizedLocationOverSpeed(k):return (not NoDangerforMemorizedLocationOverSpeed(k)and not MotionProtectionInhibition(k))#@RMRselectedDrivingMode\uff0c\u662f\u5426\u9009\u62e9\u4e86RMR\u5012\u8f66\u6a21\u5f0f\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "RMRselectedDrivingMode represents the choice of RMR.", "code": "def RMRselectedDrivingMode(k):    return Offline.GetRMRselectedDrivingMode(k)"}, {"cn": "RollbackDistanceAccount_1\uff0c\u7d2f\u8ba1\u56de\u6e9c\u7684\u8ddd\u79bb\uff08\u8d1f\u503c\u8868\u793a\u5728\u56de\u6e9c\uff09\uff1a\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u8be5\u503c\u4e3a0\uff1b\u5426\u5219\uff0c\u5982\u679c\u5217\u8f66\u8fd0\u52a8\u5b66\u65e0\u6548\uff0c\u5219\u8bbe\u7f6e\u4e3a\u914d\u7f6e\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\uff1b\u5426\u5219\uff0c\u5728END_1\u6fc0\u6d3b\u4e14\u672a\u9009\u62e9RMR\u6a21\u5f0f\u7684\u524d\u63d0\u4e0b\uff1a\u82e5\u91cc\u7a0b\u8ba1\u5df2\u521d\u59cb\u5316\uff0c\u4e14\u5217\u8f66\u5411END_1\u65b9\u5411\u8fd0\u884c\uff0c\u5219\u7d2f\u52a0\u6700\u5c0f\u4f4d\u79fb\uff0c\u82e5\u8d85\u8fc70\u5219\u53d60\uff0c\u5426\u5219\u662f\u4e00\u4e2a\u8d1f\u503c\u3002\u5426\u5219\uff0c\u82e5\u91cc\u7a0b\u8ba1\u9f7f\u6570\u9f7f\u53f7\u5339\u914d\uff0c\u5219\u7d2f\u52a0\u5217\u8f66\u6700\u5927\u4f4d\u79fb; \u5426\u5219\uff0c\u5373\u91cc\u7a0b\u8ba1\u672a\u521d\u59cb\u5316\uff0c\u5219\u4fdd\u6301\u7d2f\u8ba1\u8ddd\u79bb\u4e0d\u53d8\u3002\u5176\u4ed6\u60c5\u51b5\uff0c\u4fdd\u6301\u7d2f\u8ba1\u8ddd\u79bb\u4e0d\u53d8\u3002", "en": "When train front extremity is END_1 and traction effort is supposed to be in the direction of travel, RollbackDistanceAccount_1 is the estimated maximum distance which separates current front extremity 1 position to last most forward position reached by this extremity. ATP shall evaluate RollbackDistanceAccount_1 in order to control that speed does not exceed ATPsetting.MPnotAuthLimitSpeed .", "code": "def RollbackDistanceAccount_1(k):    if (Initialization)        return 0    elif (not ValidTrainKinematic(k)):        return (-1 * ATPsetting.MPnotAuthDistWithoutMotionAvailable)    elif (TrainFrontEnd(k) is END_1           and not RMRselectedDrivingMode(k)):        if (OdometerState(k) is INITIALIZED):            if (End1RunningForward(k)):                return min(0, RollbackDistanceAccount_1(k-1) + MinimumTrainMotion(k))            else:                return (RollbackDistanceAccount_1(k-1) + MaximumTrainMotion(k))        else:            return RollbackDistanceAccount_1(k-1)    else:        return RollbackDistanceAccount_1(k-1)"}, {"cn": "RollbackDistanceAccount_2\uff0c\u7d2f\u8ba1\u56de\u6e9c\u7684\u8ddd\u79bb\uff08\u8d1f\u503c\u8868\u793a\u5728\u56de\u6e9c\uff09\uff1a\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u8be5\u503c\u4e3a0\uff1b\u5426\u5219\uff0c\u5982\u679c\u5217\u8f66\u8fd0\u52a8\u5b66\u65e0\u6548\uff0c\u5219\u8bbe\u7f6e\u4e3a\u914d\u7f6e\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\uff1b\u5426\u5219\uff0c\u5728END_2\u6fc0\u6d3b\u4e14\u672a\u9009\u62e9RMR\u6a21\u5f0f\u7684\u524d\u63d0\u4e0b\uff1a\u82e5\u91cc\u7a0b\u8ba1\u5df2\u521d\u59cb\u5316\uff0c\u4e14\u5217\u8f66\u5411END_2\u65b9\u5411\u8fd0\u884c\uff0c\u5219\u51cf\u53bb\u6700\u5c0f\u4f4d\u79fb\uff0c\u82e5\u8d85\u8fc70\u5219\u53d60\uff0c\u5426\u5219\u662f\u4e00\u4e2a\u8d1f\u503c\u3002\u5426\u5219\uff0c\u82e5\u91cc\u7a0b\u8ba1\u5df2\u521d\u59cb\u5316\uff0c\u5219\u51cf\u53bb\u5217\u8f66\u6700\u5927\u4f4d\u79fb;\u5426\u5219\uff0c\u5373\u91cc\u7a0b\u8ba1\u8fd8\u672a\u521d\u59cb\u5316\uff0c\u5219\u4fdd\u6301\u7d2f\u8ba1\u8ddd\u79bb\u4e0d\u53d8\u3002\u5176\u4ed6\u60c5\u51b5\uff0c\u4fdd\u6301\u7d2f\u8ba1\u8ddd\u79bb\u4e0d\u53d8\u3002", "en": "When train front extremity is END_2 and traction effort is supposed to be in the direction of travel, RollbackDistanceAccount_2 is the estimated maximum distance which separates current front extremity 2 position to last most forward position reached by this extremity. ATP shall evaluate RollbackDistanceAccount_2 in order to control that speed does not exceed ATPsetting.MPnotAuthLimitSpeed.", "code": "def RollbackDistanceAccount_2(k):    if (Initialization)        return 0    elif (not ValidTrainKinematic(k)):        return (-1 * ATPsetting.MPnotAuthDistWithoutMotionAvailable)    elif (TrainFrontEnd(k) is END_2           and not RMRselectedDrivingMode(k)):        if (OdometerState(k) is INITIALIZED):            if (End2RunningForward(k)):                return min(0, RollbackDistanceAccount_2(k-1) - MinimumTrainMotion(k))            else:                return (RollbackDistanceAccount_2(k-1) \u2014 MaximumTrainMotion(k))        else:            return RollbackDistanceAccount_2(k-1)    else:        return RollbackDistanceAccount_2(k-1)"}, {"cn": "UnrecoverableRollbackOverSpeed\uff0c\u5982\u679cATP\u68c0\u6d4b\u5230\u5217\u8f66\u5df2\u7ecf\u56de\u9000\u8d85\u8fc7\u9879\u76ee\u9650\u5236\u7684\u6700\u5927\u8ddd\u79bb\uff0c\u5219\u8bbe\u7f6e\u6c38\u4e45\u56de\u9000\u8d85\u901f", "en": "From ATP power-up, UnrecoverableRollbackOverSpeed shall initialize to False. UnrecoverableRollbackOverSpeed shall be set to True if and only if following conditions are fulfilled:driving selector indicates that traction effort is supposed to be in the direction of travel,train front extremity is END_2 or END_1,and rollback limit speed currently applicable is null for this direction of travel.Once UnrecoverableRollbackOverSpeed set as True, it shall stay at state True while ATP is not reboot.", "code": "def UnrecoverableRollbackOverSpeed(k):    return (UnrecoverableRollbackOverSpeed(k-1)            or (not RMRselectedDrivingMode(k)                and ((TrainFrontEnd(k) is END_2                      and (abs(RollbackDistanceAccount_2(k))                           >  ATPsetting.MPnotAuthLimitDistance))                     or (TrainFrontEnd(k) is END_1                         and (abs(RollbackDistanceAccount_1(k))                              >  ATPsetting.MPnotAuthLimitDistance))))) "}, {"cn": "RollbackOverSpeed\uff0c\u4e0b\u5217\u4efb\u4e00\u6761\u4ef6\u6ee1\u8db3\uff0c\u8ba4\u4e3a\u56de\u9000\u8d85\u901f\u82e5\u8f66\u59342\u6fc0\u6d3b\uff0c\u4f4d\u79fb\u4e3aEND_1\u65b9\u5411\uff0c\u672a\u9009\u62e9RMR\u6a21\u5f0f;\u8f66\u901f\u5927\u4e8e\u5f53\u524d\u56de\u9000\u8ddd\u79bb\u6240\u5728\u9650\u901f;\u82e5\u8f66\u59341\u6fc0\u6d3b\uff0c\u4f4d\u79fb\u4e3aEND_2\u65b9\u5411\uff0c\u672a\u9009\u62e9RMR\u6a21\u5f0f;\u8f66\u901f\u5927\u4e8e\u5f53\u524d\u56de\u9000\u8ddd\u79bb\u6240\u5728\u9650\u901f;\u5217\u8f66\u8fd0\u52a8\u5b66\u65e0\u6548;\u5df2\u53d1\u751f\u4e86\u6c38\u4e45\u56de\u9000\u8d85\u901f\u9519\u8bef", "en": "RollbackOverSpeed shall be True if and only if following conditions are fulfilled:driving selector indicates that traction effort is supposed to be in the direction of travel,train front extremity is END_2 or END_1,and movement observed is in the opposite direction of travel, and over-estimated train speed is greater than ATPsetting.MPnotAuthLimitSpeed currently applicable for this direction of travel and rollback speed restrictions is not null.Or: train has reached a position due a rollback movement which is unrecoverable,Or: train kinematic is invalid,", "code": "def RollbackOverSpeed(k):    return (not ValidTrainKinematic(k)            or UnrecoverableRollbackOverSpeed(k)            or (not RMRselectedDrivingMode(k)                and (TrainMaxSpeed(k) >= ATPsetting.MPnotAuthLimitSpeed                     and ((TrainFrontEnd(k) is END_2                            and End1RunningForward(k) and not End2RunningForward(k))                          or (TrainFrontEnd is END_1                            and End2RunningForward(k) and not End1RunningForward(k))))))"}, {"cn": "EBforRollbackOverSpeed\uff0c\u5982\u679cATP\u68c0\u6d4b\u5230\u56de\u6e9c\u8d85\u901f\uff0c\u5219\u8f93\u51faEB", "en": "ATP shall request emergency braking if a reverse speed limit is over-run for unwilling rollback or excessive reverse motion.", "code": "EBforRollbackOverSpeed = RollbackOverSpeed(k)"}, {"cn": "LongDistanceReverseAuthorized\uff0c\u957f\u8ddd\u79bb\u5012\u8f66\u6a21\u5f0f\u662f\u5426\u6388\u6743\uff0c\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "LongDistanceReverseAuthorized represents the authorization of long distance reverse.", "code": "def LongDistanceReverseAuthorized(k):    return Offline.GetLongDistanceReverseAuthorized(k)"}, {"cn": "ReverseDistanceAccount_1\uff0c\u7d2f\u52a0RMR\u6a21\u5f0f\u4e0b\u7684\u5012\u8f66\u8ddd\u79bb\uff08\u8d1f\u503c\u8868\u793a\u5012\u8f66\uff09\uff1a\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u8be5\u503c\u4e3a0\uff1b\u5426\u5219\uff0c\u5982\u679c\u5217\u8f66\u8fd0\u52a8\u5b66\u65e0\u6548\uff0c\u5219\u8bbe\u7f6e\u4e3a\u914d\u7f6e\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\uff1b\u5426\u5219\uff0c\u5728END_1\u6fc0\u6d3b\u4e14\u975e\u957f\u8ddd\u79bb\u5012\u8f66\u6388\u6743\u7684\u524d\u63d0\u4e0b\uff1a\u82e5\u91cc\u7a0b\u8ba1\u5df2\u521d\u59cb\u5316\uff0c\u4e14\u5217\u8f66\u5411END_1\u65b9\u5411\u8fd0\u884c\uff0c\u5219\u51cf\u5c0f\u5012\u8f66\u8ddd\u79bb\u7edd\u5bf9\u503c\uff0c\u5927\u4e8e\u96f6\u5219\u7b49\u4e8e0\u3002\u5426\u5219\uff0c\u5982\u679c\u91cc\u7a0b\u8ba1\u5df2\u521d\u59cb\u5316\uff0c\u4e14\u9009\u62e9RMR\u6a21\u5f0f\uff0c\u5219\u7d2f\u52a0\u5012\u8f66\u8ddd\u79bb\u3002\u5426\u5219\uff0c\u5373\u91cc\u7a0b\u8ba1\u8fd8\u672a\u521d\u59cb\u5316\uff0c\u5219\u4fdd\u6301\u8ddd\u79bb\u4e0d\u53d8\u3002\u5176\u4ed6\u60c5\u51b5\uff0c\u4fdd\u6301\u7d2f\u8ba1\u8ddd\u79bb\u4e0d\u53d8\u3002", "en": "When train front extremity is END_1 and traction effort is supposed to be in the opposite direction of travel, ReverseDistanceAccount_1 is the estimated maximum distance which separates current front extremity 1 position to last most forward position reached by this extremity. ATP shall evaluate ReverseDistanceAccount_1 in order to control that speed does not exceed reverse speed limit function.", "code": "def ReverseDistanceAccount_1(k):    if (Initialization)        return 0    elif (not ValidTrainKinematic(k)):        return ATPsetting.ReverseDistWithoutMotionAvailable    elif (TrainFrontEnd is END_1           and not LongDistanceReverseAuthorized(k)):        if (OdometerState(k) is INITIALIZED):            if (End1RunningForward(k)):                return min(0, ReverseDistanceAccount_1(k-1) + MinimumTrainMotion(k))            elif (RMRselectedDrivingMode(k)):                return (ReverseDistanceAccount_1(k-1) + MaximumTrainMotion(k))            else:                return ReverseDistanceAccount_1(k-1)        else:            return ReverseDistanceAccount_1(k-1)    else:        return ReverseDistanceAccount_1(k-1)"}, {"cn": "ReverseDistanceAccount_2\uff0c\u7d2f\u52a0RMR\u6a21\u5f0f\u4e0b\u7684\u5012\u8f66\u8ddd\u79bb\uff08\u8d1f\u503c\u8868\u793a\u5012\u8f66\uff09\uff1a\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u8be5\u503c\u4e3a0\uff1b\u5426\u5219\uff0c\u5982\u679c\u5217\u8f66\u8fd0\u52a8\u5b66\u65e0\u6548\uff0c\u5219\u8bbe\u7f6e\u4e3a\u914d\u7f6e\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\uff1b\u5426\u5219\uff0c\u5728END_2\u6fc0\u6d3b\u4e14\u975e\u957f\u8ddd\u79bb\u5012\u8f66\u6388\u6743\u7684\u524d\u63d0\u4e0b\uff1a\u5982\u679c\u91cc\u7a0b\u8ba1\u5df2\u521d\u59cb\u5316\uff0c\u4e14\u5217\u8f66\u5411END_2\u65b9\u5411\u8fd0\u884c\uff0c\u5219\u51cf\u5c0f\u5012\u8f66\u8ddd\u79bb\u7edd\u5bf9\u503c\uff0c\u5927\u4e8e\u96f6\u5219\u7b49\u4e8e0\u3002\u5426\u5219\uff0c\u5982\u679c\u91cc\u7a0b\u8ba1\u5df2\u521d\u59cb\u5316\uff0c\u4e14\u9009\u62e9RMR\u6a21\u5f0f\u65f6\u7d2f\u52a0\u5012\u8f66\u8ddd\u79bb\u3002\u5426\u5219\uff0c\u5373\u91cc\u7a0b\u8ba1\u672a\u521d\u59cb\u5316\uff0c\u5219\u4fdd\u6301\u8ddd\u79bb\u4e0d\u53d8\uff1b\u5176\u4ed6\u60c5\u51b5\uff0c\u4fdd\u6301\u7d2f\u8ba1\u8ddd\u79bb\u4e0d\u53d8\u3002", "en": "When train front extremity is END_2 and traction effort is supposed to be in the opposite direction of travel, ReverseDistanceAccount_2 is the estimated maximum distance which separates current front extremity 2 position to last most forward position reached by this extremity. ATP shall evaluate ReverseDistanceAccount_2 in order to control that speed does not exceed ReverseSpeedRestrictions reverse speed limit function.", "code": "def ReverseDistanceAccount_2(k):    if (Initialization)        return 0    elif (not ValidTrainKinematic(k)):        return ATPsetting.ReverseDistWithoutMotionAvailable    elif (TrainFrontEnd(k) is END_2           and not LongDistanceReverseAuthorized(k)):        if (OdometerState(k) is INITIALIZED):            if (End2RunningForward(k))                return min(0, ReverseDistanceAccount_2(k-1) - MinimumTrainMotion(k))            elif (RMRselectedDrivingMode(k)):                return (ReverseDistanceAccount_2(k-1) \u2014 MaximumTrainMotion(k))            else:                return ReverseDistanceAccount_2(k-1)        else:            return ReverseDistanceAccount_2(k-1)    else:        return ReverseDistanceAccount_2(k-1)"}, {"cn": "ReverseOverSpeed\uff0c\u8d85\u8fc7RMR\u6a21\u5f0f\u9650\u901f\u7684\u6761\u4ef6\uff1a", "en": "ReverseOverSpeed shall be True if following conditions fulfilled:driving selector indicates that traction effort is supposed to be in the opposite direction of travel,train front extremity is END_2 or END_1,and movement observed is the opposite direction of travel,and:over-estimated train speed is greater than reverse speed restrictions currently applicable for this direction of travel,or else: if reverse speed restrictions currently applicable is null for this direction of travel,Or else: train kinematic is invalid.", "code": "def ReverseOverSpeed(k):    if (not RMRselectedDrivingMode(k)         or LongDistanceReverseAuthorized(k)):        return False    elif (not ValidTrainKinematic(k)):        return True    else:        return ((TrainFrontEnd(k) is END_2):                   and ((End1RunningForward(k) and not End2RunningForward(k)                          and (TrainMaxSpeed(k)                                > ReverseSpeedRestrictions(ReverseDistanceAccount_2(k))))                        or (ReverseSpeedRestrictions(ReverseDistanceAccount_2(k)) == 0)))                  or (TrainFrontEnd(k) is END_1                       and ((End2RunningForward(k) and not End1RunningForward(k)                  and (TrainMaxSpeed(k) > ReverseSpeedRestrictions(ReverseDistanceAccount_1(k))))                             or (ReverseSpeedRestrictions(ReverseDistanceAccount_1(k)) == 0))))"}, {"cn": "EBforReverseOverSpeed\uff0c\u7531\u4e8eRMR\u4e0b\u5012\u8f66\u8d85\u901f\u800c\u5bfc\u81f4EB", "en": "ATP shall request emergency braking if a reverse speed limit is over-run for unwilling rollback or excessive reverse motion.", "code": "EBforReverseOverSpeed = ReverseOverSpeed(k)"}, {"cn": "TrainEmergencyBrakeApplied\uff0c\u5217\u8f66\u662f\u5426\u65bd\u52a0\u4e86\u7d27\u6025\u5236\u52a8\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "TrainEmergencyBrakeApplied shows that whether the train has applied emergency brake. If the project is not configured, ATP shall consider the emergency brake has not applied by the train. Otherwise, if either of the end is in emergency brake, ATP considers the emergency brake has applied.", "code": "def TrainEmergencyBrakeApplied(k):    return Offline.GetTrainEmergencyBrakeApplied(k)"}, {"cn": "TrainParkingBrakeApplied\uff0c\u4efb\u4e00\u7aef\u8f66\u5934\u5df2\u65bd\u52a0\u505c\u8f66\u5236\u52a8\uff0c\u5219\u8ba4\u4e3a\u505c\u8f66\u5236\u52a8\u5df2\u65bd\u52a0\u3002\u5176\u72b6\u6001\u6765\u81ea\u4e8e\u9879\u76ee\u53ef\u914d\u7f6e\u7684\u5217\u8f66\u8f93\u5165\u91c7\u96c6\u3002", "en": "The term TrainParkingBrakeApplied stands for that either of the train ends is in parking brake.", "code": "def TrainParkingBrakeApplied(k):    return Offline.GetTrainParkingBrakeApplied(k)"}, {"cn": "TrainSafelyImmobilised\uff0c\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u5b89\u5168\u505c\u8f66", "en": "ATP shall consider that train safely immobilized if:Train brake has detected safely applied, or train parking brake is detected;And train is detected at filtered stop.", "code": "def TrainSafelyImmobilised(k):    return ((TrainEmergencyBrakeApplied(k)             or TrainParkingBrakeApplied(k))            and TrainFilteredStopped(k))"}, {"cn": "NoVitalCorrectlyDocked\uff0cCCNV\u5224\u65ad\u5217\u8f66\u662f\u5426\u505c\u5728\u5f00\u95e8\u6388\u6743\u533a\u5185%def NoVitalCorrectlyDocked(k):return (ATOcontrolTimeValid(k)and NonVitalRequest(k).TrainInCorrectlyDockedZone)#@LocalATPenableDoorOpening_A\uff0c\u672cATP\u662f\u5426\u5728\u7ad9\u5185\u5141\u8bb8\u5f00A\u4fa7\u8f66\u95e8\uff1a", "en": "ATP shall determine whether train doors on side A opening. The rules are following:", "code": "def LocalATPenableDoorOpening_A(k):    return (TrainLocatedOnKnownPath(k)            and TrainIncludedInVPEZ_A(k)            and NoVitalCorrectlyDocked(k)            and TrainSafelyImmobilised(k))"}, {"cn": "LocalATPenableDoorOpening_B\uff0c\u672cATP\u662f\u5426\u6388\u6743\u5f00\u542fB\u4fa7\u8f66\u95e8\uff1a", "en": "ATP shall determine whether train doors on side B opening. The rules are following:", "code": "def LocalATPenableDoorOpening_B(k):    return (TrainLocatedOnKnownPath(k)            and TrainIncludedInVPEZ_B(k)            and NoVitalCorrectlyDocked(k)            and TrainSafelyImmobilised(k))"}, {"cn": "EnableDoorOpening_A\uff0c\u7ed3\u5408\u8fdc\u7aefATP\u7ed3\u679c\u7684\u5f00\u95e8\u6388\u6743\u4fe1\u606f\u3002%def EnableDoorOpening_A(k):return (LocalATPenableDoorOpening_A(k)or OtherATP.EnableDoorOpening_A)#@EnableDoorOpening_B\uff0c\u7ed3\u5408\u8fdc\u7aefATP\u7ed3\u679c\u7684\u5f00\u95e8\u6388\u6743\u4fe1\u606f\u3002%def EnableDoorOpening_B(k):return (LocalATPenableDoorOpening_B(k)or OtherATP(k).EnableDoorOpening_B)#@PSDoperation_A\u548cPSDoperation_B\uff0c\u5176\u7ed3\u6784\u4e3aST_PSD_OPERATION\uff0c\u7528\u4e8e\u83b7\u53d6\u6765\u81eaCCNV\u7684\u5c4f\u853d\u95e8\u63a7\u5236\u6307\u4ee4\u3002", "en": "PSDoperation_A and PSDoperation_B structured as ST_PSD_OPERATION, used to obtain the PSD controlling order from CCNV.", "code": "if (ATOcontrolTimeValid(k) == True)    PSDoperation_A(k)= NonVitalRequest.PSDoperation_A(k)    PSDoperation_B(k)= NonVitalRequest.PSDoperation_B(k)else:    PSDoperation_A(k).Id = None    PSDoperation_B(k).Id = None"}, {"cn": "CommunicateWithPSD\uff0cATP\u6839\u636eCCNV\u7684\u8bf7\u6c42\uff0c\u5224\u65ad\u662f\u5426\u4e0e\u8054\u9501\u5efa\u7acb\u901a\u4fe1\u3002\u5f53\u672c\u5468\u671f\u6765\u81eaCCNV\u7684PSDoperation_A\u6216PSDoperation_B\u4e0d\u5168\u4e3aNone\u65f6\uff0c\u8bbe\u7f6eCommunicateWithPSD\u4e3aTrue\uff1b\u5426\u5219\uff0c\u8bbe\u7f6eCommunicateWithPSD\u4e3aFalse\u3002", "en": "ATP shall determine whether to establish communication with the correlative CI according to request from CCNV:When there is at least one id of PSDoperation_A or PSDoperation_B is not none, ATP shall set CommunicatedWithPSD to True:Otherwise, set CommunicatedWithPSD to False.", "code": "def CommunicateWithPSD(k):    return (PSDoperation_A(k).Id is not None            or PSDoperation_B(k).Id is not None)"}, {"cn": "UsingPSDstatusFromCI\uff0c\u53ea\u6709\u5f53\u5217\u8f66\u5b9a\u4f4d\u4e0ePSD\u533a\u57df\u6709\u4ea4\u96c6\uff0c\u4e14\u5217\u8f66\u9759\u6b62\u6216\u521a\u53d1\u8f66\u65f6\uff0cATP\u4f7f\u7528\u6765\u81eaCI\u7684PSD\u72b6\u6001\u4fe1\u606f\u3002", "en": "Only when the train fulfilled the following conditions, ATP shall use the PSD status from the CI:The train location intersects with a PSD zone;And the train is filtered stopped or just started moving.", "code": "UsingPSDstatusFromCI = ((AlignPSDzone_A(k) or AlignPSDzone_B(k))                             and (TrainFilteredStopped(k)                                   or (TrainFilteredStopped(k-1)                                        and not TrainFilteredStopped(k))))"}, {"cn": "MasterCCcore\uff0c\u6765\u81eaCCNV\u7684\u5f53\u524d\u662f\u5426\u4e3a\u4e3b\u63a7CC\u4fe1\u606f", "en": "MasterCCcore shows whether the status from CCNV is the main controlled CC.", "code": "if (ATOcontrolTimeValid(k) == True)    MasterCCcore = NonVitalRequest.MasterCcCore(k)else:    MasterCCcore = False"}, {"cn": "PSDzoneStatus_A, \u5982\u679cATP\u6240\u5728\u4e3a\u4e3b\u63a7CC\uff0c\u5219\u5bf9A\u4fa7PSD\u72b6\u6001\u7684\u66f4\u65b0\u89c4\u5219\u5982\u4e0b\uff1a", "en": "If the ATP is the master CC, then the A-side PSD state updating rules are as follows:", "code": "if (MasterCCcore(k) == True)    if ((PSDoperation_A.Id == None) or (PSDoperation_A.Id != PSDid_A(k)))        PSDzoneStatus_A.Id(k)= None        PSDzoneStatus_A.Validity = 0        PSDzoneStatus_A.AllPSDclosed = False    else:        PSDzoneStatus_A(k).Id = PSDoperation_A(k).Id        if (UsingPSDstatusFromCI(k))             PSDzoneStatus_A.Validity(k) = TableOfPSDPlatform[PSDid_A(k)].DoorStatusValidityTime             PSDzoneStatus_A.AllPSDclosed(k) = TableOfPSDPlatform[PSDid_A(k)].DoorClosed        elif (CoercedPermissive(TrackMap.PSDs[PSDid_A(k)].CoercedPermissive, k))             PSDzoneStatus_A.Validity = REPORT_AGE_MAX             PSDzoneStatus_A.AllPSDclosed = True        elif (CoercedRestrictive(TrackMap.PSDs[PSDid_A(k)].NotCoercedRestrictive, k))             PSDzoneStatus_A.Validity = REPORT_AGE_MAX             PSDzoneStatus_A.AllPSDclosed = False        else:             PSDzoneStatus_A.Validity(k) = ReceivedVariantReport[LineSectionOfPSD].ValidityTime             PSDzoneStatus_A.AllPSDclosed(k)= VariantValue(TrackMap.PSDs[PSDid_A(k)].Variant, k)"}, {"cn": "PSDzoneStatus_B, \u5982\u679cATP\u6240\u5728\u4e3a\u4e3b\u63a7CC\uff0c\u5219\u5bf9B\u4fa7PSD\u72b6\u6001\u7684\u66f4\u65b0\u89c4\u5219\u5982\u4e0b\uff1a", "en": "If the ATP is the master CC, then the B-side PSD state updating rules are as follows:", "code": "if (MasterCCcore(k) == True)    if ((PSDoperation_B.Id == None) or (PSDoperation_B.Id != PSDid_B(k)))        PSDzoneStatus_B.Id(k)= None        PSDzoneStatus_B.Validity = 0        PSDzoneStatus_B.AllPSDclosed = False    else:        PSDzoneStatus_B.Id(k)= PSDoperation_B.Id        if (UsingPSDstatusFromCI(k))             PSDzoneStatus_B.Validity(k) = TableOfPSDPlatform[PSDid_B(k)].DoorStatusValidityTime             PSDzoneStatus_B.AllPSDclosed(k) = TableOfPSDPlatform[PSDid_B(k)].DoorClosed        elif (CoercedPermissive(TrackMap.PSDs[PSDid_B(k)].CoercedPermissive, k))             PSDzoneStatus_B.Validity = REPORT_AGE_MAX             PSDzoneStatus_B.AllPSDclosed = True        elif (CoercedRestrictive(TrackMap.PSDs[PSDid_B(k)].NotCoercedRestrictive, k))             PSDzoneStatus_B.Validity =  REPORT_AGE_MAX             PSDzoneStatus_B.AllPSDclosed = False        else:             PSDzoneStatus_B.Validity(k) = ReceivedVariantReport[LineSectionOfPSD].ValidityTime             PSDzoneStatus_B.AllPSDclosed(k)= VariantValue(TrackMap.PSDs[PSDid_B(k)].Variant, k)"}, {"cn": "\u5982\u679cATP\u6240\u5728\u4e3a\u5907\u673aCC\uff0c\u5219\u5bf9A\u4fa7PSD\u72b6\u6001\u7684\u66f4\u65b0\u89c4\u5219\u5982\u4e0b\uff1a", "en": "If the ATP is not the master CC, then the A-side PSD state updating rules are as follows:", "code": "if (MasterCCcore != True)    if (OtherATPmessageAvailable(k) == True)        PSDzoneStatus_A.Id = OtherATP.PsdIdSide_A        if (PSDzoneStatus_A.Id(k) != None)             PSDzoneStatus_A.Validity(k) = (OtherATP.PsdValiditySide_A                                     - Message.ModularSub(ATPtime(k), OtherATP.LatestTimeOtherCore))             PSDzoneStatus_A.AllPSDclosed(k) = (OtherATP.PsdClosedSide_A                                                       and (PSDzoneStatus_A.Validity(k) > 0))        else:             PSDzoneStatus_A.Validity = 0             PSDzoneStatus_A.AllPSDclosed = False    elif (PSDzoneStatus_A.Id(k-1) != None)             PSDzoneStatus_A.Id = PSDzoneStatus_A.Id(k-1)             PSDzoneStatus_A.Validity = PSDzoneStatus_A.Validity(k-1)- 1             PSDzoneStatus_A.AllPSDclosed(k) = (PSDzoneStatus_A.AllPSDclosed(k-1)                                                       and (PSDzoneStatus_A.Validity(k) > 0))    else:         PSDzoneStatus_A.Validity = 0         PSDzoneStatus_A.AllPSDclosed = False"}, {"cn": "\u5982\u679cATP\u6240\u5728\u4e3a\u5907\u673aCC\uff0c\u5219\u5bf9B\u4fa7PSD\u72b6\u6001\u7684\u66f4\u65b0\u89c4\u5219\u5982\u4e0b\uff1a", "en": "If the ATP is not the master CC, then the B-side PSD state updating rules are as follows:", "code": "if (MasterCCcore != True)    if (OtherATPmessageAvailable(k) == True)        PSDzoneStatus_B.Id = OtherATP.PsdIdSide_B        if (PSDzoneStatus_B.Id(k) != None)             PSDzoneStatus_B.Validity(k) = (OtherATP.PsdValiditySide_B                                     - Message.ModularSub(ATPtime(k), OtherATP.LatestTimeOtherCore))             PSDzoneStatus_B.AllPSDclosed(k)               = OtherATP.PsdClosedSide_B                 and (PSDzoneStatus_B.Validity(k) > 0)        else:             PSDzoneStatus_B.Validity = 0             PSDzoneStatus_B.AllPSDclosed = False    elif (PSDzoneStatus_B.Id(k-1) != None)             PSDzoneStatus_B.Id = PSDzoneStatus_B.Id(k-1)             PSDzoneStatus_B.Validity = PSDzoneStatus_B.Validity(k-1) - 1             PSDzoneStatus_B.AllPSDclosed(k)               = PSDzoneStatus_B.AllPSDclosed(k-1)                 and (PSDzoneStatus_B.Validity(k) > 0)    else:         PSDzoneStatus_B.Validity = 0         PSDzoneStatus_B.AllPSDclosed = False"}, {"cn": "PSDstatusNonVital_A\uff0c\u7528\u4e8eCCNV\u53d1\u9001\u7ed9DMI\u663e\u793a\u7684A\u4fa7PSD\u72b6\u6001%def PSDstatusNonVital_A(k):if (PSDzoneStatus_A(k).Id is Noneor PSDzoneStatus_A(k).Validity <= 0):return PSD_STATE_UNKNOWNelif (PSDzoneStatus_A(k).AllPSDclosed):return PSD_STATE_CLOSEDelse:return PSD_STATE_OPENED#@PSDstatusNonVital_B\uff0c\u7528\u4e8eCCNV\u53d1\u9001\u7ed9DMI\u663e\u793a\u7684B\u4fa7PSD\u72b6\u6001%def PSDstatusNonVital_B(k):if (PSDzoneStatus_B(k).Id is Noneor PSDzoneStatus_B(k).Validity <= 0):return PSD_STATE_UNKNOWNelif (PSDzoneStatus_B(k).AllPSDclosed):return PSD_STATE_CLOSEDelse:return PSD_STATE_OPENED#@PSDmanagerOrder_A\uff0cA\u4fa7PSD\u7684\u63a7\u5236\u547d\u4ee4\u4fe1\u606f\uff0c\u5176\u7ed3\u6784\u4e3aST_PSD_MANAGE\u3002\u5176\u4e2d\u5982\u679c\u6765\u81eaCCNV\u7684A\u4fa7PSD\u6807\u8bc6\u4e0d\u7b49\u4e8eATP\u8bfb\u53d6SGD\u4e2dA\u4fa7\u7684\u6807\u8bc6\uff0c\u5219\u7981\u6b62\u4f7f\u7528CCNV\u7684\u6807\u8bc6\u5f00\u95e8\u3002", "en": "The rules to generate the PSD manage order on side A shall follow the pseudo-codes. In which if the PSD id from CCNV is not equal to the id in ATP's track map, ATP shall prohibit the PSD opening.", "code": "def PSDmanagerOrder_A(k):    PSDmanagerOrder_A.Id = PSDoperation_A.Id(k)    if (PSDoperation_A.Id(k) == PSDid_A(k)        and PSDoperation_A.Id(k) is not None        and not PSDoperation_A.ClosingOrder(k)        and PSDoperation_A.OpeningOrder(k)        and EnableDoorOpening_A(k)):        PSDmanagerOrder_A.Order = Open_PSD_Configuration    elif (not PSDoperation_A.OpeningOrder(k)           and PSDoperation_A.ClosingOrder(k)):        PSDmanagerOrder_A.Order = Close_PSD_Of_Platform    else:        PSDmanagerOrder_A.Order = None    return PSDmanagerOrder_A "}]